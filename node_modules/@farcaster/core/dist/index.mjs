var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../../node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "../../node_modules/tsup/assets/esm_shims.js"() {
  }
});

// ../../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err10) {
          if (pending) {
            pending = false;
            if (err10)
              reject(err10);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err10) {
          if (pending) {
            pending = false;
            reject(err10);
          }
        }
      });
    }
  }
});

// ../../node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// ../../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// ../../node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber2(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber3(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask2 = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask2) >>> 0;
      this.lo = (this.lo << 1 ^ mask2) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask2 = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask2) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask2) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_esm_shims();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet10(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge2;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString2() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err10, response) {
            if (err10) {
              self2.emit("error", err10, method);
              return callback(err10);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err11) {
                self2.emit("error", err11, method);
                return callback(err11);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err10) {
        self2.emit("error", err10, method);
        setTimeout(function() {
          callback(err10);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_esm_shims();
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = {};
  }
});

// ../../node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_esm_shims();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/lodash.mergewith/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.mergewith/index.js"(exports2, module2) {
    init_esm_shims();
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module2.exports = mergeWith2;
  }
});

// src/index.ts
init_esm_shims();

// src/protobufs/index.ts
init_esm_shims();

// src/protobufs/generated/gossip.ts
init_esm_shims();

// ../../node_modules/long/index.js
init_esm_shims();
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch (e) {
}
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}
Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache)
      INT_CACHE[value] = obj;
    return obj;
  }
}
Long.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
Long.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  var p;
  if ((p = str.indexOf("-")) > 0)
    throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number")
    return fromNumber(val, unsigned);
  if (typeof val === "string")
    return fromString(val, unsigned);
  return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else
      return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero())
      return digits + result;
    else {
      while (digits.length < 6)
        digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val & 1 << bit) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
    /* validates */
    other
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
    /* validates */
    other
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
    /* validates */
    other
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.eq(other))
    return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg)
    return -1;
  if (!thisNeg && otherNeg)
    return 1;
  if (!this.unsigned)
    return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE))
    return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend))
    addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend))
    subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero())
    return this;
  if (!isLong(multiplier))
    multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm["mul"](
      this.low,
      this.high,
      multiplier.low,
      multiplier.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (multiplier.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE))
    return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative())
      return this.neg().mul(multiplier.neg());
    else
      return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (divisor.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE))
        return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative())
        return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative())
      return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned)
      divisor = divisor.toUnsigned();
    if (divisor.gt(this))
      return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero())
      approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function and(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
  else
    return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
  if (numBits === 32)
    return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b;
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  if (numBits === 32)
    return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b;
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  if (numBits === 32)
    return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(
    bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
    bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
    unsigned
  );
};
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(
    bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
    bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
    unsigned
  );
};
var long_default = Long;

// src/protobufs/generated/gossip.ts
var import_minimal3 = __toESM(require_minimal2());

// src/protobufs/generated/message.ts
init_esm_shims();
var import_minimal2 = __toESM(require_minimal2());

// src/protobufs/generated/username_proof.ts
init_esm_shims();
var import_minimal = __toESM(require_minimal2());
var UserNameType = /* @__PURE__ */ ((UserNameType2) => {
  UserNameType2[UserNameType2["USERNAME_TYPE_NONE"] = 0] = "USERNAME_TYPE_NONE";
  UserNameType2[UserNameType2["USERNAME_TYPE_FNAME"] = 1] = "USERNAME_TYPE_FNAME";
  UserNameType2[UserNameType2["USERNAME_TYPE_ENS_L1"] = 2] = "USERNAME_TYPE_ENS_L1";
  return UserNameType2;
})(UserNameType || {});
function userNameTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "USERNAME_TYPE_NONE":
      return 0 /* USERNAME_TYPE_NONE */;
    case 1:
    case "USERNAME_TYPE_FNAME":
      return 1 /* USERNAME_TYPE_FNAME */;
    case 2:
    case "USERNAME_TYPE_ENS_L1":
      return 2 /* USERNAME_TYPE_ENS_L1 */;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum UserNameType");
  }
}
function userNameTypeToJSON(object) {
  switch (object) {
    case 0 /* USERNAME_TYPE_NONE */:
      return "USERNAME_TYPE_NONE";
    case 1 /* USERNAME_TYPE_FNAME */:
      return "USERNAME_TYPE_FNAME";
    case 2 /* USERNAME_TYPE_ENS_L1 */:
      return "USERNAME_TYPE_ENS_L1";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum UserNameType");
  }
}
function createBaseUserNameProof() {
  return {
    timestamp: 0,
    name: new Uint8Array(),
    owner: new Uint8Array(),
    signature: new Uint8Array(),
    fid: 0,
    type: 0
  };
}
var UserNameProof = {
  encode(message, writer = import_minimal.default.Writer.create()) {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint64(message.timestamp);
    }
    if (message.name.length !== 0) {
      writer.uint32(18).bytes(message.name);
    }
    if (message.owner.length !== 0) {
      writer.uint32(26).bytes(message.owner);
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    if (message.fid !== 0) {
      writer.uint32(40).uint64(message.fid);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserNameProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.timestamp = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.name = reader.bytes();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.owner = reader.bytes();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.signature = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.fid = longToNumber(reader.uint64());
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,
      name: isSet(object.name) ? bytesFromBase64(object.name) : new Uint8Array(),
      owner: isSet(object.owner) ? bytesFromBase64(object.owner) : new Uint8Array(),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(),
      fid: isSet(object.fid) ? Number(object.fid) : 0,
      type: isSet(object.type) ? userNameTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.name !== void 0 && (obj.name = base64FromBytes(message.name !== void 0 ? message.name : new Uint8Array()));
    message.owner !== void 0 && (obj.owner = base64FromBytes(message.owner !== void 0 ? message.owner : new Uint8Array()));
    message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.type !== void 0 && (obj.type = userNameTypeToJSON(message.type));
    return obj;
  },
  create(base) {
    return UserNameProof.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseUserNameProof();
    message.timestamp = (_a = object.timestamp) != null ? _a : 0;
    message.name = (_b = object.name) != null ? _b : new Uint8Array();
    message.owner = (_c = object.owner) != null ? _c : new Uint8Array();
    message.signature = (_d = object.signature) != null ? _d : new Uint8Array();
    message.fid = (_e = object.fid) != null ? _e : 0;
    message.type = (_f = object.type) != null ? _f : 0;
    return message;
  }
};
var tsProtoGlobalThis = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}
function longToNumber(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal.default.util.Long !== long_default) {
  import_minimal.default.util.Long = long_default;
  import_minimal.default.configure();
}
function isSet(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/message.ts
var HashScheme = /* @__PURE__ */ ((HashScheme2) => {
  HashScheme2[HashScheme2["NONE"] = 0] = "NONE";
  HashScheme2[HashScheme2["BLAKE3"] = 1] = "BLAKE3";
  return HashScheme2;
})(HashScheme || {});
function hashSchemeFromJSON(object) {
  switch (object) {
    case 0:
    case "HASH_SCHEME_NONE":
      return 0 /* NONE */;
    case 1:
    case "HASH_SCHEME_BLAKE3":
      return 1 /* BLAKE3 */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum HashScheme");
  }
}
function hashSchemeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "HASH_SCHEME_NONE";
    case 1 /* BLAKE3 */:
      return "HASH_SCHEME_BLAKE3";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum HashScheme");
  }
}
var SignatureScheme = /* @__PURE__ */ ((SignatureScheme2) => {
  SignatureScheme2[SignatureScheme2["NONE"] = 0] = "NONE";
  SignatureScheme2[SignatureScheme2["ED25519"] = 1] = "ED25519";
  SignatureScheme2[SignatureScheme2["EIP712"] = 2] = "EIP712";
  return SignatureScheme2;
})(SignatureScheme || {});
function signatureSchemeFromJSON(object) {
  switch (object) {
    case 0:
    case "SIGNATURE_SCHEME_NONE":
      return 0 /* NONE */;
    case 1:
    case "SIGNATURE_SCHEME_ED25519":
      return 1 /* ED25519 */;
    case 2:
    case "SIGNATURE_SCHEME_EIP712":
      return 2 /* EIP712 */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum SignatureScheme");
  }
}
function signatureSchemeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "SIGNATURE_SCHEME_NONE";
    case 1 /* ED25519 */:
      return "SIGNATURE_SCHEME_ED25519";
    case 2 /* EIP712 */:
      return "SIGNATURE_SCHEME_EIP712";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum SignatureScheme");
  }
}
var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2[MessageType2["NONE"] = 0] = "NONE";
  MessageType2[MessageType2["CAST_ADD"] = 1] = "CAST_ADD";
  MessageType2[MessageType2["CAST_REMOVE"] = 2] = "CAST_REMOVE";
  MessageType2[MessageType2["REACTION_ADD"] = 3] = "REACTION_ADD";
  MessageType2[MessageType2["REACTION_REMOVE"] = 4] = "REACTION_REMOVE";
  MessageType2[MessageType2["LINK_ADD"] = 5] = "LINK_ADD";
  MessageType2[MessageType2["LINK_REMOVE"] = 6] = "LINK_REMOVE";
  MessageType2[MessageType2["VERIFICATION_ADD_ETH_ADDRESS"] = 7] = "VERIFICATION_ADD_ETH_ADDRESS";
  MessageType2[MessageType2["VERIFICATION_REMOVE"] = 8] = "VERIFICATION_REMOVE";
  MessageType2[MessageType2["USER_DATA_ADD"] = 11] = "USER_DATA_ADD";
  MessageType2[MessageType2["USERNAME_PROOF"] = 12] = "USERNAME_PROOF";
  MessageType2[MessageType2["FRAME_ACTION"] = 13] = "FRAME_ACTION";
  MessageType2[MessageType2["LINK_COMPACT_STATE"] = 14] = "LINK_COMPACT_STATE";
  return MessageType2;
})(MessageType || {});
function messageTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "MESSAGE_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "MESSAGE_TYPE_CAST_ADD":
      return 1 /* CAST_ADD */;
    case 2:
    case "MESSAGE_TYPE_CAST_REMOVE":
      return 2 /* CAST_REMOVE */;
    case 3:
    case "MESSAGE_TYPE_REACTION_ADD":
      return 3 /* REACTION_ADD */;
    case 4:
    case "MESSAGE_TYPE_REACTION_REMOVE":
      return 4 /* REACTION_REMOVE */;
    case 5:
    case "MESSAGE_TYPE_LINK_ADD":
      return 5 /* LINK_ADD */;
    case 6:
    case "MESSAGE_TYPE_LINK_REMOVE":
      return 6 /* LINK_REMOVE */;
    case 7:
    case "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS":
      return 7 /* VERIFICATION_ADD_ETH_ADDRESS */;
    case 8:
    case "MESSAGE_TYPE_VERIFICATION_REMOVE":
      return 8 /* VERIFICATION_REMOVE */;
    case 11:
    case "MESSAGE_TYPE_USER_DATA_ADD":
      return 11 /* USER_DATA_ADD */;
    case 12:
    case "MESSAGE_TYPE_USERNAME_PROOF":
      return 12 /* USERNAME_PROOF */;
    case 13:
    case "MESSAGE_TYPE_FRAME_ACTION":
      return 13 /* FRAME_ACTION */;
    case 14:
    case "MESSAGE_TYPE_LINK_COMPACT_STATE":
      return 14 /* LINK_COMPACT_STATE */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum MessageType");
  }
}
function messageTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "MESSAGE_TYPE_NONE";
    case 1 /* CAST_ADD */:
      return "MESSAGE_TYPE_CAST_ADD";
    case 2 /* CAST_REMOVE */:
      return "MESSAGE_TYPE_CAST_REMOVE";
    case 3 /* REACTION_ADD */:
      return "MESSAGE_TYPE_REACTION_ADD";
    case 4 /* REACTION_REMOVE */:
      return "MESSAGE_TYPE_REACTION_REMOVE";
    case 5 /* LINK_ADD */:
      return "MESSAGE_TYPE_LINK_ADD";
    case 6 /* LINK_REMOVE */:
      return "MESSAGE_TYPE_LINK_REMOVE";
    case 7 /* VERIFICATION_ADD_ETH_ADDRESS */:
      return "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS";
    case 8 /* VERIFICATION_REMOVE */:
      return "MESSAGE_TYPE_VERIFICATION_REMOVE";
    case 11 /* USER_DATA_ADD */:
      return "MESSAGE_TYPE_USER_DATA_ADD";
    case 12 /* USERNAME_PROOF */:
      return "MESSAGE_TYPE_USERNAME_PROOF";
    case 13 /* FRAME_ACTION */:
      return "MESSAGE_TYPE_FRAME_ACTION";
    case 14 /* LINK_COMPACT_STATE */:
      return "MESSAGE_TYPE_LINK_COMPACT_STATE";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum MessageType");
  }
}
var FarcasterNetwork = /* @__PURE__ */ ((FarcasterNetwork4) => {
  FarcasterNetwork4[FarcasterNetwork4["NONE"] = 0] = "NONE";
  FarcasterNetwork4[FarcasterNetwork4["MAINNET"] = 1] = "MAINNET";
  FarcasterNetwork4[FarcasterNetwork4["TESTNET"] = 2] = "TESTNET";
  FarcasterNetwork4[FarcasterNetwork4["DEVNET"] = 3] = "DEVNET";
  return FarcasterNetwork4;
})(FarcasterNetwork || {});
function farcasterNetworkFromJSON(object) {
  switch (object) {
    case 0:
    case "FARCASTER_NETWORK_NONE":
      return 0 /* NONE */;
    case 1:
    case "FARCASTER_NETWORK_MAINNET":
      return 1 /* MAINNET */;
    case 2:
    case "FARCASTER_NETWORK_TESTNET":
      return 2 /* TESTNET */;
    case 3:
    case "FARCASTER_NETWORK_DEVNET":
      return 3 /* DEVNET */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum FarcasterNetwork");
  }
}
function farcasterNetworkToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "FARCASTER_NETWORK_NONE";
    case 1 /* MAINNET */:
      return "FARCASTER_NETWORK_MAINNET";
    case 2 /* TESTNET */:
      return "FARCASTER_NETWORK_TESTNET";
    case 3 /* DEVNET */:
      return "FARCASTER_NETWORK_DEVNET";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum FarcasterNetwork");
  }
}
var UserDataType = /* @__PURE__ */ ((UserDataType3) => {
  UserDataType3[UserDataType3["NONE"] = 0] = "NONE";
  UserDataType3[UserDataType3["PFP"] = 1] = "PFP";
  UserDataType3[UserDataType3["DISPLAY"] = 2] = "DISPLAY";
  UserDataType3[UserDataType3["BIO"] = 3] = "BIO";
  UserDataType3[UserDataType3["URL"] = 5] = "URL";
  UserDataType3[UserDataType3["USERNAME"] = 6] = "USERNAME";
  UserDataType3[UserDataType3["LOCATION"] = 7] = "LOCATION";
  UserDataType3[UserDataType3["TWITTER"] = 8] = "TWITTER";
  UserDataType3[UserDataType3["GITHUB"] = 9] = "GITHUB";
  return UserDataType3;
})(UserDataType || {});
function userDataTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "USER_DATA_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "USER_DATA_TYPE_PFP":
      return 1 /* PFP */;
    case 2:
    case "USER_DATA_TYPE_DISPLAY":
      return 2 /* DISPLAY */;
    case 3:
    case "USER_DATA_TYPE_BIO":
      return 3 /* BIO */;
    case 5:
    case "USER_DATA_TYPE_URL":
      return 5 /* URL */;
    case 6:
    case "USER_DATA_TYPE_USERNAME":
      return 6 /* USERNAME */;
    case 7:
    case "USER_DATA_TYPE_LOCATION":
      return 7 /* LOCATION */;
    case 8:
    case "USER_DATA_TYPE_TWITTER":
      return 8 /* TWITTER */;
    case 9:
    case "USER_DATA_TYPE_GITHUB":
      return 9 /* GITHUB */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum UserDataType");
  }
}
function userDataTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "USER_DATA_TYPE_NONE";
    case 1 /* PFP */:
      return "USER_DATA_TYPE_PFP";
    case 2 /* DISPLAY */:
      return "USER_DATA_TYPE_DISPLAY";
    case 3 /* BIO */:
      return "USER_DATA_TYPE_BIO";
    case 5 /* URL */:
      return "USER_DATA_TYPE_URL";
    case 6 /* USERNAME */:
      return "USER_DATA_TYPE_USERNAME";
    case 7 /* LOCATION */:
      return "USER_DATA_TYPE_LOCATION";
    case 8 /* TWITTER */:
      return "USER_DATA_TYPE_TWITTER";
    case 9 /* GITHUB */:
      return "USER_DATA_TYPE_GITHUB";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum UserDataType");
  }
}
var CastType = /* @__PURE__ */ ((CastType2) => {
  CastType2[CastType2["CAST"] = 0] = "CAST";
  CastType2[CastType2["LONG_CAST"] = 1] = "LONG_CAST";
  return CastType2;
})(CastType || {});
function castTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "CAST":
      return 0 /* CAST */;
    case 1:
    case "LONG_CAST":
      return 1 /* LONG_CAST */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum CastType");
  }
}
function castTypeToJSON(object) {
  switch (object) {
    case 0 /* CAST */:
      return "CAST";
    case 1 /* LONG_CAST */:
      return "LONG_CAST";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum CastType");
  }
}
var ReactionType = /* @__PURE__ */ ((ReactionType3) => {
  ReactionType3[ReactionType3["NONE"] = 0] = "NONE";
  ReactionType3[ReactionType3["LIKE"] = 1] = "LIKE";
  ReactionType3[ReactionType3["RECAST"] = 2] = "RECAST";
  return ReactionType3;
})(ReactionType || {});
function reactionTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "REACTION_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "REACTION_TYPE_LIKE":
      return 1 /* LIKE */;
    case 2:
    case "REACTION_TYPE_RECAST":
      return 2 /* RECAST */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum ReactionType");
  }
}
function reactionTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "REACTION_TYPE_NONE";
    case 1 /* LIKE */:
      return "REACTION_TYPE_LIKE";
    case 2 /* RECAST */:
      return "REACTION_TYPE_RECAST";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum ReactionType");
  }
}
var Protocol = /* @__PURE__ */ ((Protocol2) => {
  Protocol2[Protocol2["ETHEREUM"] = 0] = "ETHEREUM";
  Protocol2[Protocol2["SOLANA"] = 1] = "SOLANA";
  return Protocol2;
})(Protocol || {});
function protocolFromJSON(object) {
  switch (object) {
    case 0:
    case "PROTOCOL_ETHEREUM":
      return 0 /* ETHEREUM */;
    case 1:
    case "PROTOCOL_SOLANA":
      return 1 /* SOLANA */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum Protocol");
  }
}
function protocolToJSON(object) {
  switch (object) {
    case 0 /* ETHEREUM */:
      return "PROTOCOL_ETHEREUM";
    case 1 /* SOLANA */:
      return "PROTOCOL_SOLANA";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum Protocol");
  }
}
function createBaseMessage() {
  return {
    data: void 0,
    hash: new Uint8Array(),
    hashScheme: 0,
    signature: new Uint8Array(),
    signatureScheme: 0,
    signer: new Uint8Array(),
    dataBytes: void 0
  };
}
var Message = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.data !== void 0) {
      MessageData.encode(message.data, writer.uint32(10).fork()).ldelim();
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    if (message.hashScheme !== 0) {
      writer.uint32(24).int32(message.hashScheme);
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    if (message.signatureScheme !== 0) {
      writer.uint32(40).int32(message.signatureScheme);
    }
    if (message.signer.length !== 0) {
      writer.uint32(50).bytes(message.signer);
    }
    if (message.dataBytes !== void 0) {
      writer.uint32(58).bytes(message.dataBytes);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.data = MessageData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.hash = reader.bytes();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.hashScheme = reader.int32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.signature = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.signatureScheme = reader.int32();
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.signer = reader.bytes();
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.dataBytes = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      data: isSet2(object.data) ? MessageData.fromJSON(object.data) : void 0,
      hash: isSet2(object.hash) ? bytesFromBase642(object.hash) : new Uint8Array(),
      hashScheme: isSet2(object.hashScheme) ? hashSchemeFromJSON(object.hashScheme) : 0,
      signature: isSet2(object.signature) ? bytesFromBase642(object.signature) : new Uint8Array(),
      signatureScheme: isSet2(object.signatureScheme) ? signatureSchemeFromJSON(object.signatureScheme) : 0,
      signer: isSet2(object.signer) ? bytesFromBase642(object.signer) : new Uint8Array(),
      dataBytes: isSet2(object.dataBytes) ? bytesFromBase642(object.dataBytes) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.data !== void 0 && (obj.data = message.data ? MessageData.toJSON(message.data) : void 0);
    message.hash !== void 0 && (obj.hash = base64FromBytes2(message.hash !== void 0 ? message.hash : new Uint8Array()));
    message.hashScheme !== void 0 && (obj.hashScheme = hashSchemeToJSON(message.hashScheme));
    message.signature !== void 0 && (obj.signature = base64FromBytes2(message.signature !== void 0 ? message.signature : new Uint8Array()));
    message.signatureScheme !== void 0 && (obj.signatureScheme = signatureSchemeToJSON(message.signatureScheme));
    message.signer !== void 0 && (obj.signer = base64FromBytes2(message.signer !== void 0 ? message.signer : new Uint8Array()));
    message.dataBytes !== void 0 && (obj.dataBytes = message.dataBytes !== void 0 ? base64FromBytes2(message.dataBytes) : void 0);
    return obj;
  },
  create(base) {
    return Message.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseMessage();
    message.data = object.data !== void 0 && object.data !== null ? MessageData.fromPartial(object.data) : void 0;
    message.hash = (_a = object.hash) != null ? _a : new Uint8Array();
    message.hashScheme = (_b = object.hashScheme) != null ? _b : 0;
    message.signature = (_c = object.signature) != null ? _c : new Uint8Array();
    message.signatureScheme = (_d = object.signatureScheme) != null ? _d : 0;
    message.signer = (_e = object.signer) != null ? _e : new Uint8Array();
    message.dataBytes = (_f = object.dataBytes) != null ? _f : void 0;
    return message;
  }
};
function createBaseMessageData() {
  return {
    type: 0,
    fid: 0,
    timestamp: 0,
    network: 0,
    castAddBody: void 0,
    castRemoveBody: void 0,
    reactionBody: void 0,
    verificationAddAddressBody: void 0,
    verificationRemoveBody: void 0,
    userDataBody: void 0,
    linkBody: void 0,
    usernameProofBody: void 0,
    frameActionBody: void 0,
    linkCompactStateBody: void 0
  };
}
var MessageData = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.fid !== 0) {
      writer.uint32(16).uint64(message.fid);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.network !== 0) {
      writer.uint32(32).int32(message.network);
    }
    if (message.castAddBody !== void 0) {
      CastAddBody.encode(message.castAddBody, writer.uint32(42).fork()).ldelim();
    }
    if (message.castRemoveBody !== void 0) {
      CastRemoveBody.encode(message.castRemoveBody, writer.uint32(50).fork()).ldelim();
    }
    if (message.reactionBody !== void 0) {
      ReactionBody.encode(message.reactionBody, writer.uint32(58).fork()).ldelim();
    }
    if (message.verificationAddAddressBody !== void 0) {
      VerificationAddAddressBody.encode(message.verificationAddAddressBody, writer.uint32(74).fork()).ldelim();
    }
    if (message.verificationRemoveBody !== void 0) {
      VerificationRemoveBody.encode(message.verificationRemoveBody, writer.uint32(82).fork()).ldelim();
    }
    if (message.userDataBody !== void 0) {
      UserDataBody.encode(message.userDataBody, writer.uint32(98).fork()).ldelim();
    }
    if (message.linkBody !== void 0) {
      LinkBody.encode(message.linkBody, writer.uint32(114).fork()).ldelim();
    }
    if (message.usernameProofBody !== void 0) {
      UserNameProof.encode(message.usernameProofBody, writer.uint32(122).fork()).ldelim();
    }
    if (message.frameActionBody !== void 0) {
      FrameActionBody.encode(message.frameActionBody, writer.uint32(130).fork()).ldelim();
    }
    if (message.linkCompactStateBody !== void 0) {
      LinkCompactStateBody.encode(message.linkCompactStateBody, writer.uint32(138).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.fid = longToNumber2(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.timestamp = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.network = reader.int32();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.castAddBody = CastAddBody.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.castRemoveBody = CastRemoveBody.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.reactionBody = ReactionBody.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag != 74) {
            break;
          }
          message.verificationAddAddressBody = VerificationAddAddressBody.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag != 82) {
            break;
          }
          message.verificationRemoveBody = VerificationRemoveBody.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag != 98) {
            break;
          }
          message.userDataBody = UserDataBody.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag != 114) {
            break;
          }
          message.linkBody = LinkBody.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag != 122) {
            break;
          }
          message.usernameProofBody = UserNameProof.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag != 130) {
            break;
          }
          message.frameActionBody = FrameActionBody.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag != 138) {
            break;
          }
          message.linkCompactStateBody = LinkCompactStateBody.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? messageTypeFromJSON(object.type) : 0,
      fid: isSet2(object.fid) ? Number(object.fid) : 0,
      timestamp: isSet2(object.timestamp) ? Number(object.timestamp) : 0,
      network: isSet2(object.network) ? farcasterNetworkFromJSON(object.network) : 0,
      castAddBody: isSet2(object.castAddBody) ? CastAddBody.fromJSON(object.castAddBody) : void 0,
      castRemoveBody: isSet2(object.castRemoveBody) ? CastRemoveBody.fromJSON(object.castRemoveBody) : void 0,
      reactionBody: isSet2(object.reactionBody) ? ReactionBody.fromJSON(object.reactionBody) : void 0,
      verificationAddAddressBody: isSet2(object.verificationAddAddressBody) ? VerificationAddAddressBody.fromJSON(object.verificationAddAddressBody) : void 0,
      verificationRemoveBody: isSet2(object.verificationRemoveBody) ? VerificationRemoveBody.fromJSON(object.verificationRemoveBody) : void 0,
      userDataBody: isSet2(object.userDataBody) ? UserDataBody.fromJSON(object.userDataBody) : void 0,
      linkBody: isSet2(object.linkBody) ? LinkBody.fromJSON(object.linkBody) : void 0,
      usernameProofBody: isSet2(object.usernameProofBody) ? UserNameProof.fromJSON(object.usernameProofBody) : void 0,
      frameActionBody: isSet2(object.frameActionBody) ? FrameActionBody.fromJSON(object.frameActionBody) : void 0,
      linkCompactStateBody: isSet2(object.linkCompactStateBody) ? LinkCompactStateBody.fromJSON(object.linkCompactStateBody) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = messageTypeToJSON(message.type));
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.network !== void 0 && (obj.network = farcasterNetworkToJSON(message.network));
    message.castAddBody !== void 0 && (obj.castAddBody = message.castAddBody ? CastAddBody.toJSON(message.castAddBody) : void 0);
    message.castRemoveBody !== void 0 && (obj.castRemoveBody = message.castRemoveBody ? CastRemoveBody.toJSON(message.castRemoveBody) : void 0);
    message.reactionBody !== void 0 && (obj.reactionBody = message.reactionBody ? ReactionBody.toJSON(message.reactionBody) : void 0);
    message.verificationAddAddressBody !== void 0 && (obj.verificationAddAddressBody = message.verificationAddAddressBody ? VerificationAddAddressBody.toJSON(message.verificationAddAddressBody) : void 0);
    message.verificationRemoveBody !== void 0 && (obj.verificationRemoveBody = message.verificationRemoveBody ? VerificationRemoveBody.toJSON(message.verificationRemoveBody) : void 0);
    message.userDataBody !== void 0 && (obj.userDataBody = message.userDataBody ? UserDataBody.toJSON(message.userDataBody) : void 0);
    message.linkBody !== void 0 && (obj.linkBody = message.linkBody ? LinkBody.toJSON(message.linkBody) : void 0);
    message.usernameProofBody !== void 0 && (obj.usernameProofBody = message.usernameProofBody ? UserNameProof.toJSON(message.usernameProofBody) : void 0);
    message.frameActionBody !== void 0 && (obj.frameActionBody = message.frameActionBody ? FrameActionBody.toJSON(message.frameActionBody) : void 0);
    message.linkCompactStateBody !== void 0 && (obj.linkCompactStateBody = message.linkCompactStateBody ? LinkCompactStateBody.toJSON(message.linkCompactStateBody) : void 0);
    return obj;
  },
  create(base) {
    return MessageData.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseMessageData();
    message.type = (_a = object.type) != null ? _a : 0;
    message.fid = (_b = object.fid) != null ? _b : 0;
    message.timestamp = (_c = object.timestamp) != null ? _c : 0;
    message.network = (_d = object.network) != null ? _d : 0;
    message.castAddBody = object.castAddBody !== void 0 && object.castAddBody !== null ? CastAddBody.fromPartial(object.castAddBody) : void 0;
    message.castRemoveBody = object.castRemoveBody !== void 0 && object.castRemoveBody !== null ? CastRemoveBody.fromPartial(object.castRemoveBody) : void 0;
    message.reactionBody = object.reactionBody !== void 0 && object.reactionBody !== null ? ReactionBody.fromPartial(object.reactionBody) : void 0;
    message.verificationAddAddressBody = object.verificationAddAddressBody !== void 0 && object.verificationAddAddressBody !== null ? VerificationAddAddressBody.fromPartial(object.verificationAddAddressBody) : void 0;
    message.verificationRemoveBody = object.verificationRemoveBody !== void 0 && object.verificationRemoveBody !== null ? VerificationRemoveBody.fromPartial(object.verificationRemoveBody) : void 0;
    message.userDataBody = object.userDataBody !== void 0 && object.userDataBody !== null ? UserDataBody.fromPartial(object.userDataBody) : void 0;
    message.linkBody = object.linkBody !== void 0 && object.linkBody !== null ? LinkBody.fromPartial(object.linkBody) : void 0;
    message.usernameProofBody = object.usernameProofBody !== void 0 && object.usernameProofBody !== null ? UserNameProof.fromPartial(object.usernameProofBody) : void 0;
    message.frameActionBody = object.frameActionBody !== void 0 && object.frameActionBody !== null ? FrameActionBody.fromPartial(object.frameActionBody) : void 0;
    message.linkCompactStateBody = object.linkCompactStateBody !== void 0 && object.linkCompactStateBody !== null ? LinkCompactStateBody.fromPartial(object.linkCompactStateBody) : void 0;
    return message;
  }
};
function createBaseUserDataBody() {
  return { type: 0, value: "" };
}
var UserDataBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? userDataTypeFromJSON(object.type) : 0,
      value: isSet2(object.value) ? String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = userDataTypeToJSON(message.type));
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  create(base) {
    return UserDataBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseUserDataBody();
    message.type = (_a = object.type) != null ? _a : 0;
    message.value = (_b = object.value) != null ? _b : "";
    return message;
  }
};
function createBaseEmbed() {
  return { url: void 0, castId: void 0 };
}
var Embed = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.url !== void 0) {
      writer.uint32(10).string(message.url);
    }
    if (message.castId !== void 0) {
      CastId.encode(message.castId, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEmbed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.castId = CastId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet2(object.url) ? String(object.url) : void 0,
      castId: isSet2(object.castId) ? CastId.fromJSON(object.castId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.castId !== void 0 && (obj.castId = message.castId ? CastId.toJSON(message.castId) : void 0);
    return obj;
  },
  create(base) {
    return Embed.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseEmbed();
    message.url = (_a = object.url) != null ? _a : void 0;
    message.castId = object.castId !== void 0 && object.castId !== null ? CastId.fromPartial(object.castId) : void 0;
    return message;
  }
};
function createBaseCastAddBody() {
  return {
    embedsDeprecated: [],
    mentions: [],
    parentCastId: void 0,
    parentUrl: void 0,
    text: "",
    mentionsPositions: [],
    embeds: [],
    type: 0
  };
}
var CastAddBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    for (const v of message.embedsDeprecated) {
      writer.uint32(10).string(v);
    }
    writer.uint32(18).fork();
    for (const v of message.mentions) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.parentCastId !== void 0) {
      CastId.encode(message.parentCastId, writer.uint32(26).fork()).ldelim();
    }
    if (message.parentUrl !== void 0) {
      writer.uint32(58).string(message.parentUrl);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    writer.uint32(42).fork();
    for (const v of message.mentionsPositions) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.embeds) {
      Embed.encode(v, writer.uint32(50).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCastAddBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.embedsDeprecated.push(reader.string());
          continue;
        case 2:
          if (tag == 16) {
            message.mentions.push(longToNumber2(reader.uint64()));
            continue;
          }
          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mentions.push(longToNumber2(reader.uint64()));
            }
            continue;
          }
          break;
        case 3:
          if (tag != 26) {
            break;
          }
          message.parentCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.parentUrl = reader.string();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.text = reader.string();
          continue;
        case 5:
          if (tag == 40) {
            message.mentionsPositions.push(reader.uint32());
            continue;
          }
          if (tag == 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mentionsPositions.push(reader.uint32());
            }
            continue;
          }
          break;
        case 6:
          if (tag != 50) {
            break;
          }
          message.embeds.push(Embed.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag != 64) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      embedsDeprecated: Array.isArray(object == null ? void 0 : object.embedsDeprecated) ? object.embedsDeprecated.map((e) => String(e)) : [],
      mentions: Array.isArray(object == null ? void 0 : object.mentions) ? object.mentions.map((e) => Number(e)) : [],
      parentCastId: isSet2(object.parentCastId) ? CastId.fromJSON(object.parentCastId) : void 0,
      parentUrl: isSet2(object.parentUrl) ? String(object.parentUrl) : void 0,
      text: isSet2(object.text) ? String(object.text) : "",
      mentionsPositions: Array.isArray(object == null ? void 0 : object.mentionsPositions) ? object.mentionsPositions.map((e) => Number(e)) : [],
      embeds: Array.isArray(object == null ? void 0 : object.embeds) ? object.embeds.map((e) => Embed.fromJSON(e)) : [],
      type: isSet2(object.type) ? castTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.embedsDeprecated) {
      obj.embedsDeprecated = message.embedsDeprecated.map((e) => e);
    } else {
      obj.embedsDeprecated = [];
    }
    if (message.mentions) {
      obj.mentions = message.mentions.map((e) => Math.round(e));
    } else {
      obj.mentions = [];
    }
    message.parentCastId !== void 0 && (obj.parentCastId = message.parentCastId ? CastId.toJSON(message.parentCastId) : void 0);
    message.parentUrl !== void 0 && (obj.parentUrl = message.parentUrl);
    message.text !== void 0 && (obj.text = message.text);
    if (message.mentionsPositions) {
      obj.mentionsPositions = message.mentionsPositions.map((e) => Math.round(e));
    } else {
      obj.mentionsPositions = [];
    }
    if (message.embeds) {
      obj.embeds = message.embeds.map((e) => e ? Embed.toJSON(e) : void 0);
    } else {
      obj.embeds = [];
    }
    message.type !== void 0 && (obj.type = castTypeToJSON(message.type));
    return obj;
  },
  create(base) {
    return CastAddBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseCastAddBody();
    message.embedsDeprecated = ((_a = object.embedsDeprecated) == null ? void 0 : _a.map((e) => e)) || [];
    message.mentions = ((_b = object.mentions) == null ? void 0 : _b.map((e) => e)) || [];
    message.parentCastId = object.parentCastId !== void 0 && object.parentCastId !== null ? CastId.fromPartial(object.parentCastId) : void 0;
    message.parentUrl = (_c = object.parentUrl) != null ? _c : void 0;
    message.text = (_d = object.text) != null ? _d : "";
    message.mentionsPositions = ((_e = object.mentionsPositions) == null ? void 0 : _e.map((e) => e)) || [];
    message.embeds = ((_f = object.embeds) == null ? void 0 : _f.map((e) => Embed.fromPartial(e))) || [];
    message.type = (_g = object.type) != null ? _g : 0;
    return message;
  }
};
function createBaseCastRemoveBody() {
  return { targetHash: new Uint8Array() };
}
var CastRemoveBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.targetHash.length !== 0) {
      writer.uint32(10).bytes(message.targetHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCastRemoveBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.targetHash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { targetHash: isSet2(object.targetHash) ? bytesFromBase642(object.targetHash) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.targetHash !== void 0 && (obj.targetHash = base64FromBytes2(message.targetHash !== void 0 ? message.targetHash : new Uint8Array()));
    return obj;
  },
  create(base) {
    return CastRemoveBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseCastRemoveBody();
    message.targetHash = (_a = object.targetHash) != null ? _a : new Uint8Array();
    return message;
  }
};
function createBaseCastId() {
  return { fid: 0, hash: new Uint8Array() };
}
var CastId = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCastId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber2(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.hash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet2(object.fid) ? Number(object.fid) : 0,
      hash: isSet2(object.hash) ? bytesFromBase642(object.hash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.hash !== void 0 && (obj.hash = base64FromBytes2(message.hash !== void 0 ? message.hash : new Uint8Array()));
    return obj;
  },
  create(base) {
    return CastId.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCastId();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.hash = (_b = object.hash) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseReactionBody() {
  return { type: 0, targetCastId: void 0, targetUrl: void 0 };
}
var ReactionBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.targetCastId !== void 0) {
      CastId.encode(message.targetCastId, writer.uint32(18).fork()).ldelim();
    }
    if (message.targetUrl !== void 0) {
      writer.uint32(26).string(message.targetUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReactionBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.targetCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.targetUrl = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? reactionTypeFromJSON(object.type) : 0,
      targetCastId: isSet2(object.targetCastId) ? CastId.fromJSON(object.targetCastId) : void 0,
      targetUrl: isSet2(object.targetUrl) ? String(object.targetUrl) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = reactionTypeToJSON(message.type));
    message.targetCastId !== void 0 && (obj.targetCastId = message.targetCastId ? CastId.toJSON(message.targetCastId) : void 0);
    message.targetUrl !== void 0 && (obj.targetUrl = message.targetUrl);
    return obj;
  },
  create(base) {
    return ReactionBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseReactionBody();
    message.type = (_a = object.type) != null ? _a : 0;
    message.targetCastId = object.targetCastId !== void 0 && object.targetCastId !== null ? CastId.fromPartial(object.targetCastId) : void 0;
    message.targetUrl = (_b = object.targetUrl) != null ? _b : void 0;
    return message;
  }
};
function createBaseVerificationAddAddressBody() {
  return {
    address: new Uint8Array(),
    claimSignature: new Uint8Array(),
    blockHash: new Uint8Array(),
    verificationType: 0,
    chainId: 0,
    protocol: 0
  };
}
var VerificationAddAddressBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.claimSignature.length !== 0) {
      writer.uint32(18).bytes(message.claimSignature);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(26).bytes(message.blockHash);
    }
    if (message.verificationType !== 0) {
      writer.uint32(32).uint32(message.verificationType);
    }
    if (message.chainId !== 0) {
      writer.uint32(40).uint32(message.chainId);
    }
    if (message.protocol !== 0) {
      writer.uint32(56).int32(message.protocol);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVerificationAddAddressBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.address = reader.bytes();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.claimSignature = reader.bytes();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.blockHash = reader.bytes();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.verificationType = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.chainId = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }
          message.protocol = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet2(object.address) ? bytesFromBase642(object.address) : new Uint8Array(),
      claimSignature: isSet2(object.claimSignature) ? bytesFromBase642(object.claimSignature) : new Uint8Array(),
      blockHash: isSet2(object.blockHash) ? bytesFromBase642(object.blockHash) : new Uint8Array(),
      verificationType: isSet2(object.verificationType) ? Number(object.verificationType) : 0,
      chainId: isSet2(object.chainId) ? Number(object.chainId) : 0,
      protocol: isSet2(object.protocol) ? protocolFromJSON(object.protocol) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = base64FromBytes2(message.address !== void 0 ? message.address : new Uint8Array()));
    message.claimSignature !== void 0 && (obj.claimSignature = base64FromBytes2(
      message.claimSignature !== void 0 ? message.claimSignature : new Uint8Array()
    ));
    message.blockHash !== void 0 && (obj.blockHash = base64FromBytes2(message.blockHash !== void 0 ? message.blockHash : new Uint8Array()));
    message.verificationType !== void 0 && (obj.verificationType = Math.round(message.verificationType));
    message.chainId !== void 0 && (obj.chainId = Math.round(message.chainId));
    message.protocol !== void 0 && (obj.protocol = protocolToJSON(message.protocol));
    return obj;
  },
  create(base) {
    return VerificationAddAddressBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseVerificationAddAddressBody();
    message.address = (_a = object.address) != null ? _a : new Uint8Array();
    message.claimSignature = (_b = object.claimSignature) != null ? _b : new Uint8Array();
    message.blockHash = (_c = object.blockHash) != null ? _c : new Uint8Array();
    message.verificationType = (_d = object.verificationType) != null ? _d : 0;
    message.chainId = (_e = object.chainId) != null ? _e : 0;
    message.protocol = (_f = object.protocol) != null ? _f : 0;
    return message;
  }
};
function createBaseVerificationRemoveBody() {
  return { address: new Uint8Array(), protocol: 0 };
}
var VerificationRemoveBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.protocol !== 0) {
      writer.uint32(16).int32(message.protocol);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVerificationRemoveBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.address = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.protocol = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet2(object.address) ? bytesFromBase642(object.address) : new Uint8Array(),
      protocol: isSet2(object.protocol) ? protocolFromJSON(object.protocol) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = base64FromBytes2(message.address !== void 0 ? message.address : new Uint8Array()));
    message.protocol !== void 0 && (obj.protocol = protocolToJSON(message.protocol));
    return obj;
  },
  create(base) {
    return VerificationRemoveBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseVerificationRemoveBody();
    message.address = (_a = object.address) != null ? _a : new Uint8Array();
    message.protocol = (_b = object.protocol) != null ? _b : 0;
    return message;
  }
};
function createBaseLinkBody() {
  return { type: "", displayTimestamp: void 0, targetFid: void 0 };
}
var LinkBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.displayTimestamp !== void 0) {
      writer.uint32(16).uint32(message.displayTimestamp);
    }
    if (message.targetFid !== void 0) {
      writer.uint32(24).uint64(message.targetFid);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.displayTimestamp = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.targetFid = longToNumber2(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? String(object.type) : "",
      displayTimestamp: isSet2(object.displayTimestamp) ? Number(object.displayTimestamp) : void 0,
      targetFid: isSet2(object.targetFid) ? Number(object.targetFid) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    message.displayTimestamp !== void 0 && (obj.displayTimestamp = Math.round(message.displayTimestamp));
    message.targetFid !== void 0 && (obj.targetFid = Math.round(message.targetFid));
    return obj;
  },
  create(base) {
    return LinkBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseLinkBody();
    message.type = (_a = object.type) != null ? _a : "";
    message.displayTimestamp = (_b = object.displayTimestamp) != null ? _b : void 0;
    message.targetFid = (_c = object.targetFid) != null ? _c : void 0;
    return message;
  }
};
function createBaseLinkCompactStateBody() {
  return { type: "", targetFids: [] };
}
var LinkCompactStateBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    writer.uint32(18).fork();
    for (const v of message.targetFids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkCompactStateBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag == 16) {
            message.targetFids.push(longToNumber2(reader.uint64()));
            continue;
          }
          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.targetFids.push(longToNumber2(reader.uint64()));
            }
            continue;
          }
          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? String(object.type) : "",
      targetFids: Array.isArray(object == null ? void 0 : object.targetFids) ? object.targetFids.map((e) => Number(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    if (message.targetFids) {
      obj.targetFids = message.targetFids.map((e) => Math.round(e));
    } else {
      obj.targetFids = [];
    }
    return obj;
  },
  create(base) {
    return LinkCompactStateBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseLinkCompactStateBody();
    message.type = (_a = object.type) != null ? _a : "";
    message.targetFids = ((_b = object.targetFids) == null ? void 0 : _b.map((e) => e)) || [];
    return message;
  }
};
function createBaseFrameActionBody() {
  return {
    url: new Uint8Array(),
    buttonIndex: 0,
    castId: void 0,
    inputText: new Uint8Array(),
    state: new Uint8Array(),
    transactionId: new Uint8Array(),
    address: new Uint8Array()
  };
}
var FrameActionBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.url.length !== 0) {
      writer.uint32(10).bytes(message.url);
    }
    if (message.buttonIndex !== 0) {
      writer.uint32(16).uint32(message.buttonIndex);
    }
    if (message.castId !== void 0) {
      CastId.encode(message.castId, writer.uint32(26).fork()).ldelim();
    }
    if (message.inputText.length !== 0) {
      writer.uint32(34).bytes(message.inputText);
    }
    if (message.state.length !== 0) {
      writer.uint32(42).bytes(message.state);
    }
    if (message.transactionId.length !== 0) {
      writer.uint32(50).bytes(message.transactionId);
    }
    if (message.address.length !== 0) {
      writer.uint32(58).bytes(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFrameActionBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.url = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.buttonIndex = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.castId = CastId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.inputText = reader.bytes();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.state = reader.bytes();
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.transactionId = reader.bytes();
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.address = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet2(object.url) ? bytesFromBase642(object.url) : new Uint8Array(),
      buttonIndex: isSet2(object.buttonIndex) ? Number(object.buttonIndex) : 0,
      castId: isSet2(object.castId) ? CastId.fromJSON(object.castId) : void 0,
      inputText: isSet2(object.inputText) ? bytesFromBase642(object.inputText) : new Uint8Array(),
      state: isSet2(object.state) ? bytesFromBase642(object.state) : new Uint8Array(),
      transactionId: isSet2(object.transactionId) ? bytesFromBase642(object.transactionId) : new Uint8Array(),
      address: isSet2(object.address) ? bytesFromBase642(object.address) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = base64FromBytes2(message.url !== void 0 ? message.url : new Uint8Array()));
    message.buttonIndex !== void 0 && (obj.buttonIndex = Math.round(message.buttonIndex));
    message.castId !== void 0 && (obj.castId = message.castId ? CastId.toJSON(message.castId) : void 0);
    message.inputText !== void 0 && (obj.inputText = base64FromBytes2(message.inputText !== void 0 ? message.inputText : new Uint8Array()));
    message.state !== void 0 && (obj.state = base64FromBytes2(message.state !== void 0 ? message.state : new Uint8Array()));
    message.transactionId !== void 0 && (obj.transactionId = base64FromBytes2(
      message.transactionId !== void 0 ? message.transactionId : new Uint8Array()
    ));
    message.address !== void 0 && (obj.address = base64FromBytes2(message.address !== void 0 ? message.address : new Uint8Array()));
    return obj;
  },
  create(base) {
    return FrameActionBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseFrameActionBody();
    message.url = (_a = object.url) != null ? _a : new Uint8Array();
    message.buttonIndex = (_b = object.buttonIndex) != null ? _b : 0;
    message.castId = object.castId !== void 0 && object.castId !== null ? CastId.fromPartial(object.castId) : void 0;
    message.inputText = (_c = object.inputText) != null ? _c : new Uint8Array();
    message.state = (_d = object.state) != null ? _d : new Uint8Array();
    message.transactionId = (_e = object.transactionId) != null ? _e : new Uint8Array();
    message.address = (_f = object.address) != null ? _f : new Uint8Array();
    return message;
  }
};
var tsProtoGlobalThis2 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase642(b64) {
  if (tsProtoGlobalThis2.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis2.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis2.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes2(arr) {
  if (tsProtoGlobalThis2.Buffer) {
    return tsProtoGlobalThis2.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis2.btoa(bin.join(""));
  }
}
function longToNumber2(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal2.default.util.Long !== long_default) {
  import_minimal2.default.util.Long = long_default;
  import_minimal2.default.configure();
}
function isSet2(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/gossip.ts
var GossipVersion = /* @__PURE__ */ ((GossipVersion2) => {
  GossipVersion2[GossipVersion2["V1"] = 0] = "V1";
  GossipVersion2[GossipVersion2["V1_1"] = 1] = "V1_1";
  return GossipVersion2;
})(GossipVersion || {});
function gossipVersionFromJSON(object) {
  switch (object) {
    case 0:
    case "GOSSIP_VERSION_V1":
      return 0 /* V1 */;
    case 1:
    case "GOSSIP_VERSION_V1_1":
      return 1 /* V1_1 */;
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum GossipVersion");
  }
}
function gossipVersionToJSON(object) {
  switch (object) {
    case 0 /* V1 */:
      return "GOSSIP_VERSION_V1";
    case 1 /* V1_1 */:
      return "GOSSIP_VERSION_V1_1";
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum GossipVersion");
  }
}
function createBaseGossipAddressInfo() {
  return { address: "", family: 0, port: 0, dnsName: "" };
}
var GossipAddressInfo = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.family !== 0) {
      writer.uint32(16).uint32(message.family);
    }
    if (message.port !== 0) {
      writer.uint32(24).uint32(message.port);
    }
    if (message.dnsName !== "") {
      writer.uint32(34).string(message.dnsName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGossipAddressInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.address = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.family = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.port = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.dnsName = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet3(object.address) ? String(object.address) : "",
      family: isSet3(object.family) ? Number(object.family) : 0,
      port: isSet3(object.port) ? Number(object.port) : 0,
      dnsName: isSet3(object.dnsName) ? String(object.dnsName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    message.family !== void 0 && (obj.family = Math.round(message.family));
    message.port !== void 0 && (obj.port = Math.round(message.port));
    message.dnsName !== void 0 && (obj.dnsName = message.dnsName);
    return obj;
  },
  create(base) {
    return GossipAddressInfo.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseGossipAddressInfo();
    message.address = (_a = object.address) != null ? _a : "";
    message.family = (_b = object.family) != null ? _b : 0;
    message.port = (_c = object.port) != null ? _c : 0;
    message.dnsName = (_d = object.dnsName) != null ? _d : "";
    return message;
  }
};
function createBaseContactInfoContentBody() {
  return {
    gossipAddress: void 0,
    rpcAddress: void 0,
    excludedHashes: [],
    count: 0,
    hubVersion: "",
    network: 0,
    appVersion: "",
    timestamp: 0
  };
}
var ContactInfoContentBody = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.gossipAddress !== void 0) {
      GossipAddressInfo.encode(message.gossipAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.rpcAddress !== void 0) {
      GossipAddressInfo.encode(message.rpcAddress, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.excludedHashes) {
      writer.uint32(26).string(v);
    }
    if (message.count !== 0) {
      writer.uint32(32).uint32(message.count);
    }
    if (message.hubVersion !== "") {
      writer.uint32(42).string(message.hubVersion);
    }
    if (message.network !== 0) {
      writer.uint32(48).int32(message.network);
    }
    if (message.appVersion !== "") {
      writer.uint32(58).string(message.appVersion);
    }
    if (message.timestamp !== 0) {
      writer.uint32(64).uint64(message.timestamp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContactInfoContentBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.gossipAddress = GossipAddressInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.rpcAddress = GossipAddressInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.excludedHashes.push(reader.string());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.count = reader.uint32();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.hubVersion = reader.string();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.network = reader.int32();
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.appVersion = reader.string();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }
          message.timestamp = longToNumber3(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      gossipAddress: isSet3(object.gossipAddress) ? GossipAddressInfo.fromJSON(object.gossipAddress) : void 0,
      rpcAddress: isSet3(object.rpcAddress) ? GossipAddressInfo.fromJSON(object.rpcAddress) : void 0,
      excludedHashes: Array.isArray(object == null ? void 0 : object.excludedHashes) ? object.excludedHashes.map((e) => String(e)) : [],
      count: isSet3(object.count) ? Number(object.count) : 0,
      hubVersion: isSet3(object.hubVersion) ? String(object.hubVersion) : "",
      network: isSet3(object.network) ? farcasterNetworkFromJSON(object.network) : 0,
      appVersion: isSet3(object.appVersion) ? String(object.appVersion) : "",
      timestamp: isSet3(object.timestamp) ? Number(object.timestamp) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.gossipAddress !== void 0 && (obj.gossipAddress = message.gossipAddress ? GossipAddressInfo.toJSON(message.gossipAddress) : void 0);
    message.rpcAddress !== void 0 && (obj.rpcAddress = message.rpcAddress ? GossipAddressInfo.toJSON(message.rpcAddress) : void 0);
    if (message.excludedHashes) {
      obj.excludedHashes = message.excludedHashes.map((e) => e);
    } else {
      obj.excludedHashes = [];
    }
    message.count !== void 0 && (obj.count = Math.round(message.count));
    message.hubVersion !== void 0 && (obj.hubVersion = message.hubVersion);
    message.network !== void 0 && (obj.network = farcasterNetworkToJSON(message.network));
    message.appVersion !== void 0 && (obj.appVersion = message.appVersion);
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    return obj;
  },
  create(base) {
    return ContactInfoContentBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseContactInfoContentBody();
    message.gossipAddress = object.gossipAddress !== void 0 && object.gossipAddress !== null ? GossipAddressInfo.fromPartial(object.gossipAddress) : void 0;
    message.rpcAddress = object.rpcAddress !== void 0 && object.rpcAddress !== null ? GossipAddressInfo.fromPartial(object.rpcAddress) : void 0;
    message.excludedHashes = ((_a = object.excludedHashes) == null ? void 0 : _a.map((e) => e)) || [];
    message.count = (_b = object.count) != null ? _b : 0;
    message.hubVersion = (_c = object.hubVersion) != null ? _c : "";
    message.network = (_d = object.network) != null ? _d : 0;
    message.appVersion = (_e = object.appVersion) != null ? _e : "";
    message.timestamp = (_f = object.timestamp) != null ? _f : 0;
    return message;
  }
};
function createBaseContactInfoContent() {
  return {
    gossipAddress: void 0,
    rpcAddress: void 0,
    excludedHashes: [],
    count: 0,
    hubVersion: "",
    network: 0,
    appVersion: "",
    timestamp: 0,
    body: void 0,
    signature: new Uint8Array(),
    signer: new Uint8Array(),
    dataBytes: void 0
  };
}
var ContactInfoContent = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.gossipAddress !== void 0) {
      GossipAddressInfo.encode(message.gossipAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.rpcAddress !== void 0) {
      GossipAddressInfo.encode(message.rpcAddress, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.excludedHashes) {
      writer.uint32(26).string(v);
    }
    if (message.count !== 0) {
      writer.uint32(32).uint32(message.count);
    }
    if (message.hubVersion !== "") {
      writer.uint32(42).string(message.hubVersion);
    }
    if (message.network !== 0) {
      writer.uint32(48).int32(message.network);
    }
    if (message.appVersion !== "") {
      writer.uint32(58).string(message.appVersion);
    }
    if (message.timestamp !== 0) {
      writer.uint32(64).uint64(message.timestamp);
    }
    if (message.body !== void 0) {
      ContactInfoContentBody.encode(message.body, writer.uint32(74).fork()).ldelim();
    }
    if (message.signature.length !== 0) {
      writer.uint32(82).bytes(message.signature);
    }
    if (message.signer.length !== 0) {
      writer.uint32(90).bytes(message.signer);
    }
    if (message.dataBytes !== void 0) {
      writer.uint32(98).bytes(message.dataBytes);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContactInfoContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.gossipAddress = GossipAddressInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.rpcAddress = GossipAddressInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.excludedHashes.push(reader.string());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.count = reader.uint32();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.hubVersion = reader.string();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.network = reader.int32();
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.appVersion = reader.string();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }
          message.timestamp = longToNumber3(reader.uint64());
          continue;
        case 9:
          if (tag != 74) {
            break;
          }
          message.body = ContactInfoContentBody.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag != 82) {
            break;
          }
          message.signature = reader.bytes();
          continue;
        case 11:
          if (tag != 90) {
            break;
          }
          message.signer = reader.bytes();
          continue;
        case 12:
          if (tag != 98) {
            break;
          }
          message.dataBytes = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      gossipAddress: isSet3(object.gossipAddress) ? GossipAddressInfo.fromJSON(object.gossipAddress) : void 0,
      rpcAddress: isSet3(object.rpcAddress) ? GossipAddressInfo.fromJSON(object.rpcAddress) : void 0,
      excludedHashes: Array.isArray(object == null ? void 0 : object.excludedHashes) ? object.excludedHashes.map((e) => String(e)) : [],
      count: isSet3(object.count) ? Number(object.count) : 0,
      hubVersion: isSet3(object.hubVersion) ? String(object.hubVersion) : "",
      network: isSet3(object.network) ? farcasterNetworkFromJSON(object.network) : 0,
      appVersion: isSet3(object.appVersion) ? String(object.appVersion) : "",
      timestamp: isSet3(object.timestamp) ? Number(object.timestamp) : 0,
      body: isSet3(object.body) ? ContactInfoContentBody.fromJSON(object.body) : void 0,
      signature: isSet3(object.signature) ? bytesFromBase643(object.signature) : new Uint8Array(),
      signer: isSet3(object.signer) ? bytesFromBase643(object.signer) : new Uint8Array(),
      dataBytes: isSet3(object.dataBytes) ? bytesFromBase643(object.dataBytes) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.gossipAddress !== void 0 && (obj.gossipAddress = message.gossipAddress ? GossipAddressInfo.toJSON(message.gossipAddress) : void 0);
    message.rpcAddress !== void 0 && (obj.rpcAddress = message.rpcAddress ? GossipAddressInfo.toJSON(message.rpcAddress) : void 0);
    if (message.excludedHashes) {
      obj.excludedHashes = message.excludedHashes.map((e) => e);
    } else {
      obj.excludedHashes = [];
    }
    message.count !== void 0 && (obj.count = Math.round(message.count));
    message.hubVersion !== void 0 && (obj.hubVersion = message.hubVersion);
    message.network !== void 0 && (obj.network = farcasterNetworkToJSON(message.network));
    message.appVersion !== void 0 && (obj.appVersion = message.appVersion);
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.body !== void 0 && (obj.body = message.body ? ContactInfoContentBody.toJSON(message.body) : void 0);
    message.signature !== void 0 && (obj.signature = base64FromBytes3(message.signature !== void 0 ? message.signature : new Uint8Array()));
    message.signer !== void 0 && (obj.signer = base64FromBytes3(message.signer !== void 0 ? message.signer : new Uint8Array()));
    message.dataBytes !== void 0 && (obj.dataBytes = message.dataBytes !== void 0 ? base64FromBytes3(message.dataBytes) : void 0);
    return obj;
  },
  create(base) {
    return ContactInfoContent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const message = createBaseContactInfoContent();
    message.gossipAddress = object.gossipAddress !== void 0 && object.gossipAddress !== null ? GossipAddressInfo.fromPartial(object.gossipAddress) : void 0;
    message.rpcAddress = object.rpcAddress !== void 0 && object.rpcAddress !== null ? GossipAddressInfo.fromPartial(object.rpcAddress) : void 0;
    message.excludedHashes = ((_a = object.excludedHashes) == null ? void 0 : _a.map((e) => e)) || [];
    message.count = (_b = object.count) != null ? _b : 0;
    message.hubVersion = (_c = object.hubVersion) != null ? _c : "";
    message.network = (_d = object.network) != null ? _d : 0;
    message.appVersion = (_e = object.appVersion) != null ? _e : "";
    message.timestamp = (_f = object.timestamp) != null ? _f : 0;
    message.body = object.body !== void 0 && object.body !== null ? ContactInfoContentBody.fromPartial(object.body) : void 0;
    message.signature = (_g = object.signature) != null ? _g : new Uint8Array();
    message.signer = (_h = object.signer) != null ? _h : new Uint8Array();
    message.dataBytes = (_i = object.dataBytes) != null ? _i : void 0;
    return message;
  }
};
function createBasePingMessageBody() {
  return { pingOriginPeerId: new Uint8Array(), pingTimestamp: 0 };
}
var PingMessageBody = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.pingOriginPeerId.length !== 0) {
      writer.uint32(10).bytes(message.pingOriginPeerId);
    }
    if (message.pingTimestamp !== 0) {
      writer.uint32(16).uint64(message.pingTimestamp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePingMessageBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.pingOriginPeerId = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.pingTimestamp = longToNumber3(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      pingOriginPeerId: isSet3(object.pingOriginPeerId) ? bytesFromBase643(object.pingOriginPeerId) : new Uint8Array(),
      pingTimestamp: isSet3(object.pingTimestamp) ? Number(object.pingTimestamp) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.pingOriginPeerId !== void 0 && (obj.pingOriginPeerId = base64FromBytes3(
      message.pingOriginPeerId !== void 0 ? message.pingOriginPeerId : new Uint8Array()
    ));
    message.pingTimestamp !== void 0 && (obj.pingTimestamp = Math.round(message.pingTimestamp));
    return obj;
  },
  create(base) {
    return PingMessageBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBasePingMessageBody();
    message.pingOriginPeerId = (_a = object.pingOriginPeerId) != null ? _a : new Uint8Array();
    message.pingTimestamp = (_b = object.pingTimestamp) != null ? _b : 0;
    return message;
  }
};
function createBaseAckMessageBody() {
  return { pingOriginPeerId: new Uint8Array(), ackOriginPeerId: new Uint8Array(), pingTimestamp: 0, ackTimestamp: 0 };
}
var AckMessageBody = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.pingOriginPeerId.length !== 0) {
      writer.uint32(10).bytes(message.pingOriginPeerId);
    }
    if (message.ackOriginPeerId.length !== 0) {
      writer.uint32(18).bytes(message.ackOriginPeerId);
    }
    if (message.pingTimestamp !== 0) {
      writer.uint32(24).uint64(message.pingTimestamp);
    }
    if (message.ackTimestamp !== 0) {
      writer.uint32(32).uint64(message.ackTimestamp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAckMessageBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.pingOriginPeerId = reader.bytes();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.ackOriginPeerId = reader.bytes();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pingTimestamp = longToNumber3(reader.uint64());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.ackTimestamp = longToNumber3(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      pingOriginPeerId: isSet3(object.pingOriginPeerId) ? bytesFromBase643(object.pingOriginPeerId) : new Uint8Array(),
      ackOriginPeerId: isSet3(object.ackOriginPeerId) ? bytesFromBase643(object.ackOriginPeerId) : new Uint8Array(),
      pingTimestamp: isSet3(object.pingTimestamp) ? Number(object.pingTimestamp) : 0,
      ackTimestamp: isSet3(object.ackTimestamp) ? Number(object.ackTimestamp) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.pingOriginPeerId !== void 0 && (obj.pingOriginPeerId = base64FromBytes3(
      message.pingOriginPeerId !== void 0 ? message.pingOriginPeerId : new Uint8Array()
    ));
    message.ackOriginPeerId !== void 0 && (obj.ackOriginPeerId = base64FromBytes3(
      message.ackOriginPeerId !== void 0 ? message.ackOriginPeerId : new Uint8Array()
    ));
    message.pingTimestamp !== void 0 && (obj.pingTimestamp = Math.round(message.pingTimestamp));
    message.ackTimestamp !== void 0 && (obj.ackTimestamp = Math.round(message.ackTimestamp));
    return obj;
  },
  create(base) {
    return AckMessageBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseAckMessageBody();
    message.pingOriginPeerId = (_a = object.pingOriginPeerId) != null ? _a : new Uint8Array();
    message.ackOriginPeerId = (_b = object.ackOriginPeerId) != null ? _b : new Uint8Array();
    message.pingTimestamp = (_c = object.pingTimestamp) != null ? _c : 0;
    message.ackTimestamp = (_d = object.ackTimestamp) != null ? _d : 0;
    return message;
  }
};
function createBaseNetworkLatencyMessage() {
  return { pingMessage: void 0, ackMessage: void 0 };
}
var NetworkLatencyMessage = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.pingMessage !== void 0) {
      PingMessageBody.encode(message.pingMessage, writer.uint32(18).fork()).ldelim();
    }
    if (message.ackMessage !== void 0) {
      AckMessageBody.encode(message.ackMessage, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNetworkLatencyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag != 18) {
            break;
          }
          message.pingMessage = PingMessageBody.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.ackMessage = AckMessageBody.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      pingMessage: isSet3(object.pingMessage) ? PingMessageBody.fromJSON(object.pingMessage) : void 0,
      ackMessage: isSet3(object.ackMessage) ? AckMessageBody.fromJSON(object.ackMessage) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.pingMessage !== void 0 && (obj.pingMessage = message.pingMessage ? PingMessageBody.toJSON(message.pingMessage) : void 0);
    message.ackMessage !== void 0 && (obj.ackMessage = message.ackMessage ? AckMessageBody.toJSON(message.ackMessage) : void 0);
    return obj;
  },
  create(base) {
    return NetworkLatencyMessage.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseNetworkLatencyMessage();
    message.pingMessage = object.pingMessage !== void 0 && object.pingMessage !== null ? PingMessageBody.fromPartial(object.pingMessage) : void 0;
    message.ackMessage = object.ackMessage !== void 0 && object.ackMessage !== null ? AckMessageBody.fromPartial(object.ackMessage) : void 0;
    return message;
  }
};
function createBaseMessageBundle() {
  return { hash: new Uint8Array(), messages: [] };
}
var MessageBundle = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    for (const v of message.messages) {
      Message.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.hash = reader.bytes();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      hash: isSet3(object.hash) ? bytesFromBase643(object.hash) : new Uint8Array(),
      messages: Array.isArray(object == null ? void 0 : object.messages) ? object.messages.map((e) => Message.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.hash !== void 0 && (obj.hash = base64FromBytes3(message.hash !== void 0 ? message.hash : new Uint8Array()));
    if (message.messages) {
      obj.messages = message.messages.map((e) => e ? Message.toJSON(e) : void 0);
    } else {
      obj.messages = [];
    }
    return obj;
  },
  create(base) {
    return MessageBundle.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMessageBundle();
    message.hash = (_a = object.hash) != null ? _a : new Uint8Array();
    message.messages = ((_b = object.messages) == null ? void 0 : _b.map((e) => Message.fromPartial(e))) || [];
    return message;
  }
};
function createBaseGossipMessage() {
  return {
    message: void 0,
    contactInfoContent: void 0,
    networkLatencyMessage: void 0,
    messageBundle: void 0,
    topics: [],
    peerId: new Uint8Array(),
    version: 0,
    timestamp: 0
  };
}
var GossipMessage = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    if (message.contactInfoContent !== void 0) {
      ContactInfoContent.encode(message.contactInfoContent, writer.uint32(26).fork()).ldelim();
    }
    if (message.networkLatencyMessage !== void 0) {
      NetworkLatencyMessage.encode(message.networkLatencyMessage, writer.uint32(58).fork()).ldelim();
    }
    if (message.messageBundle !== void 0) {
      MessageBundle.encode(message.messageBundle, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.topics) {
      writer.uint32(34).string(v);
    }
    if (message.peerId.length !== 0) {
      writer.uint32(42).bytes(message.peerId);
    }
    if (message.version !== 0) {
      writer.uint32(48).int32(message.version);
    }
    if (message.timestamp !== 0) {
      writer.uint32(64).uint32(message.timestamp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGossipMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.contactInfoContent = ContactInfoContent.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.networkLatencyMessage = NetworkLatencyMessage.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag != 74) {
            break;
          }
          message.messageBundle = MessageBundle.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.topics.push(reader.string());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.peerId = reader.bytes();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.version = reader.int32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }
          message.timestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet3(object.message) ? Message.fromJSON(object.message) : void 0,
      contactInfoContent: isSet3(object.contactInfoContent) ? ContactInfoContent.fromJSON(object.contactInfoContent) : void 0,
      networkLatencyMessage: isSet3(object.networkLatencyMessage) ? NetworkLatencyMessage.fromJSON(object.networkLatencyMessage) : void 0,
      messageBundle: isSet3(object.messageBundle) ? MessageBundle.fromJSON(object.messageBundle) : void 0,
      topics: Array.isArray(object == null ? void 0 : object.topics) ? object.topics.map((e) => String(e)) : [],
      peerId: isSet3(object.peerId) ? bytesFromBase643(object.peerId) : new Uint8Array(),
      version: isSet3(object.version) ? gossipVersionFromJSON(object.version) : 0,
      timestamp: isSet3(object.timestamp) ? Number(object.timestamp) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    message.contactInfoContent !== void 0 && (obj.contactInfoContent = message.contactInfoContent ? ContactInfoContent.toJSON(message.contactInfoContent) : void 0);
    message.networkLatencyMessage !== void 0 && (obj.networkLatencyMessage = message.networkLatencyMessage ? NetworkLatencyMessage.toJSON(message.networkLatencyMessage) : void 0);
    message.messageBundle !== void 0 && (obj.messageBundle = message.messageBundle ? MessageBundle.toJSON(message.messageBundle) : void 0);
    if (message.topics) {
      obj.topics = message.topics.map((e) => e);
    } else {
      obj.topics = [];
    }
    message.peerId !== void 0 && (obj.peerId = base64FromBytes3(message.peerId !== void 0 ? message.peerId : new Uint8Array()));
    message.version !== void 0 && (obj.version = gossipVersionToJSON(message.version));
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    return obj;
  },
  create(base) {
    return GossipMessage.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseGossipMessage();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    message.contactInfoContent = object.contactInfoContent !== void 0 && object.contactInfoContent !== null ? ContactInfoContent.fromPartial(object.contactInfoContent) : void 0;
    message.networkLatencyMessage = object.networkLatencyMessage !== void 0 && object.networkLatencyMessage !== null ? NetworkLatencyMessage.fromPartial(object.networkLatencyMessage) : void 0;
    message.messageBundle = object.messageBundle !== void 0 && object.messageBundle !== null ? MessageBundle.fromPartial(object.messageBundle) : void 0;
    message.topics = ((_a = object.topics) == null ? void 0 : _a.map((e) => e)) || [];
    message.peerId = (_b = object.peerId) != null ? _b : new Uint8Array();
    message.version = (_c = object.version) != null ? _c : 0;
    message.timestamp = (_d = object.timestamp) != null ? _d : 0;
    return message;
  }
};
var tsProtoGlobalThis3 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase643(b64) {
  if (tsProtoGlobalThis3.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis3.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis3.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes3(arr) {
  if (tsProtoGlobalThis3.Buffer) {
    return tsProtoGlobalThis3.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis3.btoa(bin.join(""));
  }
}
function longToNumber3(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis3.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal3.default.util.Long !== long_default) {
  import_minimal3.default.util.Long = long_default;
  import_minimal3.default.configure();
}
function isSet3(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/hub_event.ts
init_esm_shims();
var import_minimal5 = __toESM(require_minimal2());

// src/protobufs/generated/onchain_event.ts
init_esm_shims();
var import_minimal4 = __toESM(require_minimal2());
var OnChainEventType = /* @__PURE__ */ ((OnChainEventType3) => {
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_NONE"] = 0] = "EVENT_TYPE_NONE";
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_SIGNER"] = 1] = "EVENT_TYPE_SIGNER";
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_SIGNER_MIGRATED"] = 2] = "EVENT_TYPE_SIGNER_MIGRATED";
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_ID_REGISTER"] = 3] = "EVENT_TYPE_ID_REGISTER";
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_STORAGE_RENT"] = 4] = "EVENT_TYPE_STORAGE_RENT";
  return OnChainEventType3;
})(OnChainEventType || {});
function onChainEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "EVENT_TYPE_NONE":
      return 0 /* EVENT_TYPE_NONE */;
    case 1:
    case "EVENT_TYPE_SIGNER":
      return 1 /* EVENT_TYPE_SIGNER */;
    case 2:
    case "EVENT_TYPE_SIGNER_MIGRATED":
      return 2 /* EVENT_TYPE_SIGNER_MIGRATED */;
    case 3:
    case "EVENT_TYPE_ID_REGISTER":
      return 3 /* EVENT_TYPE_ID_REGISTER */;
    case 4:
    case "EVENT_TYPE_STORAGE_RENT":
      return 4 /* EVENT_TYPE_STORAGE_RENT */;
    default:
      throw new tsProtoGlobalThis4.Error("Unrecognized enum value " + object + " for enum OnChainEventType");
  }
}
function onChainEventTypeToJSON(object) {
  switch (object) {
    case 0 /* EVENT_TYPE_NONE */:
      return "EVENT_TYPE_NONE";
    case 1 /* EVENT_TYPE_SIGNER */:
      return "EVENT_TYPE_SIGNER";
    case 2 /* EVENT_TYPE_SIGNER_MIGRATED */:
      return "EVENT_TYPE_SIGNER_MIGRATED";
    case 3 /* EVENT_TYPE_ID_REGISTER */:
      return "EVENT_TYPE_ID_REGISTER";
    case 4 /* EVENT_TYPE_STORAGE_RENT */:
      return "EVENT_TYPE_STORAGE_RENT";
    default:
      throw new tsProtoGlobalThis4.Error("Unrecognized enum value " + object + " for enum OnChainEventType");
  }
}
var SignerEventType = /* @__PURE__ */ ((SignerEventType2) => {
  SignerEventType2[SignerEventType2["NONE"] = 0] = "NONE";
  SignerEventType2[SignerEventType2["ADD"] = 1] = "ADD";
  SignerEventType2[SignerEventType2["REMOVE"] = 2] = "REMOVE";
  SignerEventType2[SignerEventType2["ADMIN_RESET"] = 3] = "ADMIN_RESET";
  return SignerEventType2;
})(SignerEventType || {});
function signerEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "SIGNER_EVENT_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "SIGNER_EVENT_TYPE_ADD":
      return 1 /* ADD */;
    case 2:
    case "SIGNER_EVENT_TYPE_REMOVE":
      return 2 /* REMOVE */;
    case 3:
    case "SIGNER_EVENT_TYPE_ADMIN_RESET":
      return 3 /* ADMIN_RESET */;
    default:
      throw new tsProtoGlobalThis4.Error("Unrecognized enum value " + object + " for enum SignerEventType");
  }
}
function signerEventTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "SIGNER_EVENT_TYPE_NONE";
    case 1 /* ADD */:
      return "SIGNER_EVENT_TYPE_ADD";
    case 2 /* REMOVE */:
      return "SIGNER_EVENT_TYPE_REMOVE";
    case 3 /* ADMIN_RESET */:
      return "SIGNER_EVENT_TYPE_ADMIN_RESET";
    default:
      throw new tsProtoGlobalThis4.Error("Unrecognized enum value " + object + " for enum SignerEventType");
  }
}
var IdRegisterEventType = /* @__PURE__ */ ((IdRegisterEventType2) => {
  IdRegisterEventType2[IdRegisterEventType2["NONE"] = 0] = "NONE";
  IdRegisterEventType2[IdRegisterEventType2["REGISTER"] = 1] = "REGISTER";
  IdRegisterEventType2[IdRegisterEventType2["TRANSFER"] = 2] = "TRANSFER";
  IdRegisterEventType2[IdRegisterEventType2["CHANGE_RECOVERY"] = 3] = "CHANGE_RECOVERY";
  return IdRegisterEventType2;
})(IdRegisterEventType || {});
function idRegisterEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ID_REGISTER_EVENT_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "ID_REGISTER_EVENT_TYPE_REGISTER":
      return 1 /* REGISTER */;
    case 2:
    case "ID_REGISTER_EVENT_TYPE_TRANSFER":
      return 2 /* TRANSFER */;
    case 3:
    case "ID_REGISTER_EVENT_TYPE_CHANGE_RECOVERY":
      return 3 /* CHANGE_RECOVERY */;
    default:
      throw new tsProtoGlobalThis4.Error("Unrecognized enum value " + object + " for enum IdRegisterEventType");
  }
}
function idRegisterEventTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "ID_REGISTER_EVENT_TYPE_NONE";
    case 1 /* REGISTER */:
      return "ID_REGISTER_EVENT_TYPE_REGISTER";
    case 2 /* TRANSFER */:
      return "ID_REGISTER_EVENT_TYPE_TRANSFER";
    case 3 /* CHANGE_RECOVERY */:
      return "ID_REGISTER_EVENT_TYPE_CHANGE_RECOVERY";
    default:
      throw new tsProtoGlobalThis4.Error("Unrecognized enum value " + object + " for enum IdRegisterEventType");
  }
}
function createBaseOnChainEvent() {
  return {
    type: 0,
    chainId: 0,
    blockNumber: 0,
    blockHash: new Uint8Array(),
    blockTimestamp: 0,
    transactionHash: new Uint8Array(),
    logIndex: 0,
    fid: 0,
    signerEventBody: void 0,
    signerMigratedEventBody: void 0,
    idRegisterEventBody: void 0,
    storageRentEventBody: void 0,
    txIndex: 0,
    version: 0
  };
}
var OnChainEvent = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.chainId !== 0) {
      writer.uint32(16).uint32(message.chainId);
    }
    if (message.blockNumber !== 0) {
      writer.uint32(24).uint32(message.blockNumber);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(34).bytes(message.blockHash);
    }
    if (message.blockTimestamp !== 0) {
      writer.uint32(40).uint64(message.blockTimestamp);
    }
    if (message.transactionHash.length !== 0) {
      writer.uint32(50).bytes(message.transactionHash);
    }
    if (message.logIndex !== 0) {
      writer.uint32(56).uint32(message.logIndex);
    }
    if (message.fid !== 0) {
      writer.uint32(64).uint64(message.fid);
    }
    if (message.signerEventBody !== void 0) {
      SignerEventBody.encode(message.signerEventBody, writer.uint32(74).fork()).ldelim();
    }
    if (message.signerMigratedEventBody !== void 0) {
      SignerMigratedEventBody.encode(message.signerMigratedEventBody, writer.uint32(82).fork()).ldelim();
    }
    if (message.idRegisterEventBody !== void 0) {
      IdRegisterEventBody.encode(message.idRegisterEventBody, writer.uint32(90).fork()).ldelim();
    }
    if (message.storageRentEventBody !== void 0) {
      StorageRentEventBody.encode(message.storageRentEventBody, writer.uint32(98).fork()).ldelim();
    }
    if (message.txIndex !== 0) {
      writer.uint32(104).uint32(message.txIndex);
    }
    if (message.version !== 0) {
      writer.uint32(112).uint32(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnChainEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.chainId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.blockNumber = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.blockHash = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.blockTimestamp = longToNumber4(reader.uint64());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.transactionHash = reader.bytes();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }
          message.logIndex = reader.uint32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }
          message.fid = longToNumber4(reader.uint64());
          continue;
        case 9:
          if (tag != 74) {
            break;
          }
          message.signerEventBody = SignerEventBody.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag != 82) {
            break;
          }
          message.signerMigratedEventBody = SignerMigratedEventBody.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag != 90) {
            break;
          }
          message.idRegisterEventBody = IdRegisterEventBody.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag != 98) {
            break;
          }
          message.storageRentEventBody = StorageRentEventBody.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag != 104) {
            break;
          }
          message.txIndex = reader.uint32();
          continue;
        case 14:
          if (tag != 112) {
            break;
          }
          message.version = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet4(object.type) ? onChainEventTypeFromJSON(object.type) : 0,
      chainId: isSet4(object.chainId) ? Number(object.chainId) : 0,
      blockNumber: isSet4(object.blockNumber) ? Number(object.blockNumber) : 0,
      blockHash: isSet4(object.blockHash) ? bytesFromBase644(object.blockHash) : new Uint8Array(),
      blockTimestamp: isSet4(object.blockTimestamp) ? Number(object.blockTimestamp) : 0,
      transactionHash: isSet4(object.transactionHash) ? bytesFromBase644(object.transactionHash) : new Uint8Array(),
      logIndex: isSet4(object.logIndex) ? Number(object.logIndex) : 0,
      fid: isSet4(object.fid) ? Number(object.fid) : 0,
      signerEventBody: isSet4(object.signerEventBody) ? SignerEventBody.fromJSON(object.signerEventBody) : void 0,
      signerMigratedEventBody: isSet4(object.signerMigratedEventBody) ? SignerMigratedEventBody.fromJSON(object.signerMigratedEventBody) : void 0,
      idRegisterEventBody: isSet4(object.idRegisterEventBody) ? IdRegisterEventBody.fromJSON(object.idRegisterEventBody) : void 0,
      storageRentEventBody: isSet4(object.storageRentEventBody) ? StorageRentEventBody.fromJSON(object.storageRentEventBody) : void 0,
      txIndex: isSet4(object.txIndex) ? Number(object.txIndex) : 0,
      version: isSet4(object.version) ? Number(object.version) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = onChainEventTypeToJSON(message.type));
    message.chainId !== void 0 && (obj.chainId = Math.round(message.chainId));
    message.blockNumber !== void 0 && (obj.blockNumber = Math.round(message.blockNumber));
    message.blockHash !== void 0 && (obj.blockHash = base64FromBytes4(message.blockHash !== void 0 ? message.blockHash : new Uint8Array()));
    message.blockTimestamp !== void 0 && (obj.blockTimestamp = Math.round(message.blockTimestamp));
    message.transactionHash !== void 0 && (obj.transactionHash = base64FromBytes4(
      message.transactionHash !== void 0 ? message.transactionHash : new Uint8Array()
    ));
    message.logIndex !== void 0 && (obj.logIndex = Math.round(message.logIndex));
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.signerEventBody !== void 0 && (obj.signerEventBody = message.signerEventBody ? SignerEventBody.toJSON(message.signerEventBody) : void 0);
    message.signerMigratedEventBody !== void 0 && (obj.signerMigratedEventBody = message.signerMigratedEventBody ? SignerMigratedEventBody.toJSON(message.signerMigratedEventBody) : void 0);
    message.idRegisterEventBody !== void 0 && (obj.idRegisterEventBody = message.idRegisterEventBody ? IdRegisterEventBody.toJSON(message.idRegisterEventBody) : void 0);
    message.storageRentEventBody !== void 0 && (obj.storageRentEventBody = message.storageRentEventBody ? StorageRentEventBody.toJSON(message.storageRentEventBody) : void 0);
    message.txIndex !== void 0 && (obj.txIndex = Math.round(message.txIndex));
    message.version !== void 0 && (obj.version = Math.round(message.version));
    return obj;
  },
  create(base) {
    return OnChainEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const message = createBaseOnChainEvent();
    message.type = (_a = object.type) != null ? _a : 0;
    message.chainId = (_b = object.chainId) != null ? _b : 0;
    message.blockNumber = (_c = object.blockNumber) != null ? _c : 0;
    message.blockHash = (_d = object.blockHash) != null ? _d : new Uint8Array();
    message.blockTimestamp = (_e = object.blockTimestamp) != null ? _e : 0;
    message.transactionHash = (_f = object.transactionHash) != null ? _f : new Uint8Array();
    message.logIndex = (_g = object.logIndex) != null ? _g : 0;
    message.fid = (_h = object.fid) != null ? _h : 0;
    message.signerEventBody = object.signerEventBody !== void 0 && object.signerEventBody !== null ? SignerEventBody.fromPartial(object.signerEventBody) : void 0;
    message.signerMigratedEventBody = object.signerMigratedEventBody !== void 0 && object.signerMigratedEventBody !== null ? SignerMigratedEventBody.fromPartial(object.signerMigratedEventBody) : void 0;
    message.idRegisterEventBody = object.idRegisterEventBody !== void 0 && object.idRegisterEventBody !== null ? IdRegisterEventBody.fromPartial(object.idRegisterEventBody) : void 0;
    message.storageRentEventBody = object.storageRentEventBody !== void 0 && object.storageRentEventBody !== null ? StorageRentEventBody.fromPartial(object.storageRentEventBody) : void 0;
    message.txIndex = (_i = object.txIndex) != null ? _i : 0;
    message.version = (_j = object.version) != null ? _j : 0;
    return message;
  }
};
function createBaseSignerEventBody() {
  return { key: new Uint8Array(), keyType: 0, eventType: 0, metadata: new Uint8Array(), metadataType: 0 };
}
var SignerEventBody = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.keyType !== 0) {
      writer.uint32(16).uint32(message.keyType);
    }
    if (message.eventType !== 0) {
      writer.uint32(24).int32(message.eventType);
    }
    if (message.metadata.length !== 0) {
      writer.uint32(34).bytes(message.metadata);
    }
    if (message.metadataType !== 0) {
      writer.uint32(40).uint32(message.metadataType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignerEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.key = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.keyType = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.eventType = reader.int32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.metadata = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.metadataType = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet4(object.key) ? bytesFromBase644(object.key) : new Uint8Array(),
      keyType: isSet4(object.keyType) ? Number(object.keyType) : 0,
      eventType: isSet4(object.eventType) ? signerEventTypeFromJSON(object.eventType) : 0,
      metadata: isSet4(object.metadata) ? bytesFromBase644(object.metadata) : new Uint8Array(),
      metadataType: isSet4(object.metadataType) ? Number(object.metadataType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes4(message.key !== void 0 ? message.key : new Uint8Array()));
    message.keyType !== void 0 && (obj.keyType = Math.round(message.keyType));
    message.eventType !== void 0 && (obj.eventType = signerEventTypeToJSON(message.eventType));
    message.metadata !== void 0 && (obj.metadata = base64FromBytes4(message.metadata !== void 0 ? message.metadata : new Uint8Array()));
    message.metadataType !== void 0 && (obj.metadataType = Math.round(message.metadataType));
    return obj;
  },
  create(base) {
    return SignerEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseSignerEventBody();
    message.key = (_a = object.key) != null ? _a : new Uint8Array();
    message.keyType = (_b = object.keyType) != null ? _b : 0;
    message.eventType = (_c = object.eventType) != null ? _c : 0;
    message.metadata = (_d = object.metadata) != null ? _d : new Uint8Array();
    message.metadataType = (_e = object.metadataType) != null ? _e : 0;
    return message;
  }
};
function createBaseSignerMigratedEventBody() {
  return { migratedAt: 0 };
}
var SignerMigratedEventBody = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.migratedAt !== 0) {
      writer.uint32(8).uint32(message.migratedAt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignerMigratedEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.migratedAt = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { migratedAt: isSet4(object.migratedAt) ? Number(object.migratedAt) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.migratedAt !== void 0 && (obj.migratedAt = Math.round(message.migratedAt));
    return obj;
  },
  create(base) {
    return SignerMigratedEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSignerMigratedEventBody();
    message.migratedAt = (_a = object.migratedAt) != null ? _a : 0;
    return message;
  }
};
function createBaseIdRegisterEventBody() {
  return { to: new Uint8Array(), eventType: 0, from: new Uint8Array(), recoveryAddress: new Uint8Array() };
}
var IdRegisterEventBody = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.to.length !== 0) {
      writer.uint32(10).bytes(message.to);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.from.length !== 0) {
      writer.uint32(26).bytes(message.from);
    }
    if (message.recoveryAddress.length !== 0) {
      writer.uint32(34).bytes(message.recoveryAddress);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIdRegisterEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.to = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.eventType = reader.int32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.from = reader.bytes();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.recoveryAddress = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      to: isSet4(object.to) ? bytesFromBase644(object.to) : new Uint8Array(),
      eventType: isSet4(object.eventType) ? idRegisterEventTypeFromJSON(object.eventType) : 0,
      from: isSet4(object.from) ? bytesFromBase644(object.from) : new Uint8Array(),
      recoveryAddress: isSet4(object.recoveryAddress) ? bytesFromBase644(object.recoveryAddress) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.to !== void 0 && (obj.to = base64FromBytes4(message.to !== void 0 ? message.to : new Uint8Array()));
    message.eventType !== void 0 && (obj.eventType = idRegisterEventTypeToJSON(message.eventType));
    message.from !== void 0 && (obj.from = base64FromBytes4(message.from !== void 0 ? message.from : new Uint8Array()));
    message.recoveryAddress !== void 0 && (obj.recoveryAddress = base64FromBytes4(
      message.recoveryAddress !== void 0 ? message.recoveryAddress : new Uint8Array()
    ));
    return obj;
  },
  create(base) {
    return IdRegisterEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseIdRegisterEventBody();
    message.to = (_a = object.to) != null ? _a : new Uint8Array();
    message.eventType = (_b = object.eventType) != null ? _b : 0;
    message.from = (_c = object.from) != null ? _c : new Uint8Array();
    message.recoveryAddress = (_d = object.recoveryAddress) != null ? _d : new Uint8Array();
    return message;
  }
};
function createBaseStorageRentEventBody() {
  return { payer: new Uint8Array(), units: 0, expiry: 0 };
}
var StorageRentEventBody = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.payer.length !== 0) {
      writer.uint32(10).bytes(message.payer);
    }
    if (message.units !== 0) {
      writer.uint32(16).uint32(message.units);
    }
    if (message.expiry !== 0) {
      writer.uint32(24).uint32(message.expiry);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorageRentEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.payer = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.units = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.expiry = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      payer: isSet4(object.payer) ? bytesFromBase644(object.payer) : new Uint8Array(),
      units: isSet4(object.units) ? Number(object.units) : 0,
      expiry: isSet4(object.expiry) ? Number(object.expiry) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.payer !== void 0 && (obj.payer = base64FromBytes4(message.payer !== void 0 ? message.payer : new Uint8Array()));
    message.units !== void 0 && (obj.units = Math.round(message.units));
    message.expiry !== void 0 && (obj.expiry = Math.round(message.expiry));
    return obj;
  },
  create(base) {
    return StorageRentEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseStorageRentEventBody();
    message.payer = (_a = object.payer) != null ? _a : new Uint8Array();
    message.units = (_b = object.units) != null ? _b : 0;
    message.expiry = (_c = object.expiry) != null ? _c : 0;
    return message;
  }
};
var tsProtoGlobalThis4 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase644(b64) {
  if (tsProtoGlobalThis4.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis4.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis4.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes4(arr) {
  if (tsProtoGlobalThis4.Buffer) {
    return tsProtoGlobalThis4.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis4.btoa(bin.join(""));
  }
}
function longToNumber4(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis4.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal4.default.util.Long !== long_default) {
  import_minimal4.default.util.Long = long_default;
  import_minimal4.default.configure();
}
function isSet4(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/hub_event.ts
var HubEventType = /* @__PURE__ */ ((HubEventType3) => {
  HubEventType3[HubEventType3["NONE"] = 0] = "NONE";
  HubEventType3[HubEventType3["MERGE_MESSAGE"] = 1] = "MERGE_MESSAGE";
  HubEventType3[HubEventType3["PRUNE_MESSAGE"] = 2] = "PRUNE_MESSAGE";
  HubEventType3[HubEventType3["REVOKE_MESSAGE"] = 3] = "REVOKE_MESSAGE";
  HubEventType3[HubEventType3["MERGE_USERNAME_PROOF"] = 6] = "MERGE_USERNAME_PROOF";
  HubEventType3[HubEventType3["MERGE_ON_CHAIN_EVENT"] = 9] = "MERGE_ON_CHAIN_EVENT";
  return HubEventType3;
})(HubEventType || {});
function hubEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "HUB_EVENT_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "HUB_EVENT_TYPE_MERGE_MESSAGE":
      return 1 /* MERGE_MESSAGE */;
    case 2:
    case "HUB_EVENT_TYPE_PRUNE_MESSAGE":
      return 2 /* PRUNE_MESSAGE */;
    case 3:
    case "HUB_EVENT_TYPE_REVOKE_MESSAGE":
      return 3 /* REVOKE_MESSAGE */;
    case 6:
    case "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF":
      return 6 /* MERGE_USERNAME_PROOF */;
    case 9:
    case "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT":
      return 9 /* MERGE_ON_CHAIN_EVENT */;
    default:
      throw new tsProtoGlobalThis5.Error("Unrecognized enum value " + object + " for enum HubEventType");
  }
}
function hubEventTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "HUB_EVENT_TYPE_NONE";
    case 1 /* MERGE_MESSAGE */:
      return "HUB_EVENT_TYPE_MERGE_MESSAGE";
    case 2 /* PRUNE_MESSAGE */:
      return "HUB_EVENT_TYPE_PRUNE_MESSAGE";
    case 3 /* REVOKE_MESSAGE */:
      return "HUB_EVENT_TYPE_REVOKE_MESSAGE";
    case 6 /* MERGE_USERNAME_PROOF */:
      return "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF";
    case 9 /* MERGE_ON_CHAIN_EVENT */:
      return "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT";
    default:
      throw new tsProtoGlobalThis5.Error("Unrecognized enum value " + object + " for enum HubEventType");
  }
}
function createBaseMergeMessageBody() {
  return { message: void 0, deletedMessages: [] };
}
var MergeMessageBody = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.deletedMessages) {
      Message.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMergeMessageBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.deletedMessages.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet5(object.message) ? Message.fromJSON(object.message) : void 0,
      deletedMessages: Array.isArray(object == null ? void 0 : object.deletedMessages) ? object.deletedMessages.map((e) => Message.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    if (message.deletedMessages) {
      obj.deletedMessages = message.deletedMessages.map((e) => e ? Message.toJSON(e) : void 0);
    } else {
      obj.deletedMessages = [];
    }
    return obj;
  },
  create(base) {
    return MergeMessageBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseMergeMessageBody();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    message.deletedMessages = ((_a = object.deletedMessages) == null ? void 0 : _a.map((e) => Message.fromPartial(e))) || [];
    return message;
  }
};
function createBasePruneMessageBody() {
  return { message: void 0 };
}
var PruneMessageBody = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePruneMessageBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { message: isSet5(object.message) ? Message.fromJSON(object.message) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    return obj;
  },
  create(base) {
    return PruneMessageBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBasePruneMessageBody();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    return message;
  }
};
function createBaseRevokeMessageBody() {
  return { message: void 0 };
}
var RevokeMessageBody = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRevokeMessageBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { message: isSet5(object.message) ? Message.fromJSON(object.message) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    return obj;
  },
  create(base) {
    return RevokeMessageBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseRevokeMessageBody();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    return message;
  }
};
function createBaseMergeOnChainEventBody() {
  return { onChainEvent: void 0 };
}
var MergeOnChainEventBody = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.onChainEvent !== void 0) {
      OnChainEvent.encode(message.onChainEvent, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMergeOnChainEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.onChainEvent = OnChainEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { onChainEvent: isSet5(object.onChainEvent) ? OnChainEvent.fromJSON(object.onChainEvent) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.onChainEvent !== void 0 && (obj.onChainEvent = message.onChainEvent ? OnChainEvent.toJSON(message.onChainEvent) : void 0);
    return obj;
  },
  create(base) {
    return MergeOnChainEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseMergeOnChainEventBody();
    message.onChainEvent = object.onChainEvent !== void 0 && object.onChainEvent !== null ? OnChainEvent.fromPartial(object.onChainEvent) : void 0;
    return message;
  }
};
function createBaseMergeUserNameProofBody() {
  return {
    usernameProof: void 0,
    deletedUsernameProof: void 0,
    usernameProofMessage: void 0,
    deletedUsernameProofMessage: void 0
  };
}
var MergeUserNameProofBody = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.usernameProof !== void 0) {
      UserNameProof.encode(message.usernameProof, writer.uint32(10).fork()).ldelim();
    }
    if (message.deletedUsernameProof !== void 0) {
      UserNameProof.encode(message.deletedUsernameProof, writer.uint32(18).fork()).ldelim();
    }
    if (message.usernameProofMessage !== void 0) {
      Message.encode(message.usernameProofMessage, writer.uint32(26).fork()).ldelim();
    }
    if (message.deletedUsernameProofMessage !== void 0) {
      Message.encode(message.deletedUsernameProofMessage, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMergeUserNameProofBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.usernameProof = UserNameProof.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.deletedUsernameProof = UserNameProof.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.usernameProofMessage = Message.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.deletedUsernameProofMessage = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      usernameProof: isSet5(object.usernameProof) ? UserNameProof.fromJSON(object.usernameProof) : void 0,
      deletedUsernameProof: isSet5(object.deletedUsernameProof) ? UserNameProof.fromJSON(object.deletedUsernameProof) : void 0,
      usernameProofMessage: isSet5(object.usernameProofMessage) ? Message.fromJSON(object.usernameProofMessage) : void 0,
      deletedUsernameProofMessage: isSet5(object.deletedUsernameProofMessage) ? Message.fromJSON(object.deletedUsernameProofMessage) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.usernameProof !== void 0 && (obj.usernameProof = message.usernameProof ? UserNameProof.toJSON(message.usernameProof) : void 0);
    message.deletedUsernameProof !== void 0 && (obj.deletedUsernameProof = message.deletedUsernameProof ? UserNameProof.toJSON(message.deletedUsernameProof) : void 0);
    message.usernameProofMessage !== void 0 && (obj.usernameProofMessage = message.usernameProofMessage ? Message.toJSON(message.usernameProofMessage) : void 0);
    message.deletedUsernameProofMessage !== void 0 && (obj.deletedUsernameProofMessage = message.deletedUsernameProofMessage ? Message.toJSON(message.deletedUsernameProofMessage) : void 0);
    return obj;
  },
  create(base) {
    return MergeUserNameProofBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseMergeUserNameProofBody();
    message.usernameProof = object.usernameProof !== void 0 && object.usernameProof !== null ? UserNameProof.fromPartial(object.usernameProof) : void 0;
    message.deletedUsernameProof = object.deletedUsernameProof !== void 0 && object.deletedUsernameProof !== null ? UserNameProof.fromPartial(object.deletedUsernameProof) : void 0;
    message.usernameProofMessage = object.usernameProofMessage !== void 0 && object.usernameProofMessage !== null ? Message.fromPartial(object.usernameProofMessage) : void 0;
    message.deletedUsernameProofMessage = object.deletedUsernameProofMessage !== void 0 && object.deletedUsernameProofMessage !== null ? Message.fromPartial(object.deletedUsernameProofMessage) : void 0;
    return message;
  }
};
function createBaseHubEvent() {
  return {
    type: 0,
    id: 0,
    mergeMessageBody: void 0,
    pruneMessageBody: void 0,
    revokeMessageBody: void 0,
    mergeUsernameProofBody: void 0,
    mergeOnChainEventBody: void 0
  };
}
var HubEvent = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    if (message.mergeMessageBody !== void 0) {
      MergeMessageBody.encode(message.mergeMessageBody, writer.uint32(26).fork()).ldelim();
    }
    if (message.pruneMessageBody !== void 0) {
      PruneMessageBody.encode(message.pruneMessageBody, writer.uint32(34).fork()).ldelim();
    }
    if (message.revokeMessageBody !== void 0) {
      RevokeMessageBody.encode(message.revokeMessageBody, writer.uint32(42).fork()).ldelim();
    }
    if (message.mergeUsernameProofBody !== void 0) {
      MergeUserNameProofBody.encode(message.mergeUsernameProofBody, writer.uint32(66).fork()).ldelim();
    }
    if (message.mergeOnChainEventBody !== void 0) {
      MergeOnChainEventBody.encode(message.mergeOnChainEventBody, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHubEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.id = longToNumber5(reader.uint64());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.mergeMessageBody = MergeMessageBody.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pruneMessageBody = PruneMessageBody.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.revokeMessageBody = RevokeMessageBody.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }
          message.mergeUsernameProofBody = MergeUserNameProofBody.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag != 90) {
            break;
          }
          message.mergeOnChainEventBody = MergeOnChainEventBody.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet5(object.type) ? hubEventTypeFromJSON(object.type) : 0,
      id: isSet5(object.id) ? Number(object.id) : 0,
      mergeMessageBody: isSet5(object.mergeMessageBody) ? MergeMessageBody.fromJSON(object.mergeMessageBody) : void 0,
      pruneMessageBody: isSet5(object.pruneMessageBody) ? PruneMessageBody.fromJSON(object.pruneMessageBody) : void 0,
      revokeMessageBody: isSet5(object.revokeMessageBody) ? RevokeMessageBody.fromJSON(object.revokeMessageBody) : void 0,
      mergeUsernameProofBody: isSet5(object.mergeUsernameProofBody) ? MergeUserNameProofBody.fromJSON(object.mergeUsernameProofBody) : void 0,
      mergeOnChainEventBody: isSet5(object.mergeOnChainEventBody) ? MergeOnChainEventBody.fromJSON(object.mergeOnChainEventBody) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = hubEventTypeToJSON(message.type));
    message.id !== void 0 && (obj.id = Math.round(message.id));
    message.mergeMessageBody !== void 0 && (obj.mergeMessageBody = message.mergeMessageBody ? MergeMessageBody.toJSON(message.mergeMessageBody) : void 0);
    message.pruneMessageBody !== void 0 && (obj.pruneMessageBody = message.pruneMessageBody ? PruneMessageBody.toJSON(message.pruneMessageBody) : void 0);
    message.revokeMessageBody !== void 0 && (obj.revokeMessageBody = message.revokeMessageBody ? RevokeMessageBody.toJSON(message.revokeMessageBody) : void 0);
    message.mergeUsernameProofBody !== void 0 && (obj.mergeUsernameProofBody = message.mergeUsernameProofBody ? MergeUserNameProofBody.toJSON(message.mergeUsernameProofBody) : void 0);
    message.mergeOnChainEventBody !== void 0 && (obj.mergeOnChainEventBody = message.mergeOnChainEventBody ? MergeOnChainEventBody.toJSON(message.mergeOnChainEventBody) : void 0);
    return obj;
  },
  create(base) {
    return HubEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseHubEvent();
    message.type = (_a = object.type) != null ? _a : 0;
    message.id = (_b = object.id) != null ? _b : 0;
    message.mergeMessageBody = object.mergeMessageBody !== void 0 && object.mergeMessageBody !== null ? MergeMessageBody.fromPartial(object.mergeMessageBody) : void 0;
    message.pruneMessageBody = object.pruneMessageBody !== void 0 && object.pruneMessageBody !== null ? PruneMessageBody.fromPartial(object.pruneMessageBody) : void 0;
    message.revokeMessageBody = object.revokeMessageBody !== void 0 && object.revokeMessageBody !== null ? RevokeMessageBody.fromPartial(object.revokeMessageBody) : void 0;
    message.mergeUsernameProofBody = object.mergeUsernameProofBody !== void 0 && object.mergeUsernameProofBody !== null ? MergeUserNameProofBody.fromPartial(object.mergeUsernameProofBody) : void 0;
    message.mergeOnChainEventBody = object.mergeOnChainEventBody !== void 0 && object.mergeOnChainEventBody !== null ? MergeOnChainEventBody.fromPartial(object.mergeOnChainEventBody) : void 0;
    return message;
  }
};
var tsProtoGlobalThis5 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber5(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis5.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal5.default.util.Long !== long_default) {
  import_minimal5.default.util.Long = long_default;
  import_minimal5.default.configure();
}
function isSet5(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/hub_state.ts
init_esm_shims();
var import_minimal6 = __toESM(require_minimal2());
function createBaseValidateOrRevokeJobState() {
  return { lastJobTimestamp: 0, lastFid: 0 };
}
var ValidateOrRevokeJobState = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.lastJobTimestamp !== 0) {
      writer.uint32(8).uint32(message.lastJobTimestamp);
    }
    if (message.lastFid !== 0) {
      writer.uint32(16).uint32(message.lastFid);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateOrRevokeJobState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.lastJobTimestamp = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.lastFid = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      lastJobTimestamp: isSet6(object.lastJobTimestamp) ? Number(object.lastJobTimestamp) : 0,
      lastFid: isSet6(object.lastFid) ? Number(object.lastFid) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.lastJobTimestamp !== void 0 && (obj.lastJobTimestamp = Math.round(message.lastJobTimestamp));
    message.lastFid !== void 0 && (obj.lastFid = Math.round(message.lastFid));
    return obj;
  },
  create(base) {
    return ValidateOrRevokeJobState.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseValidateOrRevokeJobState();
    message.lastJobTimestamp = (_a = object.lastJobTimestamp) != null ? _a : 0;
    message.lastFid = (_b = object.lastFid) != null ? _b : 0;
    return message;
  }
};
function createBaseHubState() {
  return { lastFnameProof: 0, lastL2Block: 0, validateOrRevokeState: void 0 };
}
var HubState = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.lastFnameProof !== 0) {
      writer.uint32(16).uint64(message.lastFnameProof);
    }
    if (message.lastL2Block !== 0) {
      writer.uint32(24).uint64(message.lastL2Block);
    }
    if (message.validateOrRevokeState !== void 0) {
      ValidateOrRevokeJobState.encode(message.validateOrRevokeState, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHubState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag != 16) {
            break;
          }
          message.lastFnameProof = longToNumber6(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.lastL2Block = longToNumber6(reader.uint64());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.validateOrRevokeState = ValidateOrRevokeJobState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      lastFnameProof: isSet6(object.lastFnameProof) ? Number(object.lastFnameProof) : 0,
      lastL2Block: isSet6(object.lastL2Block) ? Number(object.lastL2Block) : 0,
      validateOrRevokeState: isSet6(object.validateOrRevokeState) ? ValidateOrRevokeJobState.fromJSON(object.validateOrRevokeState) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.lastFnameProof !== void 0 && (obj.lastFnameProof = Math.round(message.lastFnameProof));
    message.lastL2Block !== void 0 && (obj.lastL2Block = Math.round(message.lastL2Block));
    message.validateOrRevokeState !== void 0 && (obj.validateOrRevokeState = message.validateOrRevokeState ? ValidateOrRevokeJobState.toJSON(message.validateOrRevokeState) : void 0);
    return obj;
  },
  create(base) {
    return HubState.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseHubState();
    message.lastFnameProof = (_a = object.lastFnameProof) != null ? _a : 0;
    message.lastL2Block = (_b = object.lastL2Block) != null ? _b : 0;
    message.validateOrRevokeState = object.validateOrRevokeState !== void 0 && object.validateOrRevokeState !== null ? ValidateOrRevokeJobState.fromPartial(object.validateOrRevokeState) : void 0;
    return message;
  }
};
var tsProtoGlobalThis6 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber6(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis6.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal6.default.util.Long !== long_default) {
  import_minimal6.default.util.Long = long_default;
  import_minimal6.default.configure();
}
function isSet6(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/job.ts
init_esm_shims();
var import_minimal7 = __toESM(require_minimal2());
function createBaseRevokeMessagesBySignerJobPayload() {
  return { fid: 0, signer: new Uint8Array() };
}
var RevokeMessagesBySignerJobPayload = {
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint32(message.fid);
    }
    if (message.signer.length !== 0) {
      writer.uint32(18).bytes(message.signer);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : import_minimal7.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRevokeMessagesBySignerJobPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.signer = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet7(object.fid) ? Number(object.fid) : 0,
      signer: isSet7(object.signer) ? bytesFromBase645(object.signer) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.signer !== void 0 && (obj.signer = base64FromBytes5(message.signer !== void 0 ? message.signer : new Uint8Array()));
    return obj;
  },
  create(base) {
    return RevokeMessagesBySignerJobPayload.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseRevokeMessagesBySignerJobPayload();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.signer = (_b = object.signer) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseUpdateNameRegistryEventExpiryJobPayload() {
  return { fname: new Uint8Array() };
}
var UpdateNameRegistryEventExpiryJobPayload = {
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.fname.length !== 0) {
      writer.uint32(10).bytes(message.fname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : import_minimal7.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateNameRegistryEventExpiryJobPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.fname = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { fname: isSet7(object.fname) ? bytesFromBase645(object.fname) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.fname !== void 0 && (obj.fname = base64FromBytes5(message.fname !== void 0 ? message.fname : new Uint8Array()));
    return obj;
  },
  create(base) {
    return UpdateNameRegistryEventExpiryJobPayload.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUpdateNameRegistryEventExpiryJobPayload();
    message.fname = (_a = object.fname) != null ? _a : new Uint8Array();
    return message;
  }
};
var tsProtoGlobalThis7 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase645(b64) {
  if (tsProtoGlobalThis7.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis7.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis7.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes5(arr) {
  if (tsProtoGlobalThis7.Buffer) {
    return tsProtoGlobalThis7.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis7.btoa(bin.join(""));
  }
}
function isSet7(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/sync_trie.ts
init_esm_shims();
var import_minimal8 = __toESM(require_minimal2());
function createBaseDbTrieNode() {
  return { key: new Uint8Array(), childChars: [], items: 0, hash: new Uint8Array() };
}
var DbTrieNode = {
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    writer.uint32(18).fork();
    for (const v of message.childChars) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.items !== 0) {
      writer.uint32(24).uint32(message.items);
    }
    if (message.hash.length !== 0) {
      writer.uint32(34).bytes(message.hash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDbTrieNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.key = reader.bytes();
          continue;
        case 2:
          if (tag == 16) {
            message.childChars.push(reader.uint32());
            continue;
          }
          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.childChars.push(reader.uint32());
            }
            continue;
          }
          break;
        case 3:
          if (tag != 24) {
            break;
          }
          message.items = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.hash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet8(object.key) ? bytesFromBase646(object.key) : new Uint8Array(),
      childChars: Array.isArray(object == null ? void 0 : object.childChars) ? object.childChars.map((e) => Number(e)) : [],
      items: isSet8(object.items) ? Number(object.items) : 0,
      hash: isSet8(object.hash) ? bytesFromBase646(object.hash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes6(message.key !== void 0 ? message.key : new Uint8Array()));
    if (message.childChars) {
      obj.childChars = message.childChars.map((e) => Math.round(e));
    } else {
      obj.childChars = [];
    }
    message.items !== void 0 && (obj.items = Math.round(message.items));
    message.hash !== void 0 && (obj.hash = base64FromBytes6(message.hash !== void 0 ? message.hash : new Uint8Array()));
    return obj;
  },
  create(base) {
    return DbTrieNode.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseDbTrieNode();
    message.key = (_a = object.key) != null ? _a : new Uint8Array();
    message.childChars = ((_b = object.childChars) == null ? void 0 : _b.map((e) => e)) || [];
    message.items = (_c = object.items) != null ? _c : 0;
    message.hash = (_d = object.hash) != null ? _d : new Uint8Array();
    return message;
  }
};
var tsProtoGlobalThis8 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase646(b64) {
  if (tsProtoGlobalThis8.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis8.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis8.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes6(arr) {
  if (tsProtoGlobalThis8.Buffer) {
    return tsProtoGlobalThis8.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis8.btoa(bin.join(""));
  }
}
function isSet8(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/request_response.ts
init_esm_shims();
var import_minimal9 = __toESM(require_minimal2());
var StoreType = /* @__PURE__ */ ((StoreType2) => {
  StoreType2[StoreType2["NONE"] = 0] = "NONE";
  StoreType2[StoreType2["CASTS"] = 1] = "CASTS";
  StoreType2[StoreType2["LINKS"] = 2] = "LINKS";
  StoreType2[StoreType2["REACTIONS"] = 3] = "REACTIONS";
  StoreType2[StoreType2["USER_DATA"] = 4] = "USER_DATA";
  StoreType2[StoreType2["VERIFICATIONS"] = 5] = "VERIFICATIONS";
  StoreType2[StoreType2["USERNAME_PROOFS"] = 6] = "USERNAME_PROOFS";
  return StoreType2;
})(StoreType || {});
function storeTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STORE_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "STORE_TYPE_CASTS":
      return 1 /* CASTS */;
    case 2:
    case "STORE_TYPE_LINKS":
      return 2 /* LINKS */;
    case 3:
    case "STORE_TYPE_REACTIONS":
      return 3 /* REACTIONS */;
    case 4:
    case "STORE_TYPE_USER_DATA":
      return 4 /* USER_DATA */;
    case 5:
    case "STORE_TYPE_VERIFICATIONS":
      return 5 /* VERIFICATIONS */;
    case 6:
    case "STORE_TYPE_USERNAME_PROOFS":
      return 6 /* USERNAME_PROOFS */;
    default:
      throw new tsProtoGlobalThis9.Error("Unrecognized enum value " + object + " for enum StoreType");
  }
}
function storeTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "STORE_TYPE_NONE";
    case 1 /* CASTS */:
      return "STORE_TYPE_CASTS";
    case 2 /* LINKS */:
      return "STORE_TYPE_LINKS";
    case 3 /* REACTIONS */:
      return "STORE_TYPE_REACTIONS";
    case 4 /* USER_DATA */:
      return "STORE_TYPE_USER_DATA";
    case 5 /* VERIFICATIONS */:
      return "STORE_TYPE_VERIFICATIONS";
    case 6 /* USERNAME_PROOFS */:
      return "STORE_TYPE_USERNAME_PROOFS";
    default:
      throw new tsProtoGlobalThis9.Error("Unrecognized enum value " + object + " for enum StoreType");
  }
}
var StorageUnitType = /* @__PURE__ */ ((StorageUnitType2) => {
  StorageUnitType2[StorageUnitType2["UNIT_TYPE_LEGACY"] = 0] = "UNIT_TYPE_LEGACY";
  StorageUnitType2[StorageUnitType2["UNIT_TYPE_2024"] = 1] = "UNIT_TYPE_2024";
  return StorageUnitType2;
})(StorageUnitType || {});
function storageUnitTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNIT_TYPE_LEGACY":
      return 0 /* UNIT_TYPE_LEGACY */;
    case 1:
    case "UNIT_TYPE_2024":
      return 1 /* UNIT_TYPE_2024 */;
    default:
      throw new tsProtoGlobalThis9.Error("Unrecognized enum value " + object + " for enum StorageUnitType");
  }
}
function storageUnitTypeToJSON(object) {
  switch (object) {
    case 0 /* UNIT_TYPE_LEGACY */:
      return "UNIT_TYPE_LEGACY";
    case 1 /* UNIT_TYPE_2024 */:
      return "UNIT_TYPE_2024";
    default:
      throw new tsProtoGlobalThis9.Error("Unrecognized enum value " + object + " for enum StorageUnitType");
  }
}
function createBaseEmpty() {
  return {};
}
var Empty = {
  encode(_, writer = import_minimal9.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return Empty.fromPartial(base != null ? base : {});
  },
  fromPartial(_) {
    const message = createBaseEmpty();
    return message;
  }
};
function createBaseSubscribeRequest() {
  return { eventTypes: [], fromId: void 0, totalShards: void 0, shardIndex: void 0 };
}
var SubscribeRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.eventTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.fromId !== void 0) {
      writer.uint32(16).uint64(message.fromId);
    }
    if (message.totalShards !== void 0) {
      writer.uint32(24).uint64(message.totalShards);
    }
    if (message.shardIndex !== void 0) {
      writer.uint32(32).uint64(message.shardIndex);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 8) {
            message.eventTypes.push(reader.int32());
            continue;
          }
          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.eventTypes.push(reader.int32());
            }
            continue;
          }
          break;
        case 2:
          if (tag != 16) {
            break;
          }
          message.fromId = longToNumber7(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.totalShards = longToNumber7(reader.uint64());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.shardIndex = longToNumber7(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      eventTypes: Array.isArray(object == null ? void 0 : object.eventTypes) ? object.eventTypes.map((e) => hubEventTypeFromJSON(e)) : [],
      fromId: isSet9(object.fromId) ? Number(object.fromId) : void 0,
      totalShards: isSet9(object.totalShards) ? Number(object.totalShards) : void 0,
      shardIndex: isSet9(object.shardIndex) ? Number(object.shardIndex) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.eventTypes) {
      obj.eventTypes = message.eventTypes.map((e) => hubEventTypeToJSON(e));
    } else {
      obj.eventTypes = [];
    }
    message.fromId !== void 0 && (obj.fromId = Math.round(message.fromId));
    message.totalShards !== void 0 && (obj.totalShards = Math.round(message.totalShards));
    message.shardIndex !== void 0 && (obj.shardIndex = Math.round(message.shardIndex));
    return obj;
  },
  create(base) {
    return SubscribeRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseSubscribeRequest();
    message.eventTypes = ((_a = object.eventTypes) == null ? void 0 : _a.map((e) => e)) || [];
    message.fromId = (_b = object.fromId) != null ? _b : void 0;
    message.totalShards = (_c = object.totalShards) != null ? _c : void 0;
    message.shardIndex = (_d = object.shardIndex) != null ? _d : void 0;
    return message;
  }
};
function createBaseEventRequest() {
  return { id: 0 };
}
var EventRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.id = longToNumber7(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet9(object.id) ? Number(object.id) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = Math.round(message.id));
    return obj;
  },
  create(base) {
    return EventRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseEventRequest();
    message.id = (_a = object.id) != null ? _a : 0;
    return message;
  }
};
function createBaseHubInfoRequest() {
  return { dbStats: false };
}
var HubInfoRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.dbStats === true) {
      writer.uint32(8).bool(message.dbStats);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHubInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.dbStats = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { dbStats: isSet9(object.dbStats) ? Boolean(object.dbStats) : false };
  },
  toJSON(message) {
    const obj = {};
    message.dbStats !== void 0 && (obj.dbStats = message.dbStats);
    return obj;
  },
  create(base) {
    return HubInfoRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseHubInfoRequest();
    message.dbStats = (_a = object.dbStats) != null ? _a : false;
    return message;
  }
};
function createBaseHubInfoResponse() {
  return {
    version: "",
    isSyncing: false,
    nickname: "",
    rootHash: "",
    dbStats: void 0,
    peerId: "",
    hubOperatorFid: 0
  };
}
var HubInfoResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.isSyncing === true) {
      writer.uint32(16).bool(message.isSyncing);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.rootHash !== "") {
      writer.uint32(34).string(message.rootHash);
    }
    if (message.dbStats !== void 0) {
      DbStats.encode(message.dbStats, writer.uint32(42).fork()).ldelim();
    }
    if (message.peerId !== "") {
      writer.uint32(50).string(message.peerId);
    }
    if (message.hubOperatorFid !== 0) {
      writer.uint32(56).uint64(message.hubOperatorFid);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHubInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.version = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.isSyncing = reader.bool();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.nickname = reader.string();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.rootHash = reader.string();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.dbStats = DbStats.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.peerId = reader.string();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }
          message.hubOperatorFid = longToNumber7(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      version: isSet9(object.version) ? String(object.version) : "",
      isSyncing: isSet9(object.isSyncing) ? Boolean(object.isSyncing) : false,
      nickname: isSet9(object.nickname) ? String(object.nickname) : "",
      rootHash: isSet9(object.rootHash) ? String(object.rootHash) : "",
      dbStats: isSet9(object.dbStats) ? DbStats.fromJSON(object.dbStats) : void 0,
      peerId: isSet9(object.peerId) ? String(object.peerId) : "",
      hubOperatorFid: isSet9(object.hubOperatorFid) ? Number(object.hubOperatorFid) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.version !== void 0 && (obj.version = message.version);
    message.isSyncing !== void 0 && (obj.isSyncing = message.isSyncing);
    message.nickname !== void 0 && (obj.nickname = message.nickname);
    message.rootHash !== void 0 && (obj.rootHash = message.rootHash);
    message.dbStats !== void 0 && (obj.dbStats = message.dbStats ? DbStats.toJSON(message.dbStats) : void 0);
    message.peerId !== void 0 && (obj.peerId = message.peerId);
    message.hubOperatorFid !== void 0 && (obj.hubOperatorFid = Math.round(message.hubOperatorFid));
    return obj;
  },
  create(base) {
    return HubInfoResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseHubInfoResponse();
    message.version = (_a = object.version) != null ? _a : "";
    message.isSyncing = (_b = object.isSyncing) != null ? _b : false;
    message.nickname = (_c = object.nickname) != null ? _c : "";
    message.rootHash = (_d = object.rootHash) != null ? _d : "";
    message.dbStats = object.dbStats !== void 0 && object.dbStats !== null ? DbStats.fromPartial(object.dbStats) : void 0;
    message.peerId = (_e = object.peerId) != null ? _e : "";
    message.hubOperatorFid = (_f = object.hubOperatorFid) != null ? _f : 0;
    return message;
  }
};
function createBaseDbStats() {
  return { numMessages: 0, numFidEvents: 0, numFnameEvents: 0, approxSize: 0 };
}
var DbStats = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.numMessages !== 0) {
      writer.uint32(8).uint64(message.numMessages);
    }
    if (message.numFidEvents !== 0) {
      writer.uint32(16).uint64(message.numFidEvents);
    }
    if (message.numFnameEvents !== 0) {
      writer.uint32(24).uint64(message.numFnameEvents);
    }
    if (message.approxSize !== 0) {
      writer.uint32(32).uint64(message.approxSize);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDbStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.numMessages = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.numFidEvents = longToNumber7(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.numFnameEvents = longToNumber7(reader.uint64());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.approxSize = longToNumber7(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      numMessages: isSet9(object.numMessages) ? Number(object.numMessages) : 0,
      numFidEvents: isSet9(object.numFidEvents) ? Number(object.numFidEvents) : 0,
      numFnameEvents: isSet9(object.numFnameEvents) ? Number(object.numFnameEvents) : 0,
      approxSize: isSet9(object.approxSize) ? Number(object.approxSize) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.numMessages !== void 0 && (obj.numMessages = Math.round(message.numMessages));
    message.numFidEvents !== void 0 && (obj.numFidEvents = Math.round(message.numFidEvents));
    message.numFnameEvents !== void 0 && (obj.numFnameEvents = Math.round(message.numFnameEvents));
    message.approxSize !== void 0 && (obj.approxSize = Math.round(message.approxSize));
    return obj;
  },
  create(base) {
    return DbStats.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseDbStats();
    message.numMessages = (_a = object.numMessages) != null ? _a : 0;
    message.numFidEvents = (_b = object.numFidEvents) != null ? _b : 0;
    message.numFnameEvents = (_c = object.numFnameEvents) != null ? _c : 0;
    message.approxSize = (_d = object.approxSize) != null ? _d : 0;
    return message;
  }
};
function createBaseSyncStatusRequest() {
  return { peerId: void 0 };
}
var SyncStatusRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.peerId !== void 0) {
      writer.uint32(10).string(message.peerId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSyncStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.peerId = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { peerId: isSet9(object.peerId) ? String(object.peerId) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.peerId !== void 0 && (obj.peerId = message.peerId);
    return obj;
  },
  create(base) {
    return SyncStatusRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSyncStatusRequest();
    message.peerId = (_a = object.peerId) != null ? _a : void 0;
    return message;
  }
};
function createBaseSyncStatusResponse() {
  return { isSyncing: false, syncStatus: [], engineStarted: false };
}
var SyncStatusResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.isSyncing === true) {
      writer.uint32(8).bool(message.isSyncing);
    }
    for (const v of message.syncStatus) {
      SyncStatus.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.engineStarted === true) {
      writer.uint32(24).bool(message.engineStarted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSyncStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.isSyncing = reader.bool();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.syncStatus.push(SyncStatus.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.engineStarted = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isSyncing: isSet9(object.isSyncing) ? Boolean(object.isSyncing) : false,
      syncStatus: Array.isArray(object == null ? void 0 : object.syncStatus) ? object.syncStatus.map((e) => SyncStatus.fromJSON(e)) : [],
      engineStarted: isSet9(object.engineStarted) ? Boolean(object.engineStarted) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.isSyncing !== void 0 && (obj.isSyncing = message.isSyncing);
    if (message.syncStatus) {
      obj.syncStatus = message.syncStatus.map((e) => e ? SyncStatus.toJSON(e) : void 0);
    } else {
      obj.syncStatus = [];
    }
    message.engineStarted !== void 0 && (obj.engineStarted = message.engineStarted);
    return obj;
  },
  create(base) {
    return SyncStatusResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseSyncStatusResponse();
    message.isSyncing = (_a = object.isSyncing) != null ? _a : false;
    message.syncStatus = ((_b = object.syncStatus) == null ? void 0 : _b.map((e) => SyncStatus.fromPartial(e))) || [];
    message.engineStarted = (_c = object.engineStarted) != null ? _c : false;
    return message;
  }
};
function createBaseSyncStatus() {
  return {
    peerId: "",
    inSync: "",
    shouldSync: false,
    divergencePrefix: "",
    divergenceSecondsAgo: 0,
    theirMessages: 0,
    ourMessages: 0,
    lastBadSync: 0,
    score: 0
  };
}
var SyncStatus = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.peerId !== "") {
      writer.uint32(10).string(message.peerId);
    }
    if (message.inSync !== "") {
      writer.uint32(18).string(message.inSync);
    }
    if (message.shouldSync === true) {
      writer.uint32(24).bool(message.shouldSync);
    }
    if (message.divergencePrefix !== "") {
      writer.uint32(34).string(message.divergencePrefix);
    }
    if (message.divergenceSecondsAgo !== 0) {
      writer.uint32(40).int32(message.divergenceSecondsAgo);
    }
    if (message.theirMessages !== 0) {
      writer.uint32(48).uint64(message.theirMessages);
    }
    if (message.ourMessages !== 0) {
      writer.uint32(56).uint64(message.ourMessages);
    }
    if (message.lastBadSync !== 0) {
      writer.uint32(64).int64(message.lastBadSync);
    }
    if (message.score !== 0) {
      writer.uint32(72).int64(message.score);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSyncStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.peerId = reader.string();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.inSync = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.shouldSync = reader.bool();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.divergencePrefix = reader.string();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.divergenceSecondsAgo = reader.int32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.theirMessages = longToNumber7(reader.uint64());
          continue;
        case 7:
          if (tag != 56) {
            break;
          }
          message.ourMessages = longToNumber7(reader.uint64());
          continue;
        case 8:
          if (tag != 64) {
            break;
          }
          message.lastBadSync = longToNumber7(reader.int64());
          continue;
        case 9:
          if (tag != 72) {
            break;
          }
          message.score = longToNumber7(reader.int64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      peerId: isSet9(object.peerId) ? String(object.peerId) : "",
      inSync: isSet9(object.inSync) ? String(object.inSync) : "",
      shouldSync: isSet9(object.shouldSync) ? Boolean(object.shouldSync) : false,
      divergencePrefix: isSet9(object.divergencePrefix) ? String(object.divergencePrefix) : "",
      divergenceSecondsAgo: isSet9(object.divergenceSecondsAgo) ? Number(object.divergenceSecondsAgo) : 0,
      theirMessages: isSet9(object.theirMessages) ? Number(object.theirMessages) : 0,
      ourMessages: isSet9(object.ourMessages) ? Number(object.ourMessages) : 0,
      lastBadSync: isSet9(object.lastBadSync) ? Number(object.lastBadSync) : 0,
      score: isSet9(object.score) ? Number(object.score) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.peerId !== void 0 && (obj.peerId = message.peerId);
    message.inSync !== void 0 && (obj.inSync = message.inSync);
    message.shouldSync !== void 0 && (obj.shouldSync = message.shouldSync);
    message.divergencePrefix !== void 0 && (obj.divergencePrefix = message.divergencePrefix);
    message.divergenceSecondsAgo !== void 0 && (obj.divergenceSecondsAgo = Math.round(message.divergenceSecondsAgo));
    message.theirMessages !== void 0 && (obj.theirMessages = Math.round(message.theirMessages));
    message.ourMessages !== void 0 && (obj.ourMessages = Math.round(message.ourMessages));
    message.lastBadSync !== void 0 && (obj.lastBadSync = Math.round(message.lastBadSync));
    message.score !== void 0 && (obj.score = Math.round(message.score));
    return obj;
  },
  create(base) {
    return SyncStatus.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const message = createBaseSyncStatus();
    message.peerId = (_a = object.peerId) != null ? _a : "";
    message.inSync = (_b = object.inSync) != null ? _b : "";
    message.shouldSync = (_c = object.shouldSync) != null ? _c : false;
    message.divergencePrefix = (_d = object.divergencePrefix) != null ? _d : "";
    message.divergenceSecondsAgo = (_e = object.divergenceSecondsAgo) != null ? _e : 0;
    message.theirMessages = (_f = object.theirMessages) != null ? _f : 0;
    message.ourMessages = (_g = object.ourMessages) != null ? _g : 0;
    message.lastBadSync = (_h = object.lastBadSync) != null ? _h : 0;
    message.score = (_i = object.score) != null ? _i : 0;
    return message;
  }
};
function createBaseTrieNodeMetadataResponse() {
  return { prefix: new Uint8Array(), numMessages: 0, hash: "", children: [] };
}
var TrieNodeMetadataResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.prefix.length !== 0) {
      writer.uint32(10).bytes(message.prefix);
    }
    if (message.numMessages !== 0) {
      writer.uint32(16).uint64(message.numMessages);
    }
    if (message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    for (const v of message.children) {
      TrieNodeMetadataResponse.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTrieNodeMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.prefix = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.numMessages = longToNumber7(reader.uint64());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.hash = reader.string();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.children.push(TrieNodeMetadataResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      prefix: isSet9(object.prefix) ? bytesFromBase647(object.prefix) : new Uint8Array(),
      numMessages: isSet9(object.numMessages) ? Number(object.numMessages) : 0,
      hash: isSet9(object.hash) ? String(object.hash) : "",
      children: Array.isArray(object == null ? void 0 : object.children) ? object.children.map((e) => TrieNodeMetadataResponse.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.prefix !== void 0 && (obj.prefix = base64FromBytes7(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
    message.numMessages !== void 0 && (obj.numMessages = Math.round(message.numMessages));
    message.hash !== void 0 && (obj.hash = message.hash);
    if (message.children) {
      obj.children = message.children.map((e) => e ? TrieNodeMetadataResponse.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    return obj;
  },
  create(base) {
    return TrieNodeMetadataResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseTrieNodeMetadataResponse();
    message.prefix = (_a = object.prefix) != null ? _a : new Uint8Array();
    message.numMessages = (_b = object.numMessages) != null ? _b : 0;
    message.hash = (_c = object.hash) != null ? _c : "";
    message.children = ((_d = object.children) == null ? void 0 : _d.map((e) => TrieNodeMetadataResponse.fromPartial(e))) || [];
    return message;
  }
};
function createBaseTrieNodeSnapshotResponse() {
  return { prefix: new Uint8Array(), excludedHashes: [], numMessages: 0, rootHash: "" };
}
var TrieNodeSnapshotResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.prefix.length !== 0) {
      writer.uint32(10).bytes(message.prefix);
    }
    for (const v of message.excludedHashes) {
      writer.uint32(18).string(v);
    }
    if (message.numMessages !== 0) {
      writer.uint32(24).uint64(message.numMessages);
    }
    if (message.rootHash !== "") {
      writer.uint32(34).string(message.rootHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTrieNodeSnapshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.prefix = reader.bytes();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.excludedHashes.push(reader.string());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.numMessages = longToNumber7(reader.uint64());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.rootHash = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      prefix: isSet9(object.prefix) ? bytesFromBase647(object.prefix) : new Uint8Array(),
      excludedHashes: Array.isArray(object == null ? void 0 : object.excludedHashes) ? object.excludedHashes.map((e) => String(e)) : [],
      numMessages: isSet9(object.numMessages) ? Number(object.numMessages) : 0,
      rootHash: isSet9(object.rootHash) ? String(object.rootHash) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.prefix !== void 0 && (obj.prefix = base64FromBytes7(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
    if (message.excludedHashes) {
      obj.excludedHashes = message.excludedHashes.map((e) => e);
    } else {
      obj.excludedHashes = [];
    }
    message.numMessages !== void 0 && (obj.numMessages = Math.round(message.numMessages));
    message.rootHash !== void 0 && (obj.rootHash = message.rootHash);
    return obj;
  },
  create(base) {
    return TrieNodeSnapshotResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseTrieNodeSnapshotResponse();
    message.prefix = (_a = object.prefix) != null ? _a : new Uint8Array();
    message.excludedHashes = ((_b = object.excludedHashes) == null ? void 0 : _b.map((e) => e)) || [];
    message.numMessages = (_c = object.numMessages) != null ? _c : 0;
    message.rootHash = (_d = object.rootHash) != null ? _d : "";
    return message;
  }
};
function createBaseTrieNodePrefix() {
  return { prefix: new Uint8Array() };
}
var TrieNodePrefix = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.prefix.length !== 0) {
      writer.uint32(10).bytes(message.prefix);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTrieNodePrefix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.prefix = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { prefix: isSet9(object.prefix) ? bytesFromBase647(object.prefix) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.prefix !== void 0 && (obj.prefix = base64FromBytes7(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
    return obj;
  },
  create(base) {
    return TrieNodePrefix.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseTrieNodePrefix();
    message.prefix = (_a = object.prefix) != null ? _a : new Uint8Array();
    return message;
  }
};
function createBaseSyncIds() {
  return { syncIds: [] };
}
var SyncIds = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v of message.syncIds) {
      writer.uint32(10).bytes(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSyncIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.syncIds.push(reader.bytes());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { syncIds: Array.isArray(object == null ? void 0 : object.syncIds) ? object.syncIds.map((e) => bytesFromBase647(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.syncIds) {
      obj.syncIds = message.syncIds.map((e) => base64FromBytes7(e !== void 0 ? e : new Uint8Array()));
    } else {
      obj.syncIds = [];
    }
    return obj;
  },
  create(base) {
    return SyncIds.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSyncIds();
    message.syncIds = ((_a = object.syncIds) == null ? void 0 : _a.map((e) => e)) || [];
    return message;
  }
};
function createBaseFidRequest() {
  return { fid: 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var FidRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(16).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(26).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(32).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      pageSize: isSet9(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet9(object.pageToken) ? bytesFromBase647(object.pageToken) : void 0,
      reverse: isSet9(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes7(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return FidRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseFidRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.pageSize = (_b = object.pageSize) != null ? _b : void 0;
    message.pageToken = (_c = object.pageToken) != null ? _c : void 0;
    message.reverse = (_d = object.reverse) != null ? _d : void 0;
    return message;
  }
};
function createBaseFidTimestampRequest() {
  return {
    fid: 0,
    pageSize: void 0,
    pageToken: void 0,
    reverse: void 0,
    startTimestamp: void 0,
    stopTimestamp: void 0
  };
}
var FidTimestampRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(16).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(26).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(32).bool(message.reverse);
    }
    if (message.startTimestamp !== void 0) {
      writer.uint32(40).uint64(message.startTimestamp);
    }
    if (message.stopTimestamp !== void 0) {
      writer.uint32(48).uint64(message.stopTimestamp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidTimestampRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.reverse = reader.bool();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.startTimestamp = longToNumber7(reader.uint64());
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.stopTimestamp = longToNumber7(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      pageSize: isSet9(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet9(object.pageToken) ? bytesFromBase647(object.pageToken) : void 0,
      reverse: isSet9(object.reverse) ? Boolean(object.reverse) : void 0,
      startTimestamp: isSet9(object.startTimestamp) ? Number(object.startTimestamp) : void 0,
      stopTimestamp: isSet9(object.stopTimestamp) ? Number(object.stopTimestamp) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes7(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    message.startTimestamp !== void 0 && (obj.startTimestamp = Math.round(message.startTimestamp));
    message.stopTimestamp !== void 0 && (obj.stopTimestamp = Math.round(message.stopTimestamp));
    return obj;
  },
  create(base) {
    return FidTimestampRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseFidTimestampRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.pageSize = (_b = object.pageSize) != null ? _b : void 0;
    message.pageToken = (_c = object.pageToken) != null ? _c : void 0;
    message.reverse = (_d = object.reverse) != null ? _d : void 0;
    message.startTimestamp = (_e = object.startTimestamp) != null ? _e : void 0;
    message.stopTimestamp = (_f = object.stopTimestamp) != null ? _f : void 0;
    return message;
  }
};
function createBaseFidsRequest() {
  return { pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var FidsRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.pageSize !== void 0) {
      writer.uint32(8).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(18).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(24).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      pageSize: isSet9(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet9(object.pageToken) ? bytesFromBase647(object.pageToken) : void 0,
      reverse: isSet9(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes7(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return FidsRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseFidsRequest();
    message.pageSize = (_a = object.pageSize) != null ? _a : void 0;
    message.pageToken = (_b = object.pageToken) != null ? _b : void 0;
    message.reverse = (_c = object.reverse) != null ? _c : void 0;
    return message;
  }
};
function createBaseFidsResponse() {
  return { fids: [], nextPageToken: void 0 };
}
var FidsResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.fids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.nextPageToken !== void 0) {
      writer.uint32(18).bytes(message.nextPageToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 8) {
            message.fids.push(longToNumber7(reader.uint64()));
            continue;
          }
          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.fids.push(longToNumber7(reader.uint64()));
            }
            continue;
          }
          break;
        case 2:
          if (tag != 18) {
            break;
          }
          message.nextPageToken = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fids: Array.isArray(object == null ? void 0 : object.fids) ? object.fids.map((e) => Number(e)) : [],
      nextPageToken: isSet9(object.nextPageToken) ? bytesFromBase647(object.nextPageToken) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fids) {
      obj.fids = message.fids.map((e) => Math.round(e));
    } else {
      obj.fids = [];
    }
    message.nextPageToken !== void 0 && (obj.nextPageToken = message.nextPageToken !== void 0 ? base64FromBytes7(message.nextPageToken) : void 0);
    return obj;
  },
  create(base) {
    return FidsResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseFidsResponse();
    message.fids = ((_a = object.fids) == null ? void 0 : _a.map((e) => e)) || [];
    message.nextPageToken = (_b = object.nextPageToken) != null ? _b : void 0;
    return message;
  }
};
function createBaseMessagesResponse() {
  return { messages: [], nextPageToken: void 0 };
}
var MessagesResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v of message.messages) {
      Message.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== void 0) {
      writer.uint32(18).bytes(message.nextPageToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.nextPageToken = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: Array.isArray(object == null ? void 0 : object.messages) ? object.messages.map((e) => Message.fromJSON(e)) : [],
      nextPageToken: isSet9(object.nextPageToken) ? bytesFromBase647(object.nextPageToken) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages) {
      obj.messages = message.messages.map((e) => e ? Message.toJSON(e) : void 0);
    } else {
      obj.messages = [];
    }
    message.nextPageToken !== void 0 && (obj.nextPageToken = message.nextPageToken !== void 0 ? base64FromBytes7(message.nextPageToken) : void 0);
    return obj;
  },
  create(base) {
    return MessagesResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMessagesResponse();
    message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => Message.fromPartial(e))) || [];
    message.nextPageToken = (_b = object.nextPageToken) != null ? _b : void 0;
    return message;
  }
};
function createBaseCastsByParentRequest() {
  return {
    parentCastId: void 0,
    parentUrl: void 0,
    pageSize: void 0,
    pageToken: void 0,
    reverse: void 0
  };
}
var CastsByParentRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.parentCastId !== void 0) {
      CastId.encode(message.parentCastId, writer.uint32(10).fork()).ldelim();
    }
    if (message.parentUrl !== void 0) {
      writer.uint32(42).string(message.parentUrl);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(16).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(26).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(32).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCastsByParentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.parentCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.parentUrl = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      parentCastId: isSet9(object.parentCastId) ? CastId.fromJSON(object.parentCastId) : void 0,
      parentUrl: isSet9(object.parentUrl) ? String(object.parentUrl) : void 0,
      pageSize: isSet9(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet9(object.pageToken) ? bytesFromBase647(object.pageToken) : void 0,
      reverse: isSet9(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.parentCastId !== void 0 && (obj.parentCastId = message.parentCastId ? CastId.toJSON(message.parentCastId) : void 0);
    message.parentUrl !== void 0 && (obj.parentUrl = message.parentUrl);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes7(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return CastsByParentRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCastsByParentRequest();
    message.parentCastId = object.parentCastId !== void 0 && object.parentCastId !== null ? CastId.fromPartial(object.parentCastId) : void 0;
    message.parentUrl = (_a = object.parentUrl) != null ? _a : void 0;
    message.pageSize = (_b = object.pageSize) != null ? _b : void 0;
    message.pageToken = (_c = object.pageToken) != null ? _c : void 0;
    message.reverse = (_d = object.reverse) != null ? _d : void 0;
    return message;
  }
};
function createBaseReactionRequest() {
  return { fid: 0, reactionType: 0, targetCastId: void 0, targetUrl: void 0 };
}
var ReactionRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.reactionType !== 0) {
      writer.uint32(16).int32(message.reactionType);
    }
    if (message.targetCastId !== void 0) {
      CastId.encode(message.targetCastId, writer.uint32(26).fork()).ldelim();
    }
    if (message.targetUrl !== void 0) {
      writer.uint32(34).string(message.targetUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.reactionType = reader.int32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.targetCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.targetUrl = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      reactionType: isSet9(object.reactionType) ? reactionTypeFromJSON(object.reactionType) : 0,
      targetCastId: isSet9(object.targetCastId) ? CastId.fromJSON(object.targetCastId) : void 0,
      targetUrl: isSet9(object.targetUrl) ? String(object.targetUrl) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.reactionType !== void 0 && (obj.reactionType = reactionTypeToJSON(message.reactionType));
    message.targetCastId !== void 0 && (obj.targetCastId = message.targetCastId ? CastId.toJSON(message.targetCastId) : void 0);
    message.targetUrl !== void 0 && (obj.targetUrl = message.targetUrl);
    return obj;
  },
  create(base) {
    return ReactionRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseReactionRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.reactionType = (_b = object.reactionType) != null ? _b : 0;
    message.targetCastId = object.targetCastId !== void 0 && object.targetCastId !== null ? CastId.fromPartial(object.targetCastId) : void 0;
    message.targetUrl = (_c = object.targetUrl) != null ? _c : void 0;
    return message;
  }
};
function createBaseReactionsByFidRequest() {
  return { fid: 0, reactionType: void 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var ReactionsByFidRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.reactionType !== void 0) {
      writer.uint32(16).int32(message.reactionType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReactionsByFidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.reactionType = reader.int32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      reactionType: isSet9(object.reactionType) ? reactionTypeFromJSON(object.reactionType) : void 0,
      pageSize: isSet9(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet9(object.pageToken) ? bytesFromBase647(object.pageToken) : void 0,
      reverse: isSet9(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.reactionType !== void 0 && (obj.reactionType = message.reactionType !== void 0 ? reactionTypeToJSON(message.reactionType) : void 0);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes7(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return ReactionsByFidRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseReactionsByFidRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.reactionType = (_b = object.reactionType) != null ? _b : void 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseReactionsByTargetRequest() {
  return {
    targetCastId: void 0,
    targetUrl: void 0,
    reactionType: void 0,
    pageSize: void 0,
    pageToken: void 0,
    reverse: void 0
  };
}
var ReactionsByTargetRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.targetCastId !== void 0) {
      CastId.encode(message.targetCastId, writer.uint32(10).fork()).ldelim();
    }
    if (message.targetUrl !== void 0) {
      writer.uint32(50).string(message.targetUrl);
    }
    if (message.reactionType !== void 0) {
      writer.uint32(16).int32(message.reactionType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReactionsByTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.targetCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.targetUrl = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.reactionType = reader.int32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      targetCastId: isSet9(object.targetCastId) ? CastId.fromJSON(object.targetCastId) : void 0,
      targetUrl: isSet9(object.targetUrl) ? String(object.targetUrl) : void 0,
      reactionType: isSet9(object.reactionType) ? reactionTypeFromJSON(object.reactionType) : void 0,
      pageSize: isSet9(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet9(object.pageToken) ? bytesFromBase647(object.pageToken) : void 0,
      reverse: isSet9(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.targetCastId !== void 0 && (obj.targetCastId = message.targetCastId ? CastId.toJSON(message.targetCastId) : void 0);
    message.targetUrl !== void 0 && (obj.targetUrl = message.targetUrl);
    message.reactionType !== void 0 && (obj.reactionType = message.reactionType !== void 0 ? reactionTypeToJSON(message.reactionType) : void 0);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes7(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return ReactionsByTargetRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseReactionsByTargetRequest();
    message.targetCastId = object.targetCastId !== void 0 && object.targetCastId !== null ? CastId.fromPartial(object.targetCastId) : void 0;
    message.targetUrl = (_a = object.targetUrl) != null ? _a : void 0;
    message.reactionType = (_b = object.reactionType) != null ? _b : void 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseUserDataRequest() {
  return { fid: 0, userDataType: 0 };
}
var UserDataRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.userDataType !== 0) {
      writer.uint32(16).int32(message.userDataType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.userDataType = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      userDataType: isSet9(object.userDataType) ? userDataTypeFromJSON(object.userDataType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.userDataType !== void 0 && (obj.userDataType = userDataTypeToJSON(message.userDataType));
    return obj;
  },
  create(base) {
    return UserDataRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseUserDataRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.userDataType = (_b = object.userDataType) != null ? _b : 0;
    return message;
  }
};
function createBaseNameRegistryEventRequest() {
  return { name: new Uint8Array() };
}
var NameRegistryEventRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.name.length !== 0) {
      writer.uint32(10).bytes(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNameRegistryEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.name = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet9(object.name) ? bytesFromBase647(object.name) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = base64FromBytes7(message.name !== void 0 ? message.name : new Uint8Array()));
    return obj;
  },
  create(base) {
    return NameRegistryEventRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseNameRegistryEventRequest();
    message.name = (_a = object.name) != null ? _a : new Uint8Array();
    return message;
  }
};
function createBaseRentRegistryEventsRequest() {
  return { fid: 0 };
}
var RentRegistryEventsRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRentRegistryEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { fid: isSet9(object.fid) ? Number(object.fid) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    return obj;
  },
  create(base) {
    return RentRegistryEventsRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseRentRegistryEventsRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    return message;
  }
};
function createBaseOnChainEventRequest() {
  return { fid: 0, eventType: 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var OnChainEventRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnChainEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.eventType = reader.int32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      eventType: isSet9(object.eventType) ? onChainEventTypeFromJSON(object.eventType) : 0,
      pageSize: isSet9(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet9(object.pageToken) ? bytesFromBase647(object.pageToken) : void 0,
      reverse: isSet9(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.eventType !== void 0 && (obj.eventType = onChainEventTypeToJSON(message.eventType));
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes7(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return OnChainEventRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseOnChainEventRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.eventType = (_b = object.eventType) != null ? _b : 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseOnChainEventResponse() {
  return { events: [], nextPageToken: void 0 };
}
var OnChainEventResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v of message.events) {
      OnChainEvent.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== void 0) {
      writer.uint32(18).bytes(message.nextPageToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnChainEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.events.push(OnChainEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.nextPageToken = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      events: Array.isArray(object == null ? void 0 : object.events) ? object.events.map((e) => OnChainEvent.fromJSON(e)) : [],
      nextPageToken: isSet9(object.nextPageToken) ? bytesFromBase647(object.nextPageToken) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.events) {
      obj.events = message.events.map((e) => e ? OnChainEvent.toJSON(e) : void 0);
    } else {
      obj.events = [];
    }
    message.nextPageToken !== void 0 && (obj.nextPageToken = message.nextPageToken !== void 0 ? base64FromBytes7(message.nextPageToken) : void 0);
    return obj;
  },
  create(base) {
    return OnChainEventResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseOnChainEventResponse();
    message.events = ((_a = object.events) == null ? void 0 : _a.map((e) => OnChainEvent.fromPartial(e))) || [];
    message.nextPageToken = (_b = object.nextPageToken) != null ? _b : void 0;
    return message;
  }
};
function createBaseStorageLimitsResponse() {
  return { limits: [], units: 0, unitDetails: [] };
}
var StorageLimitsResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v of message.limits) {
      StorageLimit.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.units !== 0) {
      writer.uint32(16).uint32(message.units);
    }
    for (const v of message.unitDetails) {
      StorageUnitDetails.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorageLimitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.limits.push(StorageLimit.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.units = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.unitDetails.push(StorageUnitDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      limits: Array.isArray(object == null ? void 0 : object.limits) ? object.limits.map((e) => StorageLimit.fromJSON(e)) : [],
      units: isSet9(object.units) ? Number(object.units) : 0,
      unitDetails: Array.isArray(object == null ? void 0 : object.unitDetails) ? object.unitDetails.map((e) => StorageUnitDetails.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.limits) {
      obj.limits = message.limits.map((e) => e ? StorageLimit.toJSON(e) : void 0);
    } else {
      obj.limits = [];
    }
    message.units !== void 0 && (obj.units = Math.round(message.units));
    if (message.unitDetails) {
      obj.unitDetails = message.unitDetails.map((e) => e ? StorageUnitDetails.toJSON(e) : void 0);
    } else {
      obj.unitDetails = [];
    }
    return obj;
  },
  create(base) {
    return StorageLimitsResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseStorageLimitsResponse();
    message.limits = ((_a = object.limits) == null ? void 0 : _a.map((e) => StorageLimit.fromPartial(e))) || [];
    message.units = (_b = object.units) != null ? _b : 0;
    message.unitDetails = ((_c = object.unitDetails) == null ? void 0 : _c.map((e) => StorageUnitDetails.fromPartial(e))) || [];
    return message;
  }
};
function createBaseStorageUnitDetails() {
  return { unitType: 0, unitSize: 0 };
}
var StorageUnitDetails = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.unitType !== 0) {
      writer.uint32(8).int32(message.unitType);
    }
    if (message.unitSize !== 0) {
      writer.uint32(16).uint32(message.unitSize);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorageUnitDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.unitType = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.unitSize = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      unitType: isSet9(object.unitType) ? storageUnitTypeFromJSON(object.unitType) : 0,
      unitSize: isSet9(object.unitSize) ? Number(object.unitSize) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.unitType !== void 0 && (obj.unitType = storageUnitTypeToJSON(message.unitType));
    message.unitSize !== void 0 && (obj.unitSize = Math.round(message.unitSize));
    return obj;
  },
  create(base) {
    return StorageUnitDetails.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseStorageUnitDetails();
    message.unitType = (_a = object.unitType) != null ? _a : 0;
    message.unitSize = (_b = object.unitSize) != null ? _b : 0;
    return message;
  }
};
function createBaseStorageLimit() {
  return { storeType: 0, name: "", limit: 0, used: 0, earliestTimestamp: 0, earliestHash: new Uint8Array() };
}
var StorageLimit = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.storeType !== 0) {
      writer.uint32(8).int32(message.storeType);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint64(message.limit);
    }
    if (message.used !== 0) {
      writer.uint32(32).uint64(message.used);
    }
    if (message.earliestTimestamp !== 0) {
      writer.uint32(40).uint64(message.earliestTimestamp);
    }
    if (message.earliestHash.length !== 0) {
      writer.uint32(50).bytes(message.earliestHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorageLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.storeType = reader.int32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.limit = longToNumber7(reader.uint64());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.used = longToNumber7(reader.uint64());
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.earliestTimestamp = longToNumber7(reader.uint64());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.earliestHash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      storeType: isSet9(object.storeType) ? storeTypeFromJSON(object.storeType) : 0,
      name: isSet9(object.name) ? String(object.name) : "",
      limit: isSet9(object.limit) ? Number(object.limit) : 0,
      used: isSet9(object.used) ? Number(object.used) : 0,
      earliestTimestamp: isSet9(object.earliestTimestamp) ? Number(object.earliestTimestamp) : 0,
      earliestHash: isSet9(object.earliestHash) ? bytesFromBase647(object.earliestHash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.storeType !== void 0 && (obj.storeType = storeTypeToJSON(message.storeType));
    message.name !== void 0 && (obj.name = message.name);
    message.limit !== void 0 && (obj.limit = Math.round(message.limit));
    message.used !== void 0 && (obj.used = Math.round(message.used));
    message.earliestTimestamp !== void 0 && (obj.earliestTimestamp = Math.round(message.earliestTimestamp));
    message.earliestHash !== void 0 && (obj.earliestHash = base64FromBytes7(
      message.earliestHash !== void 0 ? message.earliestHash : new Uint8Array()
    ));
    return obj;
  },
  create(base) {
    return StorageLimit.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseStorageLimit();
    message.storeType = (_a = object.storeType) != null ? _a : 0;
    message.name = (_b = object.name) != null ? _b : "";
    message.limit = (_c = object.limit) != null ? _c : 0;
    message.used = (_d = object.used) != null ? _d : 0;
    message.earliestTimestamp = (_e = object.earliestTimestamp) != null ? _e : 0;
    message.earliestHash = (_f = object.earliestHash) != null ? _f : new Uint8Array();
    return message;
  }
};
function createBaseUsernameProofRequest() {
  return { name: new Uint8Array() };
}
var UsernameProofRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.name.length !== 0) {
      writer.uint32(10).bytes(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUsernameProofRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.name = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet9(object.name) ? bytesFromBase647(object.name) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = base64FromBytes7(message.name !== void 0 ? message.name : new Uint8Array()));
    return obj;
  },
  create(base) {
    return UsernameProofRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUsernameProofRequest();
    message.name = (_a = object.name) != null ? _a : new Uint8Array();
    return message;
  }
};
function createBaseUsernameProofsResponse() {
  return { proofs: [] };
}
var UsernameProofsResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v of message.proofs) {
      UserNameProof.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUsernameProofsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.proofs.push(UserNameProof.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { proofs: Array.isArray(object == null ? void 0 : object.proofs) ? object.proofs.map((e) => UserNameProof.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.proofs) {
      obj.proofs = message.proofs.map((e) => e ? UserNameProof.toJSON(e) : void 0);
    } else {
      obj.proofs = [];
    }
    return obj;
  },
  create(base) {
    return UsernameProofsResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUsernameProofsResponse();
    message.proofs = ((_a = object.proofs) == null ? void 0 : _a.map((e) => UserNameProof.fromPartial(e))) || [];
    return message;
  }
};
function createBaseVerificationRequest() {
  return { fid: 0, address: new Uint8Array() };
}
var VerificationRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVerificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.address = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      address: isSet9(object.address) ? bytesFromBase647(object.address) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.address !== void 0 && (obj.address = base64FromBytes7(message.address !== void 0 ? message.address : new Uint8Array()));
    return obj;
  },
  create(base) {
    return VerificationRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseVerificationRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.address = (_b = object.address) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseSignerRequest() {
  return { fid: 0, signer: new Uint8Array() };
}
var SignerRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.signer.length !== 0) {
      writer.uint32(18).bytes(message.signer);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.signer = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      signer: isSet9(object.signer) ? bytesFromBase647(object.signer) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.signer !== void 0 && (obj.signer = base64FromBytes7(message.signer !== void 0 ? message.signer : new Uint8Array()));
    return obj;
  },
  create(base) {
    return SignerRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseSignerRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.signer = (_b = object.signer) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseLinkRequest() {
  return { fid: 0, linkType: "", targetFid: void 0 };
}
var LinkRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.linkType !== "") {
      writer.uint32(18).string(message.linkType);
    }
    if (message.targetFid !== void 0) {
      writer.uint32(24).uint64(message.targetFid);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.linkType = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.targetFid = longToNumber7(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      linkType: isSet9(object.linkType) ? String(object.linkType) : "",
      targetFid: isSet9(object.targetFid) ? Number(object.targetFid) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.linkType !== void 0 && (obj.linkType = message.linkType);
    message.targetFid !== void 0 && (obj.targetFid = Math.round(message.targetFid));
    return obj;
  },
  create(base) {
    return LinkRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseLinkRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.linkType = (_b = object.linkType) != null ? _b : "";
    message.targetFid = (_c = object.targetFid) != null ? _c : void 0;
    return message;
  }
};
function createBaseLinksByFidRequest() {
  return { fid: 0, linkType: void 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var LinksByFidRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.linkType !== void 0) {
      writer.uint32(18).string(message.linkType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinksByFidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.linkType = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet9(object.fid) ? Number(object.fid) : 0,
      linkType: isSet9(object.linkType) ? String(object.linkType) : void 0,
      pageSize: isSet9(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet9(object.pageToken) ? bytesFromBase647(object.pageToken) : void 0,
      reverse: isSet9(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.linkType !== void 0 && (obj.linkType = message.linkType);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes7(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return LinksByFidRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseLinksByFidRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.linkType = (_b = object.linkType) != null ? _b : void 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseLinksByTargetRequest() {
  return { targetFid: void 0, linkType: void 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var LinksByTargetRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.targetFid !== void 0) {
      writer.uint32(8).uint64(message.targetFid);
    }
    if (message.linkType !== void 0) {
      writer.uint32(18).string(message.linkType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinksByTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.targetFid = longToNumber7(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.linkType = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      targetFid: isSet9(object.targetFid) ? Number(object.targetFid) : void 0,
      linkType: isSet9(object.linkType) ? String(object.linkType) : void 0,
      pageSize: isSet9(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet9(object.pageToken) ? bytesFromBase647(object.pageToken) : void 0,
      reverse: isSet9(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.targetFid !== void 0 && (obj.targetFid = Math.round(message.targetFid));
    message.linkType !== void 0 && (obj.linkType = message.linkType);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes7(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return LinksByTargetRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseLinksByTargetRequest();
    message.targetFid = (_a = object.targetFid) != null ? _a : void 0;
    message.linkType = (_b = object.linkType) != null ? _b : void 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseIdRegistryEventByAddressRequest() {
  return { address: new Uint8Array() };
}
var IdRegistryEventByAddressRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIdRegistryEventByAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.address = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { address: isSet9(object.address) ? bytesFromBase647(object.address) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = base64FromBytes7(message.address !== void 0 ? message.address : new Uint8Array()));
    return obj;
  },
  create(base) {
    return IdRegistryEventByAddressRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseIdRegistryEventByAddressRequest();
    message.address = (_a = object.address) != null ? _a : new Uint8Array();
    return message;
  }
};
function createBaseContactInfoResponse() {
  return { contacts: [] };
}
var ContactInfoResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v of message.contacts) {
      ContactInfoContentBody.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContactInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.contacts.push(ContactInfoContentBody.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contacts: Array.isArray(object == null ? void 0 : object.contacts) ? object.contacts.map((e) => ContactInfoContentBody.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contacts) {
      obj.contacts = message.contacts.map((e) => e ? ContactInfoContentBody.toJSON(e) : void 0);
    } else {
      obj.contacts = [];
    }
    return obj;
  },
  create(base) {
    return ContactInfoResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseContactInfoResponse();
    message.contacts = ((_a = object.contacts) == null ? void 0 : _a.map((e) => ContactInfoContentBody.fromPartial(e))) || [];
    return message;
  }
};
function createBaseValidationResponse() {
  return { valid: false, message: void 0 };
}
var ValidationResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.valid === true) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.valid = reader.bool();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      valid: isSet9(object.valid) ? Boolean(object.valid) : false,
      message: isSet9(object.message) ? Message.fromJSON(object.message) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.valid !== void 0 && (obj.valid = message.valid);
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    return obj;
  },
  create(base) {
    return ValidationResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseValidationResponse();
    message.valid = (_a = object.valid) != null ? _a : false;
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    return message;
  }
};
function createBaseSubmitBulkMessagesRequest() {
  return { messages: [] };
}
var SubmitBulkMessagesRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v of message.messages) {
      Message.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitBulkMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { messages: Array.isArray(object == null ? void 0 : object.messages) ? object.messages.map((e) => Message.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages) {
      obj.messages = message.messages.map((e) => e ? Message.toJSON(e) : void 0);
    } else {
      obj.messages = [];
    }
    return obj;
  },
  create(base) {
    return SubmitBulkMessagesRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSubmitBulkMessagesRequest();
    message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => Message.fromPartial(e))) || [];
    return message;
  }
};
function createBaseMessageError() {
  return { hash: new Uint8Array(), errCode: "", message: "" };
}
var MessageError = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (message.errCode !== "") {
      writer.uint32(18).string(message.errCode);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.hash = reader.bytes();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.errCode = reader.string();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.message = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      hash: isSet9(object.hash) ? bytesFromBase647(object.hash) : new Uint8Array(),
      errCode: isSet9(object.errCode) ? String(object.errCode) : "",
      message: isSet9(object.message) ? String(object.message) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.hash !== void 0 && (obj.hash = base64FromBytes7(message.hash !== void 0 ? message.hash : new Uint8Array()));
    message.errCode !== void 0 && (obj.errCode = message.errCode);
    message.message !== void 0 && (obj.message = message.message);
    return obj;
  },
  create(base) {
    return MessageError.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseMessageError();
    message.hash = (_a = object.hash) != null ? _a : new Uint8Array();
    message.errCode = (_b = object.errCode) != null ? _b : "";
    message.message = (_c = object.message) != null ? _c : "";
    return message;
  }
};
function createBaseBulkMessageResponse() {
  return { message: void 0, messageError: void 0 };
}
var BulkMessageResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    if (message.messageError !== void 0) {
      MessageError.encode(message.messageError, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBulkMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.messageError = MessageError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet9(object.message) ? Message.fromJSON(object.message) : void 0,
      messageError: isSet9(object.messageError) ? MessageError.fromJSON(object.messageError) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    message.messageError !== void 0 && (obj.messageError = message.messageError ? MessageError.toJSON(message.messageError) : void 0);
    return obj;
  },
  create(base) {
    return BulkMessageResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseBulkMessageResponse();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    message.messageError = object.messageError !== void 0 && object.messageError !== null ? MessageError.fromPartial(object.messageError) : void 0;
    return message;
  }
};
function createBaseSubmitBulkMessagesResponse() {
  return { messages: [] };
}
var SubmitBulkMessagesResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    for (const v of message.messages) {
      BulkMessageResponse.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitBulkMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.messages.push(BulkMessageResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: Array.isArray(object == null ? void 0 : object.messages) ? object.messages.map((e) => BulkMessageResponse.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages) {
      obj.messages = message.messages.map((e) => e ? BulkMessageResponse.toJSON(e) : void 0);
    } else {
      obj.messages = [];
    }
    return obj;
  },
  create(base) {
    return SubmitBulkMessagesResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSubmitBulkMessagesResponse();
    message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => BulkMessageResponse.fromPartial(e))) || [];
    return message;
  }
};
function createBaseStreamSyncRequest() {
  return {
    getInfo: void 0,
    getCurrentPeers: void 0,
    stopSync: void 0,
    forceSync: void 0,
    getSyncStatus: void 0,
    getAllSyncIdsByPrefix: void 0,
    getAllMessagesBySyncIds: void 0,
    getSyncMetadataByPrefix: void 0,
    getSyncSnapshotByPrefix: void 0,
    getOnChainEvents: void 0,
    getOnChainSignersByFid: void 0
  };
}
var StreamSyncRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.getInfo !== void 0) {
      HubInfoRequest.encode(message.getInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.getCurrentPeers !== void 0) {
      Empty.encode(message.getCurrentPeers, writer.uint32(18).fork()).ldelim();
    }
    if (message.stopSync !== void 0) {
      Empty.encode(message.stopSync, writer.uint32(26).fork()).ldelim();
    }
    if (message.forceSync !== void 0) {
      SyncStatusRequest.encode(message.forceSync, writer.uint32(34).fork()).ldelim();
    }
    if (message.getSyncStatus !== void 0) {
      SyncStatusRequest.encode(message.getSyncStatus, writer.uint32(42).fork()).ldelim();
    }
    if (message.getAllSyncIdsByPrefix !== void 0) {
      TrieNodePrefix.encode(message.getAllSyncIdsByPrefix, writer.uint32(50).fork()).ldelim();
    }
    if (message.getAllMessagesBySyncIds !== void 0) {
      SyncIds.encode(message.getAllMessagesBySyncIds, writer.uint32(58).fork()).ldelim();
    }
    if (message.getSyncMetadataByPrefix !== void 0) {
      TrieNodePrefix.encode(message.getSyncMetadataByPrefix, writer.uint32(66).fork()).ldelim();
    }
    if (message.getSyncSnapshotByPrefix !== void 0) {
      TrieNodePrefix.encode(message.getSyncSnapshotByPrefix, writer.uint32(74).fork()).ldelim();
    }
    if (message.getOnChainEvents !== void 0) {
      OnChainEventRequest.encode(message.getOnChainEvents, writer.uint32(82).fork()).ldelim();
    }
    if (message.getOnChainSignersByFid !== void 0) {
      FidRequest.encode(message.getOnChainSignersByFid, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStreamSyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.getInfo = HubInfoRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.getCurrentPeers = Empty.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.stopSync = Empty.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.forceSync = SyncStatusRequest.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.getSyncStatus = SyncStatusRequest.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.getAllSyncIdsByPrefix = TrieNodePrefix.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.getAllMessagesBySyncIds = SyncIds.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }
          message.getSyncMetadataByPrefix = TrieNodePrefix.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag != 74) {
            break;
          }
          message.getSyncSnapshotByPrefix = TrieNodePrefix.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag != 82) {
            break;
          }
          message.getOnChainEvents = OnChainEventRequest.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag != 90) {
            break;
          }
          message.getOnChainSignersByFid = FidRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      getInfo: isSet9(object.getInfo) ? HubInfoRequest.fromJSON(object.getInfo) : void 0,
      getCurrentPeers: isSet9(object.getCurrentPeers) ? Empty.fromJSON(object.getCurrentPeers) : void 0,
      stopSync: isSet9(object.stopSync) ? Empty.fromJSON(object.stopSync) : void 0,
      forceSync: isSet9(object.forceSync) ? SyncStatusRequest.fromJSON(object.forceSync) : void 0,
      getSyncStatus: isSet9(object.getSyncStatus) ? SyncStatusRequest.fromJSON(object.getSyncStatus) : void 0,
      getAllSyncIdsByPrefix: isSet9(object.getAllSyncIdsByPrefix) ? TrieNodePrefix.fromJSON(object.getAllSyncIdsByPrefix) : void 0,
      getAllMessagesBySyncIds: isSet9(object.getAllMessagesBySyncIds) ? SyncIds.fromJSON(object.getAllMessagesBySyncIds) : void 0,
      getSyncMetadataByPrefix: isSet9(object.getSyncMetadataByPrefix) ? TrieNodePrefix.fromJSON(object.getSyncMetadataByPrefix) : void 0,
      getSyncSnapshotByPrefix: isSet9(object.getSyncSnapshotByPrefix) ? TrieNodePrefix.fromJSON(object.getSyncSnapshotByPrefix) : void 0,
      getOnChainEvents: isSet9(object.getOnChainEvents) ? OnChainEventRequest.fromJSON(object.getOnChainEvents) : void 0,
      getOnChainSignersByFid: isSet9(object.getOnChainSignersByFid) ? FidRequest.fromJSON(object.getOnChainSignersByFid) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.getInfo !== void 0 && (obj.getInfo = message.getInfo ? HubInfoRequest.toJSON(message.getInfo) : void 0);
    message.getCurrentPeers !== void 0 && (obj.getCurrentPeers = message.getCurrentPeers ? Empty.toJSON(message.getCurrentPeers) : void 0);
    message.stopSync !== void 0 && (obj.stopSync = message.stopSync ? Empty.toJSON(message.stopSync) : void 0);
    message.forceSync !== void 0 && (obj.forceSync = message.forceSync ? SyncStatusRequest.toJSON(message.forceSync) : void 0);
    message.getSyncStatus !== void 0 && (obj.getSyncStatus = message.getSyncStatus ? SyncStatusRequest.toJSON(message.getSyncStatus) : void 0);
    message.getAllSyncIdsByPrefix !== void 0 && (obj.getAllSyncIdsByPrefix = message.getAllSyncIdsByPrefix ? TrieNodePrefix.toJSON(message.getAllSyncIdsByPrefix) : void 0);
    message.getAllMessagesBySyncIds !== void 0 && (obj.getAllMessagesBySyncIds = message.getAllMessagesBySyncIds ? SyncIds.toJSON(message.getAllMessagesBySyncIds) : void 0);
    message.getSyncMetadataByPrefix !== void 0 && (obj.getSyncMetadataByPrefix = message.getSyncMetadataByPrefix ? TrieNodePrefix.toJSON(message.getSyncMetadataByPrefix) : void 0);
    message.getSyncSnapshotByPrefix !== void 0 && (obj.getSyncSnapshotByPrefix = message.getSyncSnapshotByPrefix ? TrieNodePrefix.toJSON(message.getSyncSnapshotByPrefix) : void 0);
    message.getOnChainEvents !== void 0 && (obj.getOnChainEvents = message.getOnChainEvents ? OnChainEventRequest.toJSON(message.getOnChainEvents) : void 0);
    message.getOnChainSignersByFid !== void 0 && (obj.getOnChainSignersByFid = message.getOnChainSignersByFid ? FidRequest.toJSON(message.getOnChainSignersByFid) : void 0);
    return obj;
  },
  create(base) {
    return StreamSyncRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseStreamSyncRequest();
    message.getInfo = object.getInfo !== void 0 && object.getInfo !== null ? HubInfoRequest.fromPartial(object.getInfo) : void 0;
    message.getCurrentPeers = object.getCurrentPeers !== void 0 && object.getCurrentPeers !== null ? Empty.fromPartial(object.getCurrentPeers) : void 0;
    message.stopSync = object.stopSync !== void 0 && object.stopSync !== null ? Empty.fromPartial(object.stopSync) : void 0;
    message.forceSync = object.forceSync !== void 0 && object.forceSync !== null ? SyncStatusRequest.fromPartial(object.forceSync) : void 0;
    message.getSyncStatus = object.getSyncStatus !== void 0 && object.getSyncStatus !== null ? SyncStatusRequest.fromPartial(object.getSyncStatus) : void 0;
    message.getAllSyncIdsByPrefix = object.getAllSyncIdsByPrefix !== void 0 && object.getAllSyncIdsByPrefix !== null ? TrieNodePrefix.fromPartial(object.getAllSyncIdsByPrefix) : void 0;
    message.getAllMessagesBySyncIds = object.getAllMessagesBySyncIds !== void 0 && object.getAllMessagesBySyncIds !== null ? SyncIds.fromPartial(object.getAllMessagesBySyncIds) : void 0;
    message.getSyncMetadataByPrefix = object.getSyncMetadataByPrefix !== void 0 && object.getSyncMetadataByPrefix !== null ? TrieNodePrefix.fromPartial(object.getSyncMetadataByPrefix) : void 0;
    message.getSyncSnapshotByPrefix = object.getSyncSnapshotByPrefix !== void 0 && object.getSyncSnapshotByPrefix !== null ? TrieNodePrefix.fromPartial(object.getSyncSnapshotByPrefix) : void 0;
    message.getOnChainEvents = object.getOnChainEvents !== void 0 && object.getOnChainEvents !== null ? OnChainEventRequest.fromPartial(object.getOnChainEvents) : void 0;
    message.getOnChainSignersByFid = object.getOnChainSignersByFid !== void 0 && object.getOnChainSignersByFid !== null ? FidRequest.fromPartial(object.getOnChainSignersByFid) : void 0;
    return message;
  }
};
function createBaseStreamError() {
  return { errCode: "", message: "", request: "" };
}
var StreamError = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.errCode !== "") {
      writer.uint32(10).string(message.errCode);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.request !== "") {
      writer.uint32(26).string(message.request);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStreamError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.errCode = reader.string();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.message = reader.string();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.request = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      errCode: isSet9(object.errCode) ? String(object.errCode) : "",
      message: isSet9(object.message) ? String(object.message) : "",
      request: isSet9(object.request) ? String(object.request) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.errCode !== void 0 && (obj.errCode = message.errCode);
    message.message !== void 0 && (obj.message = message.message);
    message.request !== void 0 && (obj.request = message.request);
    return obj;
  },
  create(base) {
    return StreamError.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseStreamError();
    message.errCode = (_a = object.errCode) != null ? _a : "";
    message.message = (_b = object.message) != null ? _b : "";
    message.request = (_c = object.request) != null ? _c : "";
    return message;
  }
};
function createBaseStreamSyncResponse() {
  return {
    getInfo: void 0,
    getCurrentPeers: void 0,
    stopSync: void 0,
    forceSync: void 0,
    getSyncStatus: void 0,
    getAllSyncIdsByPrefix: void 0,
    getAllMessagesBySyncIds: void 0,
    getSyncMetadataByPrefix: void 0,
    getSyncSnapshotByPrefix: void 0,
    getOnChainEvents: void 0,
    getOnChainSignersByFid: void 0,
    error: void 0
  };
}
var StreamSyncResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.getInfo !== void 0) {
      HubInfoResponse.encode(message.getInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.getCurrentPeers !== void 0) {
      ContactInfoResponse.encode(message.getCurrentPeers, writer.uint32(18).fork()).ldelim();
    }
    if (message.stopSync !== void 0) {
      SyncStatusResponse.encode(message.stopSync, writer.uint32(26).fork()).ldelim();
    }
    if (message.forceSync !== void 0) {
      SyncStatusResponse.encode(message.forceSync, writer.uint32(34).fork()).ldelim();
    }
    if (message.getSyncStatus !== void 0) {
      SyncStatusResponse.encode(message.getSyncStatus, writer.uint32(42).fork()).ldelim();
    }
    if (message.getAllSyncIdsByPrefix !== void 0) {
      SyncIds.encode(message.getAllSyncIdsByPrefix, writer.uint32(50).fork()).ldelim();
    }
    if (message.getAllMessagesBySyncIds !== void 0) {
      MessagesResponse.encode(message.getAllMessagesBySyncIds, writer.uint32(58).fork()).ldelim();
    }
    if (message.getSyncMetadataByPrefix !== void 0) {
      TrieNodeMetadataResponse.encode(message.getSyncMetadataByPrefix, writer.uint32(66).fork()).ldelim();
    }
    if (message.getSyncSnapshotByPrefix !== void 0) {
      TrieNodeSnapshotResponse.encode(message.getSyncSnapshotByPrefix, writer.uint32(74).fork()).ldelim();
    }
    if (message.getOnChainEvents !== void 0) {
      OnChainEventResponse.encode(message.getOnChainEvents, writer.uint32(82).fork()).ldelim();
    }
    if (message.getOnChainSignersByFid !== void 0) {
      OnChainEventResponse.encode(message.getOnChainSignersByFid, writer.uint32(90).fork()).ldelim();
    }
    if (message.error !== void 0) {
      StreamError.encode(message.error, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStreamSyncResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.getInfo = HubInfoResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.getCurrentPeers = ContactInfoResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.stopSync = SyncStatusResponse.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.forceSync = SyncStatusResponse.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.getSyncStatus = SyncStatusResponse.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.getAllSyncIdsByPrefix = SyncIds.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.getAllMessagesBySyncIds = MessagesResponse.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }
          message.getSyncMetadataByPrefix = TrieNodeMetadataResponse.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag != 74) {
            break;
          }
          message.getSyncSnapshotByPrefix = TrieNodeSnapshotResponse.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag != 82) {
            break;
          }
          message.getOnChainEvents = OnChainEventResponse.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag != 90) {
            break;
          }
          message.getOnChainSignersByFid = OnChainEventResponse.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag != 98) {
            break;
          }
          message.error = StreamError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      getInfo: isSet9(object.getInfo) ? HubInfoResponse.fromJSON(object.getInfo) : void 0,
      getCurrentPeers: isSet9(object.getCurrentPeers) ? ContactInfoResponse.fromJSON(object.getCurrentPeers) : void 0,
      stopSync: isSet9(object.stopSync) ? SyncStatusResponse.fromJSON(object.stopSync) : void 0,
      forceSync: isSet9(object.forceSync) ? SyncStatusResponse.fromJSON(object.forceSync) : void 0,
      getSyncStatus: isSet9(object.getSyncStatus) ? SyncStatusResponse.fromJSON(object.getSyncStatus) : void 0,
      getAllSyncIdsByPrefix: isSet9(object.getAllSyncIdsByPrefix) ? SyncIds.fromJSON(object.getAllSyncIdsByPrefix) : void 0,
      getAllMessagesBySyncIds: isSet9(object.getAllMessagesBySyncIds) ? MessagesResponse.fromJSON(object.getAllMessagesBySyncIds) : void 0,
      getSyncMetadataByPrefix: isSet9(object.getSyncMetadataByPrefix) ? TrieNodeMetadataResponse.fromJSON(object.getSyncMetadataByPrefix) : void 0,
      getSyncSnapshotByPrefix: isSet9(object.getSyncSnapshotByPrefix) ? TrieNodeSnapshotResponse.fromJSON(object.getSyncSnapshotByPrefix) : void 0,
      getOnChainEvents: isSet9(object.getOnChainEvents) ? OnChainEventResponse.fromJSON(object.getOnChainEvents) : void 0,
      getOnChainSignersByFid: isSet9(object.getOnChainSignersByFid) ? OnChainEventResponse.fromJSON(object.getOnChainSignersByFid) : void 0,
      error: isSet9(object.error) ? StreamError.fromJSON(object.error) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.getInfo !== void 0 && (obj.getInfo = message.getInfo ? HubInfoResponse.toJSON(message.getInfo) : void 0);
    message.getCurrentPeers !== void 0 && (obj.getCurrentPeers = message.getCurrentPeers ? ContactInfoResponse.toJSON(message.getCurrentPeers) : void 0);
    message.stopSync !== void 0 && (obj.stopSync = message.stopSync ? SyncStatusResponse.toJSON(message.stopSync) : void 0);
    message.forceSync !== void 0 && (obj.forceSync = message.forceSync ? SyncStatusResponse.toJSON(message.forceSync) : void 0);
    message.getSyncStatus !== void 0 && (obj.getSyncStatus = message.getSyncStatus ? SyncStatusResponse.toJSON(message.getSyncStatus) : void 0);
    message.getAllSyncIdsByPrefix !== void 0 && (obj.getAllSyncIdsByPrefix = message.getAllSyncIdsByPrefix ? SyncIds.toJSON(message.getAllSyncIdsByPrefix) : void 0);
    message.getAllMessagesBySyncIds !== void 0 && (obj.getAllMessagesBySyncIds = message.getAllMessagesBySyncIds ? MessagesResponse.toJSON(message.getAllMessagesBySyncIds) : void 0);
    message.getSyncMetadataByPrefix !== void 0 && (obj.getSyncMetadataByPrefix = message.getSyncMetadataByPrefix ? TrieNodeMetadataResponse.toJSON(message.getSyncMetadataByPrefix) : void 0);
    message.getSyncSnapshotByPrefix !== void 0 && (obj.getSyncSnapshotByPrefix = message.getSyncSnapshotByPrefix ? TrieNodeSnapshotResponse.toJSON(message.getSyncSnapshotByPrefix) : void 0);
    message.getOnChainEvents !== void 0 && (obj.getOnChainEvents = message.getOnChainEvents ? OnChainEventResponse.toJSON(message.getOnChainEvents) : void 0);
    message.getOnChainSignersByFid !== void 0 && (obj.getOnChainSignersByFid = message.getOnChainSignersByFid ? OnChainEventResponse.toJSON(message.getOnChainSignersByFid) : void 0);
    message.error !== void 0 && (obj.error = message.error ? StreamError.toJSON(message.error) : void 0);
    return obj;
  },
  create(base) {
    return StreamSyncResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseStreamSyncResponse();
    message.getInfo = object.getInfo !== void 0 && object.getInfo !== null ? HubInfoResponse.fromPartial(object.getInfo) : void 0;
    message.getCurrentPeers = object.getCurrentPeers !== void 0 && object.getCurrentPeers !== null ? ContactInfoResponse.fromPartial(object.getCurrentPeers) : void 0;
    message.stopSync = object.stopSync !== void 0 && object.stopSync !== null ? SyncStatusResponse.fromPartial(object.stopSync) : void 0;
    message.forceSync = object.forceSync !== void 0 && object.forceSync !== null ? SyncStatusResponse.fromPartial(object.forceSync) : void 0;
    message.getSyncStatus = object.getSyncStatus !== void 0 && object.getSyncStatus !== null ? SyncStatusResponse.fromPartial(object.getSyncStatus) : void 0;
    message.getAllSyncIdsByPrefix = object.getAllSyncIdsByPrefix !== void 0 && object.getAllSyncIdsByPrefix !== null ? SyncIds.fromPartial(object.getAllSyncIdsByPrefix) : void 0;
    message.getAllMessagesBySyncIds = object.getAllMessagesBySyncIds !== void 0 && object.getAllMessagesBySyncIds !== null ? MessagesResponse.fromPartial(object.getAllMessagesBySyncIds) : void 0;
    message.getSyncMetadataByPrefix = object.getSyncMetadataByPrefix !== void 0 && object.getSyncMetadataByPrefix !== null ? TrieNodeMetadataResponse.fromPartial(object.getSyncMetadataByPrefix) : void 0;
    message.getSyncSnapshotByPrefix = object.getSyncSnapshotByPrefix !== void 0 && object.getSyncSnapshotByPrefix !== null ? TrieNodeSnapshotResponse.fromPartial(object.getSyncSnapshotByPrefix) : void 0;
    message.getOnChainEvents = object.getOnChainEvents !== void 0 && object.getOnChainEvents !== null ? OnChainEventResponse.fromPartial(object.getOnChainEvents) : void 0;
    message.getOnChainSignersByFid = object.getOnChainSignersByFid !== void 0 && object.getOnChainSignersByFid !== null ? OnChainEventResponse.fromPartial(object.getOnChainSignersByFid) : void 0;
    message.error = object.error !== void 0 && object.error !== null ? StreamError.fromPartial(object.error) : void 0;
    return message;
  }
};
function createBaseStreamFetchRequest() {
  return {
    idempotencyKey: "",
    castMessagesByFid: void 0,
    reactionMessagesByFid: void 0,
    verificationMessagesByFid: void 0,
    userDataMessagesByFid: void 0,
    linkMessagesByFid: void 0
  };
}
var StreamFetchRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.idempotencyKey !== "") {
      writer.uint32(10).string(message.idempotencyKey);
    }
    if (message.castMessagesByFid !== void 0) {
      FidTimestampRequest.encode(message.castMessagesByFid, writer.uint32(18).fork()).ldelim();
    }
    if (message.reactionMessagesByFid !== void 0) {
      FidTimestampRequest.encode(message.reactionMessagesByFid, writer.uint32(26).fork()).ldelim();
    }
    if (message.verificationMessagesByFid !== void 0) {
      FidTimestampRequest.encode(message.verificationMessagesByFid, writer.uint32(34).fork()).ldelim();
    }
    if (message.userDataMessagesByFid !== void 0) {
      FidTimestampRequest.encode(message.userDataMessagesByFid, writer.uint32(42).fork()).ldelim();
    }
    if (message.linkMessagesByFid !== void 0) {
      FidTimestampRequest.encode(message.linkMessagesByFid, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStreamFetchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.idempotencyKey = reader.string();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.castMessagesByFid = FidTimestampRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.reactionMessagesByFid = FidTimestampRequest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.verificationMessagesByFid = FidTimestampRequest.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.userDataMessagesByFid = FidTimestampRequest.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.linkMessagesByFid = FidTimestampRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      idempotencyKey: isSet9(object.idempotencyKey) ? String(object.idempotencyKey) : "",
      castMessagesByFid: isSet9(object.castMessagesByFid) ? FidTimestampRequest.fromJSON(object.castMessagesByFid) : void 0,
      reactionMessagesByFid: isSet9(object.reactionMessagesByFid) ? FidTimestampRequest.fromJSON(object.reactionMessagesByFid) : void 0,
      verificationMessagesByFid: isSet9(object.verificationMessagesByFid) ? FidTimestampRequest.fromJSON(object.verificationMessagesByFid) : void 0,
      userDataMessagesByFid: isSet9(object.userDataMessagesByFid) ? FidTimestampRequest.fromJSON(object.userDataMessagesByFid) : void 0,
      linkMessagesByFid: isSet9(object.linkMessagesByFid) ? FidTimestampRequest.fromJSON(object.linkMessagesByFid) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.idempotencyKey !== void 0 && (obj.idempotencyKey = message.idempotencyKey);
    message.castMessagesByFid !== void 0 && (obj.castMessagesByFid = message.castMessagesByFid ? FidTimestampRequest.toJSON(message.castMessagesByFid) : void 0);
    message.reactionMessagesByFid !== void 0 && (obj.reactionMessagesByFid = message.reactionMessagesByFid ? FidTimestampRequest.toJSON(message.reactionMessagesByFid) : void 0);
    message.verificationMessagesByFid !== void 0 && (obj.verificationMessagesByFid = message.verificationMessagesByFid ? FidTimestampRequest.toJSON(message.verificationMessagesByFid) : void 0);
    message.userDataMessagesByFid !== void 0 && (obj.userDataMessagesByFid = message.userDataMessagesByFid ? FidTimestampRequest.toJSON(message.userDataMessagesByFid) : void 0);
    message.linkMessagesByFid !== void 0 && (obj.linkMessagesByFid = message.linkMessagesByFid ? FidTimestampRequest.toJSON(message.linkMessagesByFid) : void 0);
    return obj;
  },
  create(base) {
    return StreamFetchRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStreamFetchRequest();
    message.idempotencyKey = (_a = object.idempotencyKey) != null ? _a : "";
    message.castMessagesByFid = object.castMessagesByFid !== void 0 && object.castMessagesByFid !== null ? FidTimestampRequest.fromPartial(object.castMessagesByFid) : void 0;
    message.reactionMessagesByFid = object.reactionMessagesByFid !== void 0 && object.reactionMessagesByFid !== null ? FidTimestampRequest.fromPartial(object.reactionMessagesByFid) : void 0;
    message.verificationMessagesByFid = object.verificationMessagesByFid !== void 0 && object.verificationMessagesByFid !== null ? FidTimestampRequest.fromPartial(object.verificationMessagesByFid) : void 0;
    message.userDataMessagesByFid = object.userDataMessagesByFid !== void 0 && object.userDataMessagesByFid !== null ? FidTimestampRequest.fromPartial(object.userDataMessagesByFid) : void 0;
    message.linkMessagesByFid = object.linkMessagesByFid !== void 0 && object.linkMessagesByFid !== null ? FidTimestampRequest.fromPartial(object.linkMessagesByFid) : void 0;
    return message;
  }
};
function createBaseStreamFetchResponse() {
  return { idempotencyKey: "", messages: void 0, error: void 0 };
}
var StreamFetchResponse = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.idempotencyKey !== "") {
      writer.uint32(10).string(message.idempotencyKey);
    }
    if (message.messages !== void 0) {
      MessagesResponse.encode(message.messages, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== void 0) {
      StreamError.encode(message.error, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStreamFetchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.idempotencyKey = reader.string();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.messages = MessagesResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.error = StreamError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      idempotencyKey: isSet9(object.idempotencyKey) ? String(object.idempotencyKey) : "",
      messages: isSet9(object.messages) ? MessagesResponse.fromJSON(object.messages) : void 0,
      error: isSet9(object.error) ? StreamError.fromJSON(object.error) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.idempotencyKey !== void 0 && (obj.idempotencyKey = message.idempotencyKey);
    message.messages !== void 0 && (obj.messages = message.messages ? MessagesResponse.toJSON(message.messages) : void 0);
    message.error !== void 0 && (obj.error = message.error ? StreamError.toJSON(message.error) : void 0);
    return obj;
  },
  create(base) {
    return StreamFetchResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStreamFetchResponse();
    message.idempotencyKey = (_a = object.idempotencyKey) != null ? _a : "";
    message.messages = object.messages !== void 0 && object.messages !== null ? MessagesResponse.fromPartial(object.messages) : void 0;
    message.error = object.error !== void 0 && object.error !== null ? StreamError.fromPartial(object.error) : void 0;
    return message;
  }
};
var tsProtoGlobalThis9 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase647(b64) {
  if (tsProtoGlobalThis9.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis9.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis9.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes7(arr) {
  if (tsProtoGlobalThis9.Buffer) {
    return tsProtoGlobalThis9.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis9.btoa(bin.join(""));
  }
}
function longToNumber7(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis9.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal9.default.util.Long !== long_default) {
  import_minimal9.default.util.Long = long_default;
  import_minimal9.default.configure();
}
function isSet9(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/typeguards.ts
init_esm_shims();
var isCastAddData = (data) => {
  return data.type === 1 /* CAST_ADD */ && typeof data.castAddBody !== "undefined";
};
var isCastAddMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isCastAddData(message.data);
};
var isCastRemoveData = (data) => {
  return data.type === 2 /* CAST_REMOVE */ && typeof data.castRemoveBody !== "undefined";
};
var isCastRemoveMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isCastRemoveData(message.data);
};
var isLinkAddData = (data) => {
  return data.type === 5 /* LINK_ADD */ && typeof data.linkBody !== "undefined";
};
var isLinkCompactStateMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && message.data.type === 14 /* LINK_COMPACT_STATE */ && message.data.linkCompactStateBody !== void 0;
};
var isLinkAddMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isLinkAddData(message.data);
};
var isLinkRemoveData = (data) => {
  return data.type === 6 /* LINK_REMOVE */ && typeof data.linkBody !== "undefined";
};
var isLinkRemoveMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isLinkRemoveData(message.data);
};
var isReactionAddData = (data) => {
  return data.type === 3 /* REACTION_ADD */ && typeof data.reactionBody !== "undefined";
};
var isReactionAddMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isReactionAddData(message.data);
};
var isReactionRemoveData = (data) => {
  return data.type === 4 /* REACTION_REMOVE */ && typeof data.reactionBody !== "undefined";
};
var isReactionRemoveMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isReactionRemoveData(message.data);
};
var isVerificationAddAddressData = (data) => {
  return data.type === 7 /* VERIFICATION_ADD_ETH_ADDRESS */ && typeof data.verificationAddAddressBody !== "undefined" && (data.verificationAddAddressBody.protocol === 0 /* ETHEREUM */ || data.verificationAddAddressBody.protocol === 1 /* SOLANA */);
};
var isVerificationAddAddressMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isVerificationAddAddressData(message.data);
};
var isVerificationRemoveData = (data) => {
  return data.type === 8 /* VERIFICATION_REMOVE */ && typeof data.verificationRemoveBody !== "undefined" && (data.verificationRemoveBody.protocol === 0 /* ETHEREUM */ || data.verificationRemoveBody.protocol === 1 /* SOLANA */);
};
var isVerificationRemoveMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isVerificationRemoveData(message.data);
};
var isUserDataAddData = (data) => {
  return data.type === 11 /* USER_DATA_ADD */ && typeof data.userDataBody !== "undefined";
};
var isUserDataAddMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isUserDataAddData(message.data);
};
var isUsernameProofData = (data) => {
  return data.type === 12 /* USERNAME_PROOF */ && typeof data.usernameProofBody !== "undefined";
};
var isUsernameProofMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isUsernameProofData(message.data);
};
var isFrameActionData = (data) => {
  return data.type === 13 /* FRAME_ACTION */ && typeof data.frameActionBody !== "undefined";
};
var isFrameActionMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isFrameActionData(message.data);
};
var isSignerOnChainEvent = (event) => {
  return event.type === 1 /* EVENT_TYPE_SIGNER */ && typeof event.signerEventBody !== "undefined";
};
var isSignerMigratedOnChainEvent = (event) => {
  return event.type === 2 /* EVENT_TYPE_SIGNER_MIGRATED */ && typeof event.signerMigratedEventBody !== "undefined";
};
var isIdRegisterOnChainEvent = (event) => {
  return event.type === 3 /* EVENT_TYPE_ID_REGISTER */ && typeof event.idRegisterEventBody !== "undefined";
};
var isStorageRentOnChainEvent = (event) => {
  return event.type === 4 /* EVENT_TYPE_STORAGE_RENT */ && typeof event.storageRentEventBody !== "undefined";
};
var isMergeMessageHubEvent = (event) => {
  return event.type === 1 /* MERGE_MESSAGE */ && typeof event.mergeMessageBody !== "undefined" && typeof event.mergeMessageBody.message !== "undefined";
};
var isRevokeMessageHubEvent = (event) => {
  return event.type === 3 /* REVOKE_MESSAGE */ && typeof event.revokeMessageBody !== "undefined" && typeof event.revokeMessageBody.message !== "undefined";
};
var isPruneMessageHubEvent = (event) => {
  return event.type === 2 /* PRUNE_MESSAGE */ && typeof event.pruneMessageBody !== "undefined" && typeof event.pruneMessageBody.message !== "undefined";
};
var isMergeOnChainHubEvent = (event) => {
  return event.type === 9 /* MERGE_ON_CHAIN_EVENT */ && typeof event.mergeOnChainEventBody !== "undefined" && typeof event.mergeOnChainEventBody.onChainEvent !== "undefined";
};
var isMergeUsernameProofHubEvent = (event) => {
  return event.type === 6 /* MERGE_USERNAME_PROOF */ && typeof event.mergeUsernameProofBody !== "undefined" && (typeof event.mergeUsernameProofBody.usernameProof !== "undefined" || typeof event.mergeUsernameProofBody.deletedUsernameProof !== "undefined");
};

// src/protobufs/types.ts
init_esm_shims();

// src/builders.ts
init_esm_shims();
import { blake3 as blake32 } from "@noble/hashes/blake3";
import { err as err5, ok as ok5 } from "neverthrow";

// src/time.ts
init_esm_shims();
import { err, ok } from "neverthrow";

// src/errors.ts
init_esm_shims();
var isHubError = (e) => {
  return typeof e.errCode !== "undefined";
};
var HubError = class extends Error {
  /**
   * @param errCode - the HubError code for this message
   * @param context - a message, another Error, or a HubErrorOpts
   */
  constructor(errCode, context) {
    var _a;
    let parsedContext;
    if (typeof context === "string") {
      parsedContext = { message: context };
    } else if (context instanceof Error) {
      parsedContext = { cause: context, message: context.message };
    } else {
      parsedContext = context;
    }
    if (!parsedContext.message) {
      parsedContext.message = ((_a = parsedContext.cause) == null ? void 0 : _a.message) || "";
    }
    super(parsedContext.message, { cause: parsedContext.cause });
    /* Hub classification of error types */
    __publicField(this, "errCode");
    /* Indicates if error message can be presented to the user */
    __publicField(this, "presentable", false);
    this.name = "HubError";
    this.errCode = errCode;
  }
};

// src/time.ts
var FARCASTER_EPOCH = 16094592e5;
var getFarcasterTime = () => {
  return toFarcasterTime(Date.now());
};
var toFarcasterTime = (time) => {
  if (time < FARCASTER_EPOCH) {
    return err(new HubError("bad_request.invalid_param", "time must be after Farcaster epoch (01/01/2022)"));
  }
  const secondsSinceEpoch = Math.round((time - FARCASTER_EPOCH) / 1e3);
  if (secondsSinceEpoch > 2 ** 32 - 1) {
    return err(new HubError("bad_request.invalid_param", "time too far in future"));
  }
  return ok(secondsSinceEpoch);
};
var fromFarcasterTime = (time) => {
  return ok(time * 1e3 + FARCASTER_EPOCH);
};
var SEQUENCE_BITS = 12;
var extractEventTimestamp = (eventId) => {
  const binaryEventId = eventId.toString(2);
  const binaryTimestamp = binaryEventId.slice(0, binaryEventId.length - SEQUENCE_BITS);
  return parseInt(binaryTimestamp, 2) + FARCASTER_EPOCH;
};
var makeEventId = (timestamp, seq = 0) => {
  const binaryTimestamp = (timestamp - FARCASTER_EPOCH).toString(2);
  let binarySeq = seq.toString(2);
  if (binarySeq.length) {
    while (binarySeq.length < SEQUENCE_BITS) {
      binarySeq = `0${binarySeq}`;
    }
  }
  return parseInt(binaryTimestamp + binarySeq, 2);
};

// src/validations.ts
var validations_exports = {};
__export(validations_exports, {
  ALLOWED_CLOCK_SKEW_SECONDS: () => ALLOWED_CLOCK_SKEW_SECONDS,
  EMBEDS_V1_CUTOFF: () => EMBEDS_V1_CUTOFF,
  FNAME_REGEX: () => FNAME_REGEX,
  GITHUB_REGEX: () => GITHUB_REGEX,
  HEX_REGEX: () => HEX_REGEX,
  TWITTER_REGEX: () => TWITTER_REGEX,
  USERNAME_MAX_LENGTH: () => USERNAME_MAX_LENGTH,
  createMessageHash: () => createMessageHash,
  signMessageHash: () => signMessageHash2,
  validateCastAddBody: () => validateCastAddBody,
  validateCastId: () => validateCastId,
  validateCastRemoveBody: () => validateCastRemoveBody,
  validateEd25519PublicKey: () => validateEd25519PublicKey,
  validateEmbed: () => validateEmbed,
  validateEnsName: () => validateEnsName,
  validateEthAddress: () => validateEthAddress,
  validateEthBlockHash: () => validateEthBlockHash,
  validateFarcasterTime: () => validateFarcasterTime,
  validateFid: () => validateFid,
  validateFname: () => validateFname,
  validateFrameActionBody: () => validateFrameActionBody,
  validateGithubUsername: () => validateGithubUsername,
  validateLinkBody: () => validateLinkBody,
  validateLinkCompactStateBody: () => validateLinkCompactStateBody,
  validateLinkType: () => validateLinkType,
  validateMessage: () => validateMessage,
  validateMessageData: () => validateMessageData,
  validateMessageHash: () => validateMessageHash,
  validateMessageType: () => validateMessageType,
  validateNetwork: () => validateNetwork,
  validateParent: () => validateParent,
  validateReactionBody: () => validateReactionBody,
  validateReactionType: () => validateReactionType,
  validateSolAddress: () => validateSolAddress,
  validateSolBlockHash: () => validateSolBlockHash,
  validateTarget: () => validateTarget,
  validateTwitterUsername: () => validateTwitterUsername,
  validateUrl: () => validateUrl,
  validateUserDataAddBody: () => validateUserDataAddBody,
  validateUserDataType: () => validateUserDataType,
  validateUserLocation: () => validateUserLocation,
  validateUsernameProofBody: () => validateUsernameProofBody,
  validateVerificationAddAddressBody: () => validateVerificationAddAddressBody,
  validateVerificationAddEthAddressBody: () => validateVerificationAddEthAddressBody,
  validateVerificationAddEthAddressSignature: () => validateVerificationAddEthAddressSignature,
  validateVerificationAddSolAddressBody: () => validateVerificationAddSolAddressBody,
  validateVerificationAddSolAddressSignature: () => validateVerificationAddSolAddressSignature,
  validateVerificationRemoveBody: () => validateVerificationRemoveBody,
  verifySignedMessageHash: () => verifySignedMessageHash
});
init_esm_shims();
import { blake3 } from "@noble/hashes/blake3";
import { err as err4, ok as ok4, Result as Result3 } from "neverthrow";

// src/bytes.ts
init_esm_shims();
import { err as err2, ok as ok2, Result } from "neverthrow";
import { bytesToHex, hexToBytes } from "viem";
import base58 from "bs58";
var bytesCompare = (a, b) => {
  const len = Math.min(a.length, b.length);
  for (let i = 0; i < len; i++) {
    if (a[i] < b[i]) {
      return -1;
    } else if (a[i] > b[i]) {
      return 1;
    }
  }
  if (a.length < b.length) {
    return -1;
  } else if (a.length > b.length) {
    return 1;
  }
  return 0;
};
var bytesIncrement = (inputBytes) => {
  const bytes = new Uint8Array(inputBytes);
  let i = bytes.length - 1;
  while (i >= 0) {
    if (bytes[i] < 255) {
      bytes[i] = bytes[i] + 1;
      return ok2(bytes);
    } else {
      bytes[i] = 0;
    }
    i = i - 1;
  }
  return ok2(new Uint8Array([1, ...bytes]));
};
var bytesDecrement = (inputBytes) => {
  const bytes = new Uint8Array(inputBytes);
  let i = bytes.length - 1;
  while (i >= 0) {
    if (bytes[i] > 0) {
      bytes[i] = bytes[i] - 1;
      return ok2(bytes);
    } else {
      if (i === 0) {
        return err2(new HubError("bad_request.invalid_param", "Cannot decrement zero"));
      }
      bytes[i] = 255;
    }
    i = i - 1;
  }
  return ok2(bytes);
};
var bytesToHexString = (bytes) => {
  return Result.fromThrowable(
    (bytes2) => bytesToHex(bytes2),
    (e) => new HubError("unknown", e)
  )(bytes);
};
var hexStringToBytes = (hex) => {
  return Result.fromThrowable(
    (hex2) => hexToBytes(hex2.startsWith("0x") ? hex2 : `0x${hex2}`),
    (e) => new HubError("unknown", e)
  )(hex);
};
var bytesToUtf8String = (bytes) => {
  const decoder = new TextDecoder(void 0, { fatal: true });
  return ok2(decoder.decode(bytes));
};
var encoder = new TextEncoder();
var utf8StringToBytes = (utf8) => {
  return ok2(encoder.encode(utf8));
};
var base58ToBytes = (bs58) => {
  return Result.fromThrowable(
    (str) => base58.decode(str),
    (e) => new HubError("unknown", e)
  )(bs58);
};
var bytesToBase58 = (bytes) => {
  return Result.fromThrowable(
    (b) => base58.encode(b),
    (e) => new HubError("unknown", e)
  )(bytes);
};
var bigIntToBytes = (value) => {
  let hexValue = value.toString(16);
  hexValue = hexValue.length % 2 === 0 ? hexValue : `0${hexValue}`;
  return hexStringToBytes(hexValue);
};
var bytesToBigInt = (bytes) => {
  return bytesToHexString(bytes).map((hexString) => BigInt(hexString));
};
var bytesStartsWith = (haystack, needle) => {
  if (needle.length > haystack.length) {
    return false;
  }
  for (let i = 0; i < needle.length; i++) {
    if (haystack[i] !== needle[i]) {
      return false;
    }
  }
  return true;
};

// src/crypto/index.ts
init_esm_shims();

// src/crypto/ed25519.ts
var ed25519_exports = {};
__export(ed25519_exports, {
  getPublicKey: () => getPublicKey,
  signMessageHash: () => signMessageHash,
  verifyMessageHashSignature: () => verifyMessageHashSignature
});
init_esm_shims();
import { ed25519 } from "@noble/curves/ed25519";
import { Result as Result2 } from "neverthrow";
var safeGetPublicKey = Result2.fromThrowable(ed25519.getPublicKey, (err10) => new HubError("bad_request", err10));
var safeSign = Result2.fromThrowable(ed25519.sign, (err10) => new HubError("bad_request", err10));
var safeVerify = Result2.fromThrowable(ed25519.verify, (err10) => new HubError("bad_request", err10));
var getPublicKey = async (privateKey) => {
  return safeGetPublicKey(privateKey);
};
var signMessageHash = async (hash, privateKey) => {
  return safeSign(hash, privateKey);
};
var verifyMessageHashSignature = async (signature, hash, publicKey) => {
  return safeVerify(signature, hash, publicKey);
};

// src/crypto/eip712.ts
var eip712_exports = {};
__export(eip712_exports, {
  EIP_712_FARCASTER_DOMAIN: () => EIP_712_FARCASTER_DOMAIN,
  EIP_712_FARCASTER_MESSAGE_DATA: () => EIP_712_FARCASTER_MESSAGE_DATA,
  EIP_712_FARCASTER_VERIFICATION_CLAIM: () => EIP_712_FARCASTER_VERIFICATION_CLAIM,
  EIP_712_FARCASTER_VERIFICATION_CLAIM_CHAIN_IDS: () => EIP_712_FARCASTER_VERIFICATION_CLAIM_CHAIN_IDS,
  EIP_712_USERNAME_DOMAIN: () => EIP_712_USERNAME_DOMAIN,
  EIP_712_USERNAME_PROOF: () => EIP_712_USERNAME_PROOF,
  MESSAGE_DATA_EIP_712_TYPES: () => MESSAGE_DATA_EIP_712_TYPES,
  USERNAME_PROOF_EIP_712_TYPES: () => USERNAME_PROOF_EIP_712_TYPES,
  verifyMessageHashSignature: () => verifyMessageHashSignature2,
  verifyUserNameProofClaim: () => verifyUserNameProofClaim,
  verifyVerificationClaimContractSignature: () => verifyVerificationClaimContractSignature,
  verifyVerificationClaimEOASignature: () => verifyVerificationClaimEOASignature,
  verifyVerificationEthAddressClaimSignature: () => verifyVerificationEthAddressClaimSignature
});
init_esm_shims();
import { bytesToHex as bytesToHex2, verifyTypedData } from "viem";
import { ResultAsync } from "neverthrow";

// src/eth/clients.ts
var clients_exports = {};
__export(clients_exports, {
  defaultL1PublicClient: () => defaultL1PublicClient,
  defaultL1PublicTestClient: () => defaultL1PublicTestClient,
  defaultL2PublicClient: () => defaultL2PublicClient,
  defaultL2PublicTestClient: () => defaultL2PublicTestClient,
  defaultPublicClients: () => defaultPublicClients
});
init_esm_shims();
import { createPublicClient, http } from "viem";
import { mainnet, goerli, optimism, optimismGoerli } from "viem/chains";
var defaultL1PublicClient = createPublicClient({
  chain: mainnet,
  transport: http()
});
var defaultL2PublicClient = createPublicClient({
  chain: optimism,
  transport: http()
});
var defaultL1PublicTestClient = createPublicClient({
  chain: goerli,
  transport: http()
});
var defaultL2PublicTestClient = createPublicClient({
  chain: optimismGoerli,
  transport: http()
});
var defaultPublicClients = {
  [mainnet.id]: defaultL1PublicClient,
  [optimism.id]: defaultL2PublicClient,
  [goerli.id]: defaultL1PublicTestClient,
  [optimismGoerli.id]: defaultL2PublicTestClient
};

// src/eth/chains.ts
var chains_exports = {};
__export(chains_exports, {
  CHAIN_IDS: () => CHAIN_IDS
});
init_esm_shims();
import { mainnet as mainnet2, goerli as goerli2, optimism as optimism2, optimismGoerli as optimismGoerli2 } from "viem/chains";
var CHAIN_IDS = [mainnet2.id, goerli2.id, optimism2.id, optimismGoerli2.id];

// src/crypto/eip712.ts
var EIP_712_FARCASTER_DOMAIN = {
  name: "Farcaster Verify Ethereum Address",
  version: "2.0.0",
  // fixed salt to minimize collisions
  salt: "0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558"
};
var EIP_712_FARCASTER_VERIFICATION_CLAIM = [
  {
    name: "fid",
    type: "uint256"
  },
  {
    name: "address",
    type: "address"
  },
  {
    name: "blockHash",
    type: "bytes32"
  },
  {
    name: "network",
    type: "uint8"
  }
];
var EIP_712_FARCASTER_VERIFICATION_CLAIM_CHAIN_IDS = [...CHAIN_IDS, 0];
var EIP_712_FARCASTER_MESSAGE_DATA = [
  {
    name: "hash",
    type: "bytes"
  }
];
var EIP_712_USERNAME_DOMAIN = {
  name: "Farcaster name verification",
  version: "1",
  chainId: 1,
  verifyingContract: "0xe3be01d99baa8db9905b33a3ca391238234b79d1"
  // name registry contract, will be the farcaster ENS CCIP contract later
};
var EIP_712_USERNAME_PROOF = [
  { name: "name", type: "string" },
  { name: "timestamp", type: "uint256" },
  { name: "owner", type: "address" }
];
var USERNAME_PROOF_EIP_712_TYPES = {
  domain: EIP_712_USERNAME_DOMAIN,
  types: { UserNameProof: EIP_712_USERNAME_PROOF }
};
var MESSAGE_DATA_EIP_712_TYPES = {
  domain: EIP_712_FARCASTER_DOMAIN,
  types: { MessageData: EIP_712_FARCASTER_MESSAGE_DATA }
};
var verifyVerificationClaimEOASignature = async (claim, signature, address, chainId) => {
  if (chainId !== 0) {
    return ResultAsync.fromPromise(
      Promise.reject(),
      () => new HubError("bad_request.invalid_param", "Invalid chain ID")
    );
  }
  return ResultAsync.fromPromise(
    verifyTypedData({
      address: bytesToHex2(address),
      domain: EIP_712_FARCASTER_DOMAIN,
      types: { VerificationClaim: EIP_712_FARCASTER_VERIFICATION_CLAIM },
      primaryType: "VerificationClaim",
      message: claim,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
};
var verifyVerificationClaimContractSignature = async (claim, signature, address, chainId, publicClients = defaultPublicClients) => {
  const client = publicClients[chainId];
  if (!client) {
    return ResultAsync.fromPromise(
      Promise.reject(),
      () => new HubError("bad_request.invalid_param", `RPC client not provided for chainId ${chainId}`)
    );
  }
  const valid = await ResultAsync.fromPromise(
    client.verifyTypedData({
      address: bytesToHex2(address),
      domain: { ...EIP_712_FARCASTER_DOMAIN, chainId },
      types: { VerificationClaim: EIP_712_FARCASTER_VERIFICATION_CLAIM },
      primaryType: "VerificationClaim",
      message: claim,
      signature
    }),
    (e) => new HubError("unavailable.network_failure", e)
  );
  return valid;
};
var verifyVerificationEthAddressClaimSignature = async (claim, signature, address, verificationType = 0, chainId = 0, publicClients = defaultPublicClients) => {
  if (!EIP_712_FARCASTER_VERIFICATION_CLAIM_CHAIN_IDS.includes(chainId)) {
    return ResultAsync.fromPromise(
      Promise.reject(),
      () => new HubError("bad_request.invalid_param", "Invalid chain ID")
    );
  }
  if (verificationType === 0) {
    return verifyVerificationClaimEOASignature(claim, signature, address, chainId);
  } else if (verificationType === 1) {
    return verifyVerificationClaimContractSignature(claim, signature, address, chainId, publicClients);
  } else {
    return ResultAsync.fromPromise(
      Promise.reject(),
      () => new HubError("bad_request.invalid_param", "Invalid verification type")
    );
  }
};
var verifyUserNameProofClaim = async (nameProof, signature, address) => {
  const valid = await ResultAsync.fromPromise(
    verifyTypedData({
      address: bytesToHex2(address),
      domain: EIP_712_USERNAME_DOMAIN,
      types: { UserNameProof: EIP_712_USERNAME_PROOF },
      primaryType: "UserNameProof",
      message: nameProof,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};
var verifyMessageHashSignature2 = async (hash, signature, address) => {
  const valid = await ResultAsync.fromPromise(
    verifyTypedData({
      address: bytesToHex2(address),
      domain: EIP_712_FARCASTER_DOMAIN,
      types: { MessageData: EIP_712_FARCASTER_MESSAGE_DATA },
      primaryType: "MessageData",
      message: { hash: bytesToHex2(hash) },
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/verifications.ts
init_esm_shims();
import { err as err3, ok as ok3 } from "neverthrow";
var makeVerificationAddressClaim = (fid, address, network, blockHash, protocol) => {
  switch (protocol) {
    case 0 /* ETHEREUM */: {
      const ethAddressHex = validateEthAddress(address).andThen(
        (validatedEthAddress) => bytesToHexString(validatedEthAddress)
      );
      if (ethAddressHex.isErr()) {
        return err3(ethAddressHex.error);
      }
      const blockHashHex = validateEthBlockHash(blockHash).andThen(
        (validatedBlockHash) => bytesToHexString(validatedBlockHash)
      );
      if (blockHashHex.isErr()) {
        return err3(blockHashHex.error);
      }
      return ok3({
        fid: BigInt(fid),
        address: ethAddressHex.value,
        network,
        blockHash: blockHashHex.value,
        protocol: 0 /* ETHEREUM */
      });
    }
    case 1 /* SOLANA */: {
      const solAddress = validateSolAddress(address).andThen(
        (validatedSolAddress) => bytesToBase58(validatedSolAddress)
      );
      if (solAddress.isErr()) {
        return err3(solAddress.error);
      }
      const blockHashSol = validateSolBlockHash(blockHash).andThen(
        (validatedBlockHash) => bytesToBase58(validatedBlockHash)
      );
      if (blockHashSol.isErr()) {
        return err3(blockHashSol.error);
      }
      return ok3({
        fid: BigInt(fid),
        network,
        address: solAddress.value,
        blockHash: blockHashSol.value,
        protocol: 1 /* SOLANA */
      });
    }
    default:
      return err3(new HubError("bad_request.invalid_param", `Invalid protocol: ${protocol}`));
  }
};
var recreateSolanaClaimMessage = (claim, pubkey) => {
  const messageContent = `fid: ${claim.fid} address: ${claim.address} network: ${claim.network} blockHash: ${claim.blockHash} protocol: ${claim.protocol}`;
  return Buffer.from(utf8StringToBytes(messageContent)._unsafeUnwrap());
};

// src/validations.ts
import { normalize } from "viem/ens";
var ALLOWED_CLOCK_SKEW_SECONDS = 10 * 60;
var FNAME_REGEX = /^[a-z0-9][a-z0-9-]{0,15}$/;
var HEX_REGEX = /^(0x)?[0-9A-Fa-f]+$/;
var TWITTER_REGEX = /^[a-z0-9_]{0,15}$/;
var GITHUB_REGEX = /^[a-z\d](?:[a-z\d]|-(?!-)){0,38}$/i;
var USERNAME_MAX_LENGTH = 20;
var EMBEDS_V1_CUTOFF = 73612800;
var pureJSValidationMethods = {
  ed25519_verify: async (s, m, p) => (await ed25519_exports.verifyMessageHashSignature(s, m, p)).unwrapOr(false),
  ed25519_signMessageHash: async (h, s) => (await ed25519_exports.signMessageHash(h, s)).unwrapOr(new Uint8Array([])),
  blake3_20: (message) => blake3(message, { dkLen: 20 })
};
var createMessageHash = async (message, hashScheme, validationMethods = pureJSValidationMethods) => {
  if (!message || message.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  if (hashScheme !== 1 /* BLAKE3 */) {
    return err4(new HubError("bad_request.validation_failure", "unsupported hash scheme"));
  }
  return ok4(validationMethods.blake3_20(message));
};
var signMessageHash2 = async (hash, signingKey, validationMethods = pureJSValidationMethods) => {
  if (!hash || hash.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  if (!signingKey || signingKey.length !== 64) {
    return err4(new HubError("bad_request.validation_failure", "signingKey is invalid"));
  }
  return ok4(await validationMethods.ed25519_signMessageHash(hash, signingKey));
};
var verifySignedMessageHash = async (hash, signature, signer, validationMethods = pureJSValidationMethods) => {
  if (!hash || hash.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  if (!signature || signature.length !== 64) {
    return err4(new HubError("bad_request.validation_failure", "signature is invalid"));
  }
  if (!signer || signer.length !== 32) {
    return err4(new HubError("bad_request.validation_failure", "signer is invalid"));
  }
  return ok4(await validationMethods.ed25519_verify(signature, hash, signer));
};
var validateMessageHash = (hash) => {
  if (!hash || hash.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  if (hash.length !== 20) {
    return err4(new HubError("bad_request.validation_failure", "hash must be 20 bytes"));
  }
  return ok4(hash);
};
var validateNumber = (value) => {
  const number = parseFloat(value);
  if (Number.isNaN(number)) {
    return err4(void 0);
  }
  return ok4(number);
};
var validateLatitude = (value) => {
  const number = validateNumber(value);
  if (number.isErr()) {
    return err4(new HubError("bad_request.validation_failure", "Latitude is not a valid number"));
  }
  if (number.value < -90 || number.value > 90) {
    return err4(new HubError("bad_request.validation_failure", "Latitude value outside valid range"));
  }
  return ok4(value);
};
var validateLongitude = (value) => {
  const number = validateNumber(value);
  if (number.isErr()) {
    return err4(new HubError("bad_request.validation_failure", "Longitude is not a valid number"));
  }
  if (number.value < -180 || number.value > 180) {
    return err4(new HubError("bad_request.validation_failure", "Longitude value outside valid range"));
  }
  return ok4(value);
};
var validateUserLocation = (location) => {
  if (location === "") {
    return ok4(location);
  }
  const result = location.match(/^geo:(-?\d{1,2}\.\d{2}),(-?\d{1,3}\.\d{2})$/);
  if (result === null || result[0] !== location) {
    return err4(new HubError("bad_request.validation_failure", "Invalid location string"));
  }
  if (result[1] === void 0) {
    return err4(new HubError("bad_request.validation_failure", "Location missing latitude"));
  }
  const latitude = validateLatitude(result[1]);
  if (latitude.isErr()) {
    return err4(latitude.error);
  }
  if (result[2] === void 0) {
    return err4(new HubError("bad_request.validation_failure", "Location missing longitude"));
  }
  const longitude = validateLongitude(result[2]);
  if (longitude.isErr()) {
    return err4(longitude.error);
  }
  return ok4(location);
};
var validateCastId = (castId) => {
  if (!castId) {
    return err4(new HubError("bad_request.validation_failure", "castId is missing"));
  }
  return Result3.combineWithAllErrors([validateFid(castId.fid), validateMessageHash(castId.hash)]).map(() => castId).mapErr(
    (errs) => new HubError("bad_request.validation_failure", errs.map((e) => e.message).join(", "))
  );
};
var validateFid = (fid) => {
  if (typeof fid !== "number" || fid === 0) {
    return err4(new HubError("bad_request.validation_failure", "fid is missing"));
  }
  if (fid < 0) {
    return err4(new HubError("bad_request.validation_failure", "fid must be positive"));
  }
  if (!Number.isInteger(fid)) {
    return err4(new HubError("bad_request.validation_failure", "fid must be an integer"));
  }
  return ok4(fid);
};
var validateSolAddress = (address) => {
  if (!address || address.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "solana address is missing"));
  }
  if (address.length !== 32) {
    return err4(new HubError("bad_request.validation_failure", "solana address must be 32 bytes"));
  }
  return ok4(address);
};
var validateSolBlockHash = (blockHash) => {
  if (!blockHash || blockHash.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "blockHash is missing"));
  }
  if (blockHash.length !== 32) {
    return err4(new HubError("bad_request.validation_failure", "blockHash must be 32 bytes"));
  }
  return ok4(blockHash);
};
var validateEthAddress = (address) => {
  if (!address || address.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "Ethereum address is missing"));
  }
  if (address.length !== 20) {
    return err4(new HubError("bad_request.validation_failure", "Ethereum address must be 20 bytes"));
  }
  return ok4(address);
};
var validateEthBlockHash = (blockHash) => {
  if (!blockHash || blockHash.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "blockHash is missing"));
  }
  if (blockHash.length !== 32) {
    return err4(new HubError("bad_request.validation_failure", "blockHash must be 32 bytes"));
  }
  return ok4(blockHash);
};
var validateEd25519PublicKey = (publicKey) => {
  if (!publicKey || publicKey.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "publicKey is missing"));
  }
  if (publicKey.length !== 32) {
    return err4(new HubError("bad_request.validation_failure", "publicKey must be 32 bytes"));
  }
  return ok4(publicKey);
};
var validateFarcasterTime = (farcasterTime) => {
  const unixTime = fromFarcasterTime(farcasterTime);
  if (unixTime.isErr()) {
    return err4(unixTime.error);
  }
  const rtFarcasterTime = toFarcasterTime(unixTime.value);
  if (rtFarcasterTime.isErr()) {
    return err4(rtFarcasterTime.error);
  }
  return ok4(rtFarcasterTime.value);
};
var validateMessage = async (message, validationMethods = pureJSValidationMethods, publicClients = defaultPublicClients) => {
  if (!message.data && !message.dataBytes) {
    return err4(new HubError("bad_request.validation_failure", "data is missing"));
  }
  const data = message.data || MessageData.decode(Buffer.from(message.dataBytes));
  const validData = await validateMessageData(data, publicClients);
  if (validData.isErr()) {
    return err4(validData.error);
  }
  const hash = message.hash;
  if (!hash) {
    return err4(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  let computedHash;
  if (message.dataBytes && message.dataBytes.length > 0) {
    if (message.dataBytes.length > 2048) {
      return err4(new HubError("bad_request.validation_failure", "dataBytes > 2048 bytes"));
    }
    computedHash = validationMethods.blake3_20(message.dataBytes);
  } else {
    computedHash = validationMethods.blake3_20(MessageData.encode(data).finish());
  }
  if (message.hashScheme === 1 /* BLAKE3 */) {
    if (bytesCompare(hash, computedHash) !== 0) {
      return err4(
        new HubError("bad_request.validation_failure", `invalid hash. Expected=${hash}, computed=${computedHash}`)
      );
    }
  } else {
    return err4(new HubError("bad_request.validation_failure", "invalid hashScheme"));
  }
  const signature = message.signature;
  if (!signature) {
    return err4(new HubError("bad_request.validation_failure", "signature is missing"));
  }
  const signer = message.signer;
  if (!signer) {
    return err4(new HubError("bad_request.validation_failure", "signer is missing"));
  }
  if (message.signatureScheme === 1 /* ED25519 */) {
    const signatureIsValid = await validationMethods.ed25519_verify(signature, hash, signer);
    if (!signatureIsValid) {
      return err4(new HubError("bad_request.validation_failure", "invalid signature"));
    }
  } else {
    return err4(new HubError("bad_request.validation_failure", "invalid signatureScheme"));
  }
  return ok4(message);
};
var validateMessageData = async (data, publicClients = defaultPublicClients) => {
  const validFid = validateFid(data.fid);
  if (validFid.isErr()) {
    return err4(validFid.error);
  }
  const farcasterTime = getFarcasterTime();
  if (farcasterTime.isErr()) {
    return err4(farcasterTime.error);
  }
  if (data.timestamp - farcasterTime.value > ALLOWED_CLOCK_SKEW_SECONDS) {
    return err4(new HubError("bad_request.validation_failure", "timestamp more than 10 mins in the future"));
  }
  const validNetwork = validateNetwork(data.network);
  if (validNetwork.isErr()) {
    return err4(validNetwork.error);
  }
  const validType = validateMessageType(data.type);
  if (validType.isErr()) {
    return err4(validType.error);
  }
  const bodySet = Object.keys(data).filter((k) => k.endsWith("Body")).map((k) => data[k] !== void 0 ? 1 : 0).reduce((s, c) => s + c, 0);
  if (bodySet !== 1) {
    return err4(new HubError("bad_request.validation_failure", "only one body can be set"));
  }
  let bodyResult;
  if (validType.value === 1 /* CAST_ADD */ && !!data.castAddBody) {
    const allowEmbedsDeprecated = data.timestamp < EMBEDS_V1_CUTOFF;
    bodyResult = validateCastAddBody(data.castAddBody, allowEmbedsDeprecated);
  } else if (validType.value === 2 /* CAST_REMOVE */ && !!data.castRemoveBody) {
    bodyResult = validateCastRemoveBody(data.castRemoveBody);
  } else if ((validType.value === 3 /* REACTION_ADD */ || validType.value === 4 /* REACTION_REMOVE */) && !!data.reactionBody) {
    bodyResult = validateReactionBody(data.reactionBody);
  } else if (validType.value === 14 /* LINK_COMPACT_STATE */ && !!data.linkCompactStateBody) {
    bodyResult = validateLinkCompactStateBody(data.linkCompactStateBody);
  } else if ((validType.value === 5 /* LINK_ADD */ || validType.value === 6 /* LINK_REMOVE */) && !!data.linkBody) {
    bodyResult = validateLinkBody(data.linkBody);
  } else if (validType.value === 11 /* USER_DATA_ADD */ && !!data.userDataBody) {
    bodyResult = validateUserDataAddBody(data.userDataBody);
  } else if (validType.value === 7 /* VERIFICATION_ADD_ETH_ADDRESS */ && !!data.verificationAddAddressBody) {
    bodyResult = await validateVerificationAddAddressBody(
      data.verificationAddAddressBody,
      validFid.value,
      validNetwork.value,
      publicClients
    );
  } else if (validType.value === 8 /* VERIFICATION_REMOVE */ && !!data.verificationRemoveBody) {
    bodyResult = validateVerificationRemoveBody(data.verificationRemoveBody);
  } else if (validType.value === 12 /* USERNAME_PROOF */ && !!data.usernameProofBody) {
    bodyResult = validateUsernameProofBody(data.usernameProofBody, data);
  } else if (validType.value === 13 /* FRAME_ACTION */ && !!data.frameActionBody) {
    bodyResult = validateFrameActionBody(data.frameActionBody);
  } else {
    return err4(new HubError("bad_request.invalid_param", "bodyType is invalid"));
  }
  if (bodyResult.isErr()) {
    return err4(bodyResult.error);
  }
  return ok4(data);
};
var validateVerificationAddSolAddressSignature = async (body, fid, network) => {
  if (body.claimSignature.length !== 64) {
    return err4(new HubError("bad_request.validation_failure", "claimSignature != 64 bytes"));
  }
  const reconstructedClaim = makeVerificationAddressClaim(fid, body.address, network, body.blockHash, body.protocol);
  if (reconstructedClaim.isErr()) {
    return err4(reconstructedClaim.error);
  }
  const fullMessage = recreateSolanaClaimMessage(
    reconstructedClaim.value,
    body.address
  );
  const verificationResult = await pureJSValidationMethods.ed25519_verify(
    body.claimSignature,
    fullMessage,
    body.address
  );
  if (!verificationResult) {
    return err4(new HubError("bad_request.validation_failure", "invalid claimSignature"));
  }
  return ok4(body.claimSignature);
};
var validateVerificationAddEthAddressSignature = async (body, fid, network, publicClients = defaultPublicClients) => {
  if (body.claimSignature.length > 2048) {
    return err4(new HubError("bad_request.validation_failure", "claimSignature > 2048 bytes"));
  }
  const reconstructedClaim = makeVerificationAddressClaim(
    fid,
    body.address,
    network,
    body.blockHash,
    0 /* ETHEREUM */
  );
  if (reconstructedClaim.isErr()) {
    return err4(reconstructedClaim.error);
  }
  const verificationResult = await eip712_exports.verifyVerificationEthAddressClaimSignature(
    reconstructedClaim.value,
    body.claimSignature,
    body.address,
    body.verificationType,
    body.chainId,
    publicClients
  );
  if (verificationResult.isErr()) {
    return err4(verificationResult.error);
  }
  if (!verificationResult.value) {
    return err4(new HubError("bad_request.validation_failure", "invalid claimSignature"));
  }
  return ok4(body.claimSignature);
};
var validateUrl = (url) => {
  if (typeof url !== "string") {
    return err4(new HubError("bad_request.validation_failure", "url must be a string"));
  }
  const urlBytesResult = utf8StringToBytes(url);
  if (urlBytesResult.isErr()) {
    return err4(new HubError("bad_request.invalid_param", "url must be encodable as utf8"));
  }
  const urlBytes = urlBytesResult.value;
  if (urlBytes.length < 1) {
    return err4(new HubError("bad_request.invalid_param", "url < 1 byte"));
  }
  if (urlBytes.length > 256) {
    return err4(new HubError("bad_request.invalid_param", "url > 256 bytes"));
  }
  return ok4(url);
};
var validateParent = (parent) => {
  if (typeof parent === "string") {
    return validateUrl(parent);
  } else {
    return validateCastId(parent);
  }
};
var validateEmbed = (embed) => {
  if (embed.url !== void 0 && embed.castId !== void 0) {
    return err4(new HubError("bad_request.validation_failure", "cannot use both url and castId"));
  }
  if (embed.url !== void 0) {
    return validateUrl(embed.url).map(() => embed);
  } else if (embed.castId !== void 0) {
    return validateCastId(embed.castId).map(() => embed);
  } else {
    return err4(new HubError("bad_request.validation_failure", "embed must have either url or castId"));
  }
};
var validateCastAddBody = (body, allowEmbedsDeprecated = false) => {
  var _a;
  const text = body.text;
  if (text === void 0 || text === null) {
    return err4(new HubError("bad_request.validation_failure", "text is missing"));
  }
  const textUtf8BytesResult = utf8StringToBytes(text);
  if (textUtf8BytesResult.isErr()) {
    return err4(new HubError("bad_request.invalid_param", "text must be encodable as utf8"));
  }
  const textBytes = textUtf8BytesResult.value;
  if (body.type === 0 /* CAST */ && textBytes.length > 320) {
    return err4(new HubError("bad_request.validation_failure", "text > 320 bytes"));
  }
  if (body.type === 1 /* LONG_CAST */ && textBytes.length > 1024) {
    return err4(new HubError("bad_request.validation_failure", "text > 1024 bytes for long cast"));
  }
  if (body.type === 1 /* LONG_CAST */ && textBytes.length <= 320) {
    return err4(new HubError("bad_request.validation_failure", "text too short for long cast"));
  }
  if (body.type !== 0 /* CAST */ && body.type !== 1 /* LONG_CAST */) {
    return err4(new HubError("bad_request.validation_failure", "invalid cast type"));
  }
  if (body.embeds.length > 2) {
    return err4(new HubError("bad_request.validation_failure", "embeds > 2"));
  }
  if (allowEmbedsDeprecated && body.embedsDeprecated.length > 2) {
    return err4(new HubError("bad_request.validation_failure", "string embeds > 2"));
  }
  if (!allowEmbedsDeprecated && body.embedsDeprecated.length > 0) {
    return err4(new HubError("bad_request.validation_failure", "string embeds have been deprecated"));
  }
  if (body.mentions.length > 10) {
    return err4(new HubError("bad_request.validation_failure", "mentions > 10"));
  }
  if (body.mentions.length !== body.mentionsPositions.length) {
    return err4(new HubError("bad_request.validation_failure", "mentions and mentionsPositions must match"));
  }
  if (body.embeds.length > 0 && body.embedsDeprecated.length > 0) {
    return err4(new HubError("bad_request.validation_failure", "cannot use both embeds and string embeds"));
  }
  if (body.parentUrl !== void 0 && body.parentCastId !== void 0) {
    return err4(new HubError("bad_request.validation_failure", "cannot use both parentUrl and parentCastId"));
  }
  if (body.text.length === 0 && body.embeds.length === 0 && body.embedsDeprecated.length === 0 && body.mentions.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "cast is empty"));
  }
  for (let i = 0; i < body.embeds.length; i++) {
    const embed = body.embeds[i];
    if (embed === void 0) {
      return err4(new HubError("bad_request.validation_failure", "embed is missing"));
    }
    const embedIsValid = validateEmbed(embed);
    if (embedIsValid.isErr()) {
      return err4(embedIsValid.error);
    }
  }
  for (let i = 0; i < body.embedsDeprecated.length; i++) {
    const embed = body.embedsDeprecated[i];
    if (embed === void 0) {
      return err4(new HubError("bad_request.validation_failure", "string embed is missing"));
    }
    const embedIsValid = validateUrl(embed);
    if (embedIsValid.isErr()) {
      return err4(embedIsValid.error);
    }
  }
  for (let i = 0; i < body.mentions.length; i++) {
    const mention = validateFid(body.mentions[i]);
    if (mention.isErr()) {
      return err4(mention.error);
    }
    const position = body.mentionsPositions[i];
    if (typeof position !== "number" || !Number.isInteger(position)) {
      return err4(new HubError("bad_request.validation_failure", "mentionsPositions must be integers"));
    }
    if (position < 0 || position > textBytes.length) {
      return err4(new HubError("bad_request.validation_failure", "mentionsPositions must be a position in text"));
    }
    if (i > 0) {
      const prevPosition = body.mentionsPositions[i - 1];
      if (position < prevPosition) {
        return err4(
          new HubError("bad_request.validation_failure", "mentionsPositions must be sorted in ascending order")
        );
      }
    }
  }
  if (body.parentCastId !== void 0 && body.parentUrl !== void 0) {
    return err4(new HubError("bad_request.validation_failure", "cannot use both parentUrl and parentCastId"));
  }
  const parent = (_a = body.parentCastId) != null ? _a : body.parentUrl;
  if (parent !== void 0) {
    const validParent = validateParent(parent);
    if (validParent.isErr()) {
      return err4(validParent.error);
    }
  }
  return ok4(body);
};
var validateCastRemoveBody = (body) => {
  return validateMessageHash(body.targetHash).map(() => body);
};
var validateLinkType = (type) => {
  const typeBuffer = Buffer.from(type);
  if (type.length === 0 || typeBuffer.length > 8) {
    return err4(new HubError("bad_request.validation_failure", "type must be between 1-8 bytes"));
  }
  return ok4(type);
};
var validateReactionType = (type) => {
  if (!Object.values(ReactionType).includes(type)) {
    return err4(new HubError("bad_request.validation_failure", "invalid reaction type"));
  }
  return ok4(type);
};
var validateTarget = (target) => {
  if (typeof target === "string") {
    return validateUrl(target);
  } else if (typeof target === "number") {
    return validateFid(target);
  } else {
    return validateCastId(target);
  }
};
var validateMessageType = (type) => {
  if (!Object.values(MessageType).includes(type)) {
    return err4(new HubError("bad_request.validation_failure", "invalid message type"));
  }
  return ok4(type);
};
var validateNetwork = (network) => {
  if (!Object.values(FarcasterNetwork).includes(network)) {
    return err4(new HubError("bad_request.validation_failure", "invalid network"));
  }
  return ok4(network);
};
var validateLinkCompactStateBody = (body) => {
  const validatedType = validateLinkType(body.type);
  if (validatedType.isErr()) {
    return err4(validatedType.error);
  }
  const targetFids = body.targetFids;
  if (targetFids === void 0) {
    return err4(new HubError("bad_request.validation_failure", "targets is missing"));
  }
  for (const targetFid of targetFids) {
    const validFid = validateFid(targetFid);
    if (validFid.isErr()) {
      return err4(validFid.error);
    }
  }
  return ok4(body);
};
var validateLinkBody = (body) => {
  const validatedType = validateLinkType(body.type);
  if (validatedType.isErr()) {
    return err4(validatedType.error);
  }
  const target = body.targetFid;
  if (target === void 0) {
    return err4(new HubError("bad_request.validation_failure", "target is missing"));
  }
  return validateTarget(target).map(() => body);
};
var validateReactionBody = (body) => {
  var _a;
  const validatedType = validateReactionType(body.type);
  if (validatedType.isErr()) {
    return err4(validatedType.error);
  }
  if (body.targetCastId !== void 0 && body.targetUrl !== void 0) {
    return err4(new HubError("bad_request.validation_failure", "cannot use both targetUrl and targetCastId"));
  }
  const target = (_a = body.targetCastId) != null ? _a : body.targetUrl;
  if (target === void 0) {
    return err4(new HubError("bad_request.validation_failure", "target is missing"));
  }
  return validateTarget(target).map(() => body);
};
var validateVerificationAddAddressBody = async (body, fid, network, publicClients) => {
  switch (body.protocol) {
    case 0 /* ETHEREUM */:
      return await validateVerificationAddEthAddressBody(body, fid, network, publicClients);
    case 1 /* SOLANA */: {
      return validateVerificationAddSolAddressBody(body, fid, network);
    }
    default:
      return err4(new HubError("bad_request.validation_failure", "invalid verification protocol"));
  }
};
var validateVerificationAddEthAddressBody = async (body, fid, network, publicClients) => {
  const validAddress = validateEthAddress(body.address);
  if (validAddress.isErr()) {
    return err4(validAddress.error);
  }
  const validBlockHash = validateEthBlockHash(body.blockHash);
  if (validBlockHash.isErr()) {
    return err4(validBlockHash.error);
  }
  const validSignature = await validateVerificationAddEthAddressSignature(body, fid, network, publicClients);
  if (validSignature.isErr()) {
    return err4(validSignature.error);
  }
  return ok4(body);
};
var validateVerificationAddSolAddressBody = async (body, fid, network) => {
  if (body.protocol !== 1 /* SOLANA */) {
    return err4(new HubError("bad_request.validation_failure", "invalid verification protocol"));
  }
  if (validateSolAddress(body.address).isErr()) {
    return err4(new HubError("bad_request.validation_failure", "solana address must be 32 bytes"));
  }
  if (validateSolBlockHash(body.blockHash).isErr()) {
    return err4(new HubError("bad_request.validation_failure", "blockHash must be 32 bytes"));
  }
  const isVerified = await validateVerificationAddSolAddressSignature(body, fid, network);
  if (isVerified.isErr()) {
    return err4(isVerified.error);
  }
  return ok4(body);
};
var validateVerificationRemoveBody = (body) => {
  switch (body.protocol) {
    case 0 /* ETHEREUM */:
      return validateEthAddress(body.address).map(() => body);
    case 1 /* SOLANA */:
      return validateSolAddress(body.address).map(() => body);
    default:
      return err4(new HubError("bad_request.validation_failure", "invalid verification protocol"));
  }
};
var validateUsernameProofBody = (body, data) => {
  if (body.type !== 2 /* USERNAME_TYPE_ENS_L1 */) {
    return err4(new HubError("bad_request.validation_failure", `invalid username type: ${body.type}`));
  }
  const validateName = validateEnsName(body.name);
  if (validateName.isErr()) {
    return err4(validateName.error);
  }
  if (body.fid !== data.fid) {
    return err4(
      new HubError("bad_request.validation_failure", "fid in username proof does not match fid in message data")
    );
  }
  const proofFarcasterTimestamp = toFarcasterTime(body.timestamp * 1e3);
  if (proofFarcasterTimestamp.isErr()) {
    return err4(proofFarcasterTimestamp.error);
  }
  if (proofFarcasterTimestamp.value !== data.timestamp) {
    return err4(
      new HubError(
        "bad_request.validation_failure",
        "timestamp in username proof does not match timestamp in message data"
      )
    );
  }
  return ok4(body);
};
var validateFrameActionBody = (body) => {
  if (body.buttonIndex > 5) {
    return err4(new HubError("bad_request.validation_failure", "invalid button index"));
  }
  if (validateBytesAsString(body.url, 1024, true).isErr()) {
    return err4(new HubError("bad_request.validation_failure", "invalid url"));
  }
  if (validateBytesAsString(body.inputText, 256).isErr()) {
    return err4(new HubError("bad_request.validation_failure", "invalid input text"));
  }
  if (validateBytesAsString(body.state, 4096).isErr()) {
    return err4(new HubError("bad_request.validation_failure", "invalid state"));
  }
  if (validateBytesAsString(body.transactionId, 256).isErr()) {
    return err4(new HubError("bad_request.validation_failure", "invalid transaction ID"));
  }
  if (validateBytesAsString(body.address, 64).isErr()) {
    return err4(new HubError("bad_request.validation_failure", "invalid address"));
  }
  if (body.castId !== void 0) {
    const result = validateCastId(body.castId);
    if (result.isErr()) {
      return err4(result.error);
    }
  }
  return ok4(body);
};
var validateBytesAsString = (byteArray, maxLength, required = false) => {
  if (required && byteArray.length === 0) {
    return err4(new HubError("bad_request.validation_failure", "value is required"));
  }
  if (byteArray.length > maxLength) {
    return err4(new HubError("bad_request.validation_failure", "value is too long"));
  }
  return ok4(byteArray);
};
var validateUserDataType = (type) => {
  if (!Object.values(UserDataType).includes(type) || type === 0 /* NONE */ || type === 0 /* NONE */) {
    return err4(new HubError("bad_request.validation_failure", "invalid user data type"));
  }
  return ok4(type);
};
var validateUserDataAddBody = (body) => {
  const { type, value } = body;
  const textUtf8BytesResult = utf8StringToBytes(value);
  if (textUtf8BytesResult.isErr()) {
    return err4(new HubError("bad_request.invalid_param", "value cannot be encoded as utf8"));
  }
  const valueBytes = textUtf8BytesResult.value;
  switch (type) {
    case 1 /* PFP */:
      if (valueBytes.length > 256) {
        return err4(new HubError("bad_request.validation_failure", "pfp value > 256"));
      }
      break;
    case 2 /* DISPLAY */:
      if (valueBytes.length > 32) {
        return err4(new HubError("bad_request.validation_failure", "display value > 32"));
      }
      break;
    case 3 /* BIO */:
      if (valueBytes.length > 256) {
        return err4(new HubError("bad_request.validation_failure", "bio value > 256"));
      }
      break;
    case 5 /* URL */:
      if (valueBytes.length > 256) {
        return err4(new HubError("bad_request.validation_failure", "url value > 256"));
      }
      break;
    case 6 /* USERNAME */: {
      if (value !== "") {
        const validatedFname = validateFname(value);
        const validatedEnsName = validateEnsName(value);
        if (validatedFname.isErr() && validatedEnsName.isErr()) {
          return err4(validatedFname.error);
        }
      }
      break;
    }
    case 7 /* LOCATION */: {
      const validatedUserLocation = validateUserLocation(value);
      if (validatedUserLocation.isErr()) {
        return err4(validatedUserLocation.error);
      }
      break;
    }
    case 8 /* TWITTER */: {
      const validatedTwitterUsername = validateTwitterUsername(value);
      if (validatedTwitterUsername.isErr()) {
        return err4(validatedTwitterUsername.error);
      }
      break;
    }
    case 9 /* GITHUB */: {
      const validatedGithubUsername = validateGithubUsername(value);
      if (validatedGithubUsername.isErr()) {
        return err4(validatedGithubUsername.error);
      }
      break;
    }
    default:
      return err4(new HubError("bad_request.validation_failure", "invalid user data type"));
  }
  return ok4(body);
};
var validateFname = (fnameP) => {
  if (fnameP === void 0 || fnameP === null || fnameP === "") {
    return err4(new HubError("bad_request.validation_failure", "fname is missing"));
  }
  let fname;
  if (fnameP instanceof Uint8Array) {
    const fromBytes2 = bytesToUtf8String(fnameP);
    if (fromBytes2.isErr()) {
      return err4(fromBytes2.error);
    }
    fname = fromBytes2.value;
  } else {
    fname = fnameP;
  }
  if (fname === void 0 || fname === null || fname === "") {
    return err4(new HubError("bad_request.validation_failure", "fname is missing"));
  }
  if (fname.length > 16) {
    return err4(new HubError("bad_request.validation_failure", `fname "${fname}" > 16 characters`));
  }
  const hasValidChars = FNAME_REGEX.test(fname);
  if (hasValidChars === false) {
    return err4(new HubError("bad_request.validation_failure", `fname "${fname}" doesn't match ${FNAME_REGEX}`));
  }
  return ok4(fnameP);
};
var validateEnsName = (ensNameP) => {
  if (ensNameP === void 0 || ensNameP === null || ensNameP === "") {
    return err4(new HubError("bad_request.validation_failure", "ensName is missing"));
  }
  let ensName;
  if (ensNameP instanceof Uint8Array) {
    const fromBytes2 = bytesToUtf8String(ensNameP);
    if (fromBytes2.isErr()) {
      return err4(fromBytes2.error);
    }
    ensName = fromBytes2.value;
  } else {
    ensName = ensNameP;
  }
  if (ensName === void 0 || ensName === null || ensName === "") {
    return err4(new HubError("bad_request.validation_failure", "ensName is missing"));
  }
  try {
    normalize(ensName);
  } catch (e) {
    return err4(new HubError("bad_request.validation_failure", `ensName "${ensName}" is not a valid ENS name`));
  }
  if (!ensName.endsWith(".eth")) {
    return err4(new HubError("bad_request.validation_failure", `ensName "${ensName}" doesn't end with .eth`));
  }
  const nameParts = ensName.split(".");
  if (nameParts[0] === void 0 || nameParts.length !== 2) {
    return err4(new HubError("bad_request.validation_failure", `ensName "${ensName}" unsupported subdomain`));
  }
  if (ensName.length > USERNAME_MAX_LENGTH) {
    return err4(new HubError("bad_request.validation_failure", `ensName "${ensName}" > 20 characters`));
  }
  const hasValidChars = FNAME_REGEX.test(nameParts[0]);
  if (!hasValidChars) {
    return err4(new HubError("bad_request.validation_failure", `ensName "${ensName}" doesn't match ${FNAME_REGEX}`));
  }
  return ok4(ensNameP);
};
var validateTwitterUsername = (username) => {
  if (username === void 0 || username === null || username === "") {
    return err4(new HubError("bad_request.validation_failure", "username is missing"));
  }
  let twitterUsername;
  if (username instanceof Uint8Array) {
    const fromBytes2 = bytesToUtf8String(username);
    if (fromBytes2.isErr()) {
      return err4(fromBytes2.error);
    }
    twitterUsername = fromBytes2.value;
  } else {
    twitterUsername = username;
  }
  if (twitterUsername === void 0 || twitterUsername === null || twitterUsername === "") {
    return err4(new HubError("bad_request.validation_failure", "username is missing"));
  }
  if (twitterUsername.length > 15) {
    return err4(new HubError("bad_request.validation_failure", `username "${twitterUsername}" > 15 characters`));
  }
  const hasValidChars = TWITTER_REGEX.test(twitterUsername);
  if (hasValidChars === false) {
    return err4(
      new HubError("bad_request.validation_failure", `username "${twitterUsername}" doesn't match ${TWITTER_REGEX}`)
    );
  }
  return ok4(username);
};
var validateGithubUsername = (username) => {
  if (username === void 0 || username === null || username === "") {
    return err4(new HubError("bad_request.validation_failure", "username is missing"));
  }
  let githubUsername;
  if (username instanceof Uint8Array) {
    const fromBytes2 = bytesToUtf8String(username);
    if (fromBytes2.isErr()) {
      return err4(fromBytes2.error);
    }
    githubUsername = fromBytes2.value;
  } else {
    githubUsername = username;
  }
  if (githubUsername === void 0 || githubUsername === null || githubUsername === "") {
    return err4(new HubError("bad_request.validation_failure", "username is missing"));
  }
  if (githubUsername.length > 38) {
    return err4(new HubError("bad_request.validation_failure", `username "${githubUsername}" > 38 characters`));
  }
  const hasValidChars = GITHUB_REGEX.test(githubUsername);
  if (hasValidChars === false) {
    return err4(
      new HubError("bad_request.validation_failure", `username "${githubUsername}" doesn't match ${GITHUB_REGEX}`)
    );
  }
  return ok4(username);
};

// src/builders.ts
var makeMessageData = async (bodyOptions, messageType, dataOptions, publicClients = defaultPublicClients) => {
  if (!dataOptions.timestamp) {
    getFarcasterTime().map((timestamp) => {
      dataOptions.timestamp = timestamp;
    });
  }
  const data = MessageData.create({
    ...bodyOptions,
    type: messageType,
    ...dataOptions
  });
  return validateMessageData(data, publicClients);
};
var makeMessage = async (messageData, signer) => {
  const dataBytes = MessageData.encode(messageData).finish();
  const hash = blake32(dataBytes, { dkLen: 20 });
  const signature = await signer.signMessageHash(hash);
  if (signature.isErr())
    return err5(signature.error);
  const signerKey = await signer.getSignerKey();
  if (signerKey.isErr())
    return err5(signerKey.error);
  const message = Message.create({
    // data: messageData,
    dataBytes,
    // Messages for snapchain must use dataBytes because of serialization differences between js and rust
    hash,
    hashScheme: 1 /* BLAKE3 */,
    signature: signature.value,
    signatureScheme: signer.scheme,
    signer: signerKey.value
  });
  return ok5(message);
};
var makeMessageHash = async (messageData) => {
  const dataBytes = MessageData.encode(messageData).finish();
  return ok5(blake32(dataBytes, { dkLen: 20 }));
};
var makeMessageWithSignature = async (messageData, signerOptions) => {
  const dataBytes = MessageData.encode(messageData).finish();
  const hash = blake32(dataBytes, { dkLen: 20 });
  const message = Message.create({
    // data: messageData,
    dataBytes,
    hash,
    hashScheme: 1 /* BLAKE3 */,
    ...signerOptions
  });
  return validateMessage(message);
};
var makeCastAdd = async (body, dataOptions, signer) => {
  const data = await makeCastAddData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeCastRemove = async (body, dataOptions, signer) => {
  const data = await makeCastRemoveData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeCastAddData = async (body, dataOptions) => {
  return makeMessageData({ castAddBody: body }, 1 /* CAST_ADD */, dataOptions);
};
var makeCastRemoveData = (body, dataOptions) => {
  return makeMessageData({ castRemoveBody: body }, 2 /* CAST_REMOVE */, dataOptions);
};
var makeLinkAdd = async (body, dataOptions, signer) => {
  const data = await makeLinkAddData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeLinkCompactState = async (body, dataOptions, signer) => {
  const data = await makeLinkCompactStateData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeLinkRemove = async (body, dataOptions, signer) => {
  const data = await makeLinkRemoveData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeLinkAddData = (body, dataOptions) => {
  return makeMessageData({ linkBody: body }, 5 /* LINK_ADD */, dataOptions);
};
var makeLinkCompactStateData = (body, dataOptions) => {
  return makeMessageData({ linkCompactStateBody: body }, 14 /* LINK_COMPACT_STATE */, dataOptions);
};
var makeLinkRemoveData = (body, dataOptions) => {
  return makeMessageData({ linkBody: body }, 6 /* LINK_REMOVE */, dataOptions);
};
var makeReactionAdd = async (body, dataOptions, signer) => {
  const data = await makeReactionAddData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeReactionRemove = async (body, dataOptions, signer) => {
  const data = await makeReactionRemoveData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeReactionAddData = (body, dataOptions) => {
  return makeMessageData({ reactionBody: body }, 3 /* REACTION_ADD */, dataOptions);
};
var makeReactionRemoveData = (body, dataOptions) => {
  return makeMessageData({ reactionBody: body }, 4 /* REACTION_REMOVE */, dataOptions);
};
var makeVerificationAddEthAddress = async (body, dataOptions, signer, publicClients = defaultPublicClients) => {
  const data = await makeVerificationAddEthAddressData(body, dataOptions, publicClients);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeVerificationRemove = async (body, dataOptions, signer) => {
  const data = await makeVerificationRemoveData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeVerificationAddEthAddressData = (body, dataOptions, publicClients = defaultPublicClients) => {
  return makeMessageData(
    { verificationAddAddressBody: body },
    7 /* VERIFICATION_ADD_ETH_ADDRESS */,
    dataOptions,
    publicClients
  );
};
var makeVerificationRemoveData = (body, dataOptions) => {
  return makeMessageData({ verificationRemoveBody: body }, 8 /* VERIFICATION_REMOVE */, dataOptions);
};
var makeUserDataAdd = async (body, dataOptions, signer) => {
  const data = await makeUserDataAddData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeUserDataAddData = (body, dataOptions) => {
  return makeMessageData({ userDataBody: body }, 11 /* USER_DATA_ADD */, dataOptions);
};
var makeUsernameProof = async (body, dataOptions, signer) => {
  const data = await makeUsernameProofData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeUsernameProofData = (body, dataOptions) => {
  return makeMessageData({ usernameProofBody: body }, 12 /* USERNAME_PROOF */, dataOptions);
};
var makeFrameAction = async (body, dataOptions, signer) => {
  const data = await makeFrameActionData(body, dataOptions);
  if (data.isErr()) {
    return err5(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeFrameActionData = (body, dataOptions) => {
  return makeMessageData({ frameActionBody: body }, 13 /* FRAME_ACTION */, dataOptions);
};

// src/eth/index.ts
init_esm_shims();

// src/eth/contracts/index.ts
init_esm_shims();

// src/eth/contracts/bundler.ts
init_esm_shims();
var BUNDLER_ADDRESS = "0x00000000FC04c910A0b5feA33b03E0447AD0B0aA";

// src/eth/contracts/idGateway.ts
init_esm_shims();
import { ResultAsync as ResultAsync2 } from "neverthrow";
import { verifyTypedData as verifyTypedData2, bytesToHex as bytesToHex3 } from "viem";
var ID_GATEWAY_ADDRESS = "0x00000000Fc25870C6eD6b6c7E41Fb078b7656f69";
var ID_GATEWAY_EIP_712_DOMAIN = {
  name: "Farcaster IdGateway",
  version: "1",
  chainId: 10,
  verifyingContract: ID_GATEWAY_ADDRESS
};
var ID_GATEWAY_REGISTER_TYPE = [
  { name: "to", type: "address" },
  { name: "recovery", type: "address" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var ID_GATEWAY_EIP_712_TYPES = {
  domain: ID_GATEWAY_EIP_712_DOMAIN,
  types: { Register: ID_GATEWAY_REGISTER_TYPE }
};
var verifyRegister = async (message, signature, address) => {
  const valid = await ResultAsync2.fromPromise(
    verifyTypedData2({
      address: bytesToHex3(address),
      domain: ID_GATEWAY_EIP_712_DOMAIN,
      types: { Register: ID_GATEWAY_REGISTER_TYPE },
      primaryType: "Register",
      message,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/idRegistry.ts
init_esm_shims();
import { ResultAsync as ResultAsync3 } from "neverthrow";
import { verifyTypedData as verifyTypedData3, bytesToHex as bytesToHex4 } from "viem";
var ID_REGISTRY_ADDRESS = "0x00000000Fc6c5F01Fc30151999387Bb99A9f489b";
var ID_REGISTRY_EIP_712_DOMAIN = {
  name: "Farcaster IdRegistry",
  version: "1",
  chainId: 10,
  verifyingContract: ID_REGISTRY_ADDRESS
};
var ID_REGISTRY_TRANSFER_TYPE = [
  { name: "fid", type: "uint256" },
  { name: "to", type: "address" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE = [
  { name: "fid", type: "uint256" },
  { name: "to", type: "address" },
  { name: "recovery", type: "address" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE = [
  { name: "fid", type: "uint256" },
  { name: "from", type: "address" },
  { name: "to", type: "address" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var ID_REGISTRY_EIP_712_TYPES = {
  domain: ID_REGISTRY_EIP_712_DOMAIN,
  types: {
    Transfer: ID_REGISTRY_TRANSFER_TYPE,
    TransferAndChangeRecovery: ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE,
    ChangeRecoveryAddress: ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE
  }
};
var verifyTransfer = async (message, signature, address) => {
  const valid = await ResultAsync3.fromPromise(
    verifyTypedData3({
      address: bytesToHex4(address),
      domain: ID_REGISTRY_EIP_712_DOMAIN,
      types: { Transfer: ID_REGISTRY_TRANSFER_TYPE },
      primaryType: "Transfer",
      message,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};
var verifyTransferAndChangeRecovery = async (message, signature, address) => {
  const valid = await ResultAsync3.fromPromise(
    verifyTypedData3({
      address: bytesToHex4(address),
      domain: ID_REGISTRY_EIP_712_DOMAIN,
      types: { TransferAndChangeRecovery: ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE },
      primaryType: "TransferAndChangeRecovery",
      message,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};
var verifyChangeRecoveryAddress = async (message, signature, address) => {
  const valid = await ResultAsync3.fromPromise(
    verifyTypedData3({
      address: bytesToHex4(address),
      domain: ID_REGISTRY_EIP_712_DOMAIN,
      types: { ChangeRecoveryAddress: ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE },
      primaryType: "ChangeRecoveryAddress",
      message,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/keyGateway.ts
init_esm_shims();
import { ResultAsync as ResultAsync4 } from "neverthrow";
import { verifyTypedData as verifyTypedData4, bytesToHex as bytesToHex5 } from "viem";
var KEY_GATEWAY_ADDRESS = "0x00000000fC56947c7E7183f8Ca4B62398CaAdf0B";
var KEY_GATEWAY_EIP_712_DOMAIN = {
  name: "Farcaster KeyGateway",
  version: "1",
  chainId: 10,
  verifyingContract: KEY_GATEWAY_ADDRESS
};
var KEY_GATEWAY_ADD_TYPE = [
  { name: "owner", type: "address" },
  { name: "keyType", type: "uint32" },
  { name: "key", type: "bytes" },
  { name: "metadataType", type: "uint8" },
  { name: "metadata", type: "bytes" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var KEY_GATEWAY_EIP_712_TYPES = {
  domain: KEY_GATEWAY_EIP_712_DOMAIN,
  types: { Add: KEY_GATEWAY_ADD_TYPE }
};
var verifyAdd = async (message, signature, address) => {
  const valid = await ResultAsync4.fromPromise(
    verifyTypedData4({
      address: bytesToHex5(address),
      domain: KEY_GATEWAY_EIP_712_DOMAIN,
      types: { Add: KEY_GATEWAY_ADD_TYPE },
      primaryType: "Add",
      message: { ...message, key: bytesToHex5(message.key) },
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/keyRegistry.ts
init_esm_shims();
import { ResultAsync as ResultAsync5 } from "neverthrow";
import { verifyTypedData as verifyTypedData5, bytesToHex as bytesToHex6 } from "viem";
var KEY_REGISTRY_ADDRESS = "0x00000000fc1237824fb747abde0ff18990e59b7e";
var KEY_REGISTRY_EIP_712_DOMAIN = {
  name: "Farcaster KeyRegistry",
  version: "1",
  chainId: 10,
  verifyingContract: KEY_REGISTRY_ADDRESS
};
var KEY_REGISTRY_REMOVE_TYPE = [
  { name: "owner", type: "address" },
  { name: "key", type: "bytes" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var KEY_REGISTRY_EIP_712_TYPES = {
  domain: KEY_REGISTRY_EIP_712_DOMAIN,
  types: { Remove: KEY_REGISTRY_REMOVE_TYPE }
};
var verifyRemove = async (message, signature, address) => {
  const valid = await ResultAsync5.fromPromise(
    verifyTypedData5({
      address: bytesToHex6(address),
      domain: KEY_REGISTRY_EIP_712_DOMAIN,
      types: { Remove: KEY_REGISTRY_REMOVE_TYPE },
      primaryType: "Remove",
      message: { ...message, key: bytesToHex6(message.key) },
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/signedKeyRequestValidator.ts
init_esm_shims();
import { ResultAsync as ResultAsync6 } from "neverthrow";
import { verifyTypedData as verifyTypedData6, bytesToHex as bytesToHex7 } from "viem";
var SIGNED_KEY_REQUEST_VALIDATOR_ADDRESS = "0x00000000FC700472606ED4fA22623Acf62c60553";
var SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN = {
  name: "Farcaster SignedKeyRequestValidator",
  version: "1",
  chainId: 10,
  verifyingContract: SIGNED_KEY_REQUEST_VALIDATOR_ADDRESS
};
var SIGNED_KEY_REQUEST_TYPE = [
  { name: "requestFid", type: "uint256" },
  { name: "key", type: "bytes" },
  { name: "deadline", type: "uint256" }
];
var SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES = {
  domain: SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
  types: { SignedKeyRequest: SIGNED_KEY_REQUEST_TYPE }
};
var verifyKeyRequest = async (message, signature, address) => {
  const valid = await ResultAsync6.fromPromise(
    verifyTypedData6({
      address: bytesToHex7(address),
      domain: SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
      types: { SignedKeyRequest: SIGNED_KEY_REQUEST_TYPE },
      primaryType: "SignedKeyRequest",
      message: { ...message, key: bytesToHex7(message.key) },
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/storageRegistry.ts
init_esm_shims();
var STORAGE_REGISTRY_ADDRESS = "0x00000000fcCe7f938e7aE6D3c335bD6a1a7c593D";

// src/eth/contracts/abis/index.ts
init_esm_shims();

// src/eth/contracts/abis/bundler.ts
init_esm_shims();
var bundlerABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_idGateway",
        type: "address"
      },
      {
        internalType: "address",
        name: "_keyGateway",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "CallFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidPayment",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidState",
    type: "error"
  },
  {
    inputs: [],
    name: "ExceedsMaximum",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMetadata",
    type: "error"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idGateway",
    outputs: [
      {
        internalType: "contract IIdGateway",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "keyGateway",
    outputs: [
      {
        internalType: "contract IKeyGateway",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "price",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "recovery",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "sig",
            type: "bytes"
          }
        ],
        internalType: "struct IBundler.RegistrationParams",
        name: "registerParams",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint32",
            name: "keyType",
            type: "uint32"
          },
          {
            internalType: "bytes",
            name: "key",
            type: "bytes"
          },
          {
            internalType: "uint8",
            name: "metadataType",
            type: "uint8"
          },
          {
            internalType: "bytes",
            name: "metadata",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "sig",
            type: "bytes"
          }
        ],
        internalType: "struct IBundler.SignerParams[]",
        name: "signerParams",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// src/eth/contracts/abis/idGateway.ts
init_esm_shims();
var idGatewayABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_storageRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "CallFailed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyGuardian",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidPayment",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldStorageRegistry",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newStorageRegistry",
        type: "address"
      }
    ],
    name: "SetStorageRegistry",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "REGISTER_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "addGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "guardians",
    outputs: [
      {
        internalType: "bool",
        name: "isGuardian",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idRegistry",
    outputs: [
      {
        internalType: "contract IIdRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "price",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "price",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "overpayment",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "registerFor",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "registerFor",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "overpayment",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "removeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_storageRegistry",
        type: "address"
      }
    ],
    name: "setStorageRegistry",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "storageRegistry",
    outputs: [
      {
        internalType: "contract IStorageRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "useNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// src/eth/contracts/abis/idRegistry.ts
init_esm_shims();
var idRegistryABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "AlreadyMigrated",
    type: "error"
  },
  {
    inputs: [],
    name: "GatewayFrozen",
    type: "error"
  },
  {
    inputs: [],
    name: "HasId",
    type: "error"
  },
  {
    inputs: [],
    name: "HasNoId",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyGuardian",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyMigrator",
    type: "error"
  },
  {
    inputs: [],
    name: "PermissionRevoked",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    name: "AdminReset",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "ChangeRecoveryAddress",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "idGateway",
        type: "address"
      }
    ],
    name: "FreezeIdGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "migratedAt",
        type: "uint256"
      }
    ],
    name: "Migrated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Recover",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "Register",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldCounter",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newCounter",
        type: "uint256"
      }
    ],
    name: "SetIdCounter",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldIdGateway",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newIdGateway",
        type: "address"
      }
    ],
    name: "SetIdGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldMigrator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newMigrator",
        type: "address"
      }
    ],
    name: "SetMigrator",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "CHANGE_RECOVERY_ADDRESS_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TRANSFER_AND_CHANGE_RECOVERY_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TRANSFER_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "addGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint24",
            name: "fid",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "custody",
            type: "address"
          },
          {
            internalType: "address",
            name: "recovery",
            type: "address"
          }
        ],
        internalType: "struct IIdRegistry.BulkRegisterData[]",
        name: "ids",
        type: "tuple[]"
      }
    ],
    name: "bulkRegisterIds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint24",
            name: "fid",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "custody",
            type: "address"
          }
        ],
        internalType: "struct IIdRegistry.BulkRegisterDefaultRecoveryData[]",
        name: "ids",
        type: "tuple[]"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "bulkRegisterIdsWithDefaultRecovery",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint24[]",
        name: "ids",
        type: "uint24[]"
      }
    ],
    name: "bulkResetIds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "changeRecoveryAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "changeRecoveryAddressFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    name: "custodyOf",
    outputs: [
      {
        internalType: "address",
        name: "custody",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "freezeIdGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "gatewayFrozen",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "gracePeriod",
    outputs: [
      {
        internalType: "uint24",
        name: "",
        type: "uint24"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "guardians",
    outputs: [
      {
        internalType: "bool",
        name: "isGuardian",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idCounter",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idGateway",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "idOf",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isMigrated",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "migratedAt",
    outputs: [
      {
        internalType: "uint40",
        name: "",
        type: "uint40"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrator",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "recover",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "recoveryDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "recoverySig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "toDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "toSig",
        type: "bytes"
      }
    ],
    name: "recoverFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    name: "recoveryOf",
    outputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "removeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_counter",
        type: "uint256"
      }
    ],
    name: "setIdCounter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_idGateway",
        type: "address"
      }
    ],
    name: "setIdGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      }
    ],
    name: "setMigrator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "transfer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "transferAndChangeRecovery",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "fromDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "fromSig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "toDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "toSig",
        type: "bytes"
      }
    ],
    name: "transferAndChangeRecoveryFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "fromDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "fromSig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "toDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "toSig",
        type: "bytes"
      }
    ],
    name: "transferFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "useNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "custodyAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "digest",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "verifyFidSignature",
    outputs: [
      {
        internalType: "bool",
        name: "isValid",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/eth/contracts/abis/keyGateway.ts
init_esm_shims();
var keyGatewayABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_keyRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyGuardian",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMetadata",
    type: "error"
  },
  {
    inputs: [],
    name: "ExceedsMaximum",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidState",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "ADD_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "fidOwner",
        type: "address"
      },
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "addFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "addGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "guardians",
    outputs: [
      {
        internalType: "bool",
        name: "isGuardian",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "keyRegistry",
    outputs: [
      {
        internalType: "contract IKeyRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "removeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "useNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/eth/contracts/abis/keyRegistry.ts
init_esm_shims();
var keyRegistryABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_maxKeysPerFid",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "AlreadyMigrated",
    type: "error"
  },
  {
    inputs: [],
    name: "ExceedsMaximum",
    type: "error"
  },
  {
    inputs: [],
    name: "GatewayFrozen",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidKeyType",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMaxKeys",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMetadata",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMetadataType",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidState",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyGuardian",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyMigrator",
    type: "error"
  },
  {
    inputs: [],
    name: "PermissionRevoked",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      }
    ],
    name: "ValidatorNotFound",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "keyBytes",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "keyBytes",
        type: "bytes"
      }
    ],
    name: "AdminReset",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "keyGateway",
        type: "address"
      }
    ],
    name: "FreezeKeyGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "migratedAt",
        type: "uint256"
      }
    ],
    name: "Migrated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "keyBytes",
        type: "bytes"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldIdRegistry",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newIdRegistry",
        type: "address"
      }
    ],
    name: "SetIdRegistry",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldKeyGateway",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newKeyGateway",
        type: "address"
      }
    ],
    name: "SetKeyGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldMax",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newMax",
        type: "uint256"
      }
    ],
    name: "SetMaxKeysPerFid",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldMigrator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newMigrator",
        type: "address"
      }
    ],
    name: "SetMigrator",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "address",
        name: "oldValidator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newValidator",
        type: "address"
      }
    ],
    name: "SetValidator",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "REMOVE_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "fidOwner",
        type: "address"
      },
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "addGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "fid",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "bytes",
                name: "key",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "metadata",
                type: "bytes"
              }
            ],
            internalType: "struct IKeyRegistry.BulkAddKey[]",
            name: "keys",
            type: "tuple[]"
          }
        ],
        internalType: "struct IKeyRegistry.BulkAddData[]",
        name: "items",
        type: "tuple[]"
      }
    ],
    name: "bulkAddKeysForMigration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "fid",
            type: "uint256"
          },
          {
            internalType: "bytes[]",
            name: "keys",
            type: "bytes[]"
          }
        ],
        internalType: "struct IKeyRegistry.BulkResetData[]",
        name: "items",
        type: "tuple[]"
      }
    ],
    name: "bulkResetKeysForMigration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "freezeKeyGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "gatewayFrozen",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "gracePeriod",
    outputs: [
      {
        internalType: "uint24",
        name: "",
        type: "uint24"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "guardians",
    outputs: [
      {
        internalType: "bool",
        name: "isGuardian",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idRegistry",
    outputs: [
      {
        internalType: "contract IdRegistryLike",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isMigrated",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "keyAt",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "keyDataOf",
    outputs: [
      {
        components: [
          {
            internalType: "enum IKeyRegistry.KeyState",
            name: "state",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "keyType",
            type: "uint32"
          }
        ],
        internalType: "struct IKeyRegistry.KeyData",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "keyGateway",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "keys",
    outputs: [
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      },
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      }
    ],
    name: "keysOf",
    outputs: [
      {
        internalType: "bytes[]",
        name: "",
        type: "bytes[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "startIdx",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "batchSize",
        type: "uint256"
      }
    ],
    name: "keysOf",
    outputs: [
      {
        internalType: "bytes[]",
        name: "page",
        type: "bytes[]"
      },
      {
        internalType: "uint256",
        name: "nextIdx",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "maxKeysPerFid",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "migratedAt",
    outputs: [
      {
        internalType: "uint40",
        name: "",
        type: "uint40"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrator",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "remove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "fidOwner",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "removeFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "removeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      }
    ],
    name: "setIdRegistry",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_keyGateway",
        type: "address"
      }
    ],
    name: "setKeyGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_maxKeysPerFid",
        type: "uint256"
      }
    ],
    name: "setMaxKeysPerFid",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      }
    ],
    name: "setMigrator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        internalType: "contract IMetadataValidator",
        name: "validator",
        type: "address"
      }
    ],
    name: "setValidator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      }
    ],
    name: "totalKeys",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "useNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      }
    ],
    name: "validators",
    outputs: [
      {
        internalType: "contract IMetadataValidator",
        name: "validator",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/eth/contracts/abis/signedKeyRequestValidator.ts
init_esm_shims();
var signedKeyRequestValidatorABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldIdRegistry",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newIdRegistry",
        type: "address"
      }
    ],
    name: "SetIdRegistry",
    type: "event"
  },
  {
    inputs: [],
    name: "METADATA_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "requestFid",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "requestSigner",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        internalType: "struct SignedKeyRequestValidator.SignedKeyRequestMetadata",
        name: "metadata",
        type: "tuple"
      }
    ],
    name: "encodeMetadata",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idRegistry",
    outputs: [
      {
        internalType: "contract IdRegistryLike",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      }
    ],
    name: "setIdRegistry",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "signedKeyRequestBytes",
        type: "bytes"
      }
    ],
    name: "validate",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/eth/contracts/abis/storageRegistry.ts
init_esm_shims();
var storageRegistryABI = [
  {
    inputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "_priceFeed",
        type: "address"
      },
      {
        internalType: "contract AggregatorV3Interface",
        name: "_uptimeFeed",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_initialUsdUnitPrice",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_initialMaxUnits",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_initialVault",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialRoleAdmin",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOperator",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialTreasurer",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "CallFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "ContractDeprecated",
    type: "error"
  },
  {
    inputs: [],
    name: "ExceedsCapacity",
    type: "error"
  },
  {
    inputs: [],
    name: "GracePeriodNotOver",
    type: "error"
  },
  {
    inputs: [],
    name: "IncompleteRound",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidAmount",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidBatchInput",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidDeprecationTimestamp",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidFixedPrice",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMaxAnswer",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMinAnswer",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidPayment",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidPrice",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidRangeInput",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidRoundTimestamp",
    type: "error"
  },
  {
    inputs: [],
    name: "NotOperator",
    type: "error"
  },
  {
    inputs: [],
    name: "NotOwner",
    type: "error"
  },
  {
    inputs: [],
    name: "NotTreasurer",
    type: "error"
  },
  {
    inputs: [],
    name: "PriceOutOfBounds",
    type: "error"
  },
  {
    inputs: [],
    name: "SequencerDown",
    type: "error"
  },
  {
    inputs: [],
    name: "StaleAnswer",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "payer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "Rent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldDuration",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newDuration",
        type: "uint256"
      }
    ],
    name: "SetCacheDuration",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldTimestamp",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newTimestamp",
        type: "uint256"
      }
    ],
    name: "SetDeprecationTimestamp",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPrice",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPrice",
        type: "uint256"
      }
    ],
    name: "SetFixedEthUsdPrice",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPeriod",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPeriod",
        type: "uint256"
      }
    ],
    name: "SetGracePeriod",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldAge",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newAge",
        type: "uint256"
      }
    ],
    name: "SetMaxAge",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPrice",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPrice",
        type: "uint256"
      }
    ],
    name: "SetMaxAnswer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldMax",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newMax",
        type: "uint256"
      }
    ],
    name: "SetMaxUnits",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPrice",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPrice",
        type: "uint256"
      }
    ],
    name: "SetMinAnswer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPrice",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPrice",
        type: "uint256"
      }
    ],
    name: "SetPrice",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldFeed",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newFeed",
        type: "address"
      }
    ],
    name: "SetPriceFeed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldFeed",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newFeed",
        type: "address"
      }
    ],
    name: "SetUptimeFeed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldVault",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newVault",
        type: "address"
      }
    ],
    name: "SetVault",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdraw",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "fids",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "batchCredit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "fids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "units",
        type: "uint256[]"
      }
    ],
    name: "batchRent",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "start",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "end",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "continuousCredit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "credit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "deprecationTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ethUsdPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "fixedEthUsdPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lastPriceFeedUpdateBlock",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lastPriceFeedUpdateTime",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "maxUnits",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "prevEthUsdPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "price",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeed",
    outputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeedCacheDuration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeedMaxAge",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeedMaxAnswer",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeedMinAnswer",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "refreshPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "rent",
    outputs: [
      {
        internalType: "uint256",
        name: "overpayment",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "rentedUnits",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "duration",
        type: "uint256"
      }
    ],
    name: "setCacheDuration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    name: "setDeprecationTimestamp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fixedPrice",
        type: "uint256"
      }
    ],
    name: "setFixedEthUsdPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "period",
        type: "uint256"
      }
    ],
    name: "setGracePeriod",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "age",
        type: "uint256"
      }
    ],
    name: "setMaxAge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxPrice",
        type: "uint256"
      }
    ],
    name: "setMaxAnswer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "max",
        type: "uint256"
      }
    ],
    name: "setMaxUnits",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minPrice",
        type: "uint256"
      }
    ],
    name: "setMinAnswer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "usdPrice",
        type: "uint256"
      }
    ],
    name: "setPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "feed",
        type: "address"
      }
    ],
    name: "setPriceFeed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "feed",
        type: "address"
      }
    ],
    name: "setUptimeFeed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "vaultAddr",
        type: "address"
      }
    ],
    name: "setVault",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unitPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "uptimeFeed",
    outputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "uptimeFeedGracePeriod",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "usdUnitPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "vault",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/factories.ts
init_esm_shims();
import { faker } from "@faker-js/faker";

// ../../node_modules/@farcaster/fishery/dist/fishery.mjs
init_esm_shims();
var import_lodash = __toESM(require_lodash(), 1);
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
var merge = import_lodash.default;
var mergeCustomizer = function(objValue, srcVal, key, object) {
  if (Array.isArray(srcVal) || ArrayBuffer.isView(srcVal)) {
    return srcVal;
  } else if (srcVal === void 0) {
    object[key] = srcVal;
  }
};
var FactoryBuilder = (
  /** @class */
  function() {
    function FactoryBuilder2(generator, sequence, params, transientParams, associations, afterBuilds, afterCreates, onCreate) {
      var _this = this;
      this.generator = generator;
      this.sequence = sequence;
      this.params = params;
      this.transientParams = transientParams;
      this.associations = associations;
      this.afterBuilds = afterBuilds;
      this.afterCreates = afterCreates;
      this.onCreate = onCreate;
      this.setAfterBuild = function(hook) {
        _this.afterBuilds = __spreadArrays([hook], _this.afterBuilds);
      };
      this.setAfterCreate = function(hook) {
        _this.afterCreates = __spreadArrays([hook], _this.afterCreates);
      };
      this.setOnCreate = function(hook) {
        if (!_this.onCreate) {
          _this.onCreate = hook;
        }
      };
    }
    FactoryBuilder2.prototype.build = function() {
      var generatorOptions = {
        sequence: this.sequence,
        afterBuild: this.setAfterBuild,
        afterCreate: this.setAfterCreate,
        onCreate: this.setOnCreate,
        params: this.params,
        associations: this.associations,
        transientParams: this.transientParams
      };
      var object = this._mergeParamsOntoObject(this.generator(generatorOptions));
      this._callAfterBuilds(object);
      return object;
    };
    FactoryBuilder2.prototype.create = function() {
      return __awaiter(this, void 0, void 0, function() {
        var object, created;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              object = this.build();
              return [4, this._callOnCreate(object)];
            case 1:
              created = _a.sent();
              return [2, this._callAfterCreates(created)];
          }
        });
      });
    };
    FactoryBuilder2.prototype._mergeParamsOntoObject = function(object) {
      if (typeof object !== "object") {
        return object;
      }
      var targetObject = object;
      if (Object.getPrototypeOf(object) === Object.prototype) {
        targetObject = {};
      } else if (Array.isArray(object)) {
        targetObject = [];
      }
      return merge(targetObject, object, this.params, this.associations, mergeCustomizer);
    };
    FactoryBuilder2.prototype._callAfterBuilds = function(object) {
      this.afterBuilds.forEach(function(afterBuild) {
        if (typeof afterBuild === "function") {
          afterBuild(object);
        } else {
          throw new Error('"afterBuild" must be a function');
        }
      });
    };
    FactoryBuilder2.prototype._callOnCreate = function(object) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          if (!this.onCreate) {
            throw new Error("Attempted to call `create`, but no onCreate defined");
          }
          return [2, this.onCreate(object)];
        });
      });
    };
    FactoryBuilder2.prototype._callAfterCreates = function(object) {
      return __awaiter(this, void 0, void 0, function() {
        var created, _i, _a, afterCreate;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              created = object;
              _i = 0, _a = this.afterCreates;
              _b.label = 1;
            case 1:
              if (!(_i < _a.length))
                return [3, 5];
              afterCreate = _a[_i];
              if (!(typeof afterCreate === "function"))
                return [3, 3];
              return [4, afterCreate(created)];
            case 2:
              created = _b.sent();
              return [3, 4];
            case 3:
              throw new Error('"afterCreate" must be a function');
            case 4:
              _i++;
              return [3, 1];
            case 5:
              return [2, created];
          }
        });
      });
    };
    return FactoryBuilder2;
  }()
);
var SEQUENCE_START_VALUE = 1;
var Factory = (
  /** @class */
  function() {
    function Factory2(generator) {
      this.generator = generator;
      this.id = { value: SEQUENCE_START_VALUE };
      this._afterBuilds = [];
      this._afterCreates = [];
    }
    Factory2.define = function(generator) {
      return new this(generator);
    };
    Factory2.prototype.build = function(params, options) {
      if (options === void 0) {
        options = {};
      }
      return this.builder(params, options).build();
    };
    Factory2.prototype.buildList = function(number, params, options) {
      if (options === void 0) {
        options = {};
      }
      var list = [];
      for (var i = 0; i < number; i++) {
        list.push(this.build(params, options));
      }
      return list;
    };
    Factory2.prototype.create = function(params, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, this.builder(params, options).create()];
        });
      });
    };
    Factory2.prototype.createList = function(number, params, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var list, i;
        return __generator(this, function(_a) {
          list = [];
          for (i = 0; i < number; i++) {
            list.push(this.create(params, options));
          }
          return [2, Promise.all(list)];
        });
      });
    };
    Factory2.prototype.afterBuild = function(afterBuildFn) {
      var factory = this.clone();
      factory._afterBuilds.push(afterBuildFn);
      return factory;
    };
    Factory2.prototype.onCreate = function(onCreateFn) {
      var factory = this.clone();
      factory._onCreate = onCreateFn;
      return factory;
    };
    Factory2.prototype.afterCreate = function(afterCreateFn) {
      var factory = this.clone();
      factory._afterCreates.push(afterCreateFn);
      return factory;
    };
    Factory2.prototype.associations = function(associations) {
      var factory = this.clone();
      factory._associations = __assign(__assign({}, this._associations), associations);
      return factory;
    };
    Factory2.prototype.params = function(params) {
      var factory = this.clone();
      factory._params = merge({}, this._params, params, mergeCustomizer);
      return factory;
    };
    Factory2.prototype.transient = function(transient) {
      var factory = this.clone();
      factory._transient = __assign(__assign({}, this._transient), transient);
      return factory;
    };
    Factory2.prototype.rewindSequence = function() {
      this.id.value = SEQUENCE_START_VALUE;
    };
    Factory2.prototype.clone = function() {
      var copy = new this.constructor(this.generator);
      Object.assign(copy, this);
      copy._afterCreates = __spreadArrays(this._afterCreates);
      copy._afterBuilds = __spreadArrays(this._afterBuilds);
      return copy;
    };
    Factory2.prototype.sequence = function() {
      return this.id.value++;
    };
    Factory2.prototype.builder = function(params, options) {
      if (options === void 0) {
        options = {};
      }
      return new FactoryBuilder(this.generator, this.sequence(), merge({}, this._params, params, mergeCustomizer), __assign(__assign({}, this._transient), options.transient), __assign(__assign({}, this._associations), options.associations), this._afterBuilds, this._afterCreates, this._onCreate);
    };
    return Factory2;
  }()
);

// src/factories.ts
import { ed25519 as ed255193 } from "@noble/curves/ed25519";
import { blake3 as blake33 } from "@noble/hashes/blake3";
import { generatePrivateKey, privateKeyToAccount } from "viem/accounts";
import { randomBytes } from "@noble/hashes/utils";

// src/signers/index.ts
init_esm_shims();

// src/signers/ed25519Signer.ts
init_esm_shims();
var Ed25519Signer = class {
  constructor() {
    /** Signature scheme as defined in protobufs */
    __publicField(this, "scheme", 1 /* ED25519 */);
  }
};

// src/signers/eip712Signer.ts
init_esm_shims();
var Eip712Signer = class {
  constructor() {
    /** Signature scheme as defined in protobufs */
    __publicField(this, "scheme", 2 /* EIP712 */);
  }
};

// src/signers/ethersEip712Signer.ts
init_esm_shims();
import { ResultAsync as ResultAsync7, err as err6 } from "neverthrow";
import { encodeAbiParameters } from "viem";
var EthersEip712Signer = class extends Eip712Signer {
  constructor(signer) {
    super();
    __publicField(this, "_ethersSigner");
    this._ethersSigner = signer;
  }
  async getSignerKey() {
    return ResultAsync7.fromPromise(this._ethersSigner.getAddress(), (e) => new HubError("unknown", e)).andThen(
      hexStringToBytes
    );
  }
  async signMessageHash(hash) {
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(
        EIP_712_FARCASTER_DOMAIN,
        { MessageData: [...EIP_712_FARCASTER_MESSAGE_DATA] },
        { hash }
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signVerificationEthAddressClaim(claim, chainId = 0) {
    const domain = chainId === 0 ? EIP_712_FARCASTER_DOMAIN : { ...EIP_712_FARCASTER_DOMAIN, chainId };
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(domain, { VerificationClaim: [...EIP_712_FARCASTER_VERIFICATION_CLAIM] }, claim),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signUserNameProofClaim(userNameProof) {
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(
        EIP_712_USERNAME_DOMAIN,
        { UserNameProof: [...EIP_712_USERNAME_PROOF] },
        userNameProof
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signRegister(message) {
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(ID_GATEWAY_EIP_712_DOMAIN, { Register: [...ID_GATEWAY_REGISTER_TYPE] }, message),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signTransfer(message) {
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { Transfer: [...ID_REGISTRY_TRANSFER_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signTransferAndChangeRecovery(message) {
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { TransferAndChangeRecovery: [...ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signChangeRecoveryAddress(message) {
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { ChangeRecoveryAddress: [...ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signAdd(message) {
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(KEY_GATEWAY_EIP_712_DOMAIN, { Add: [...KEY_GATEWAY_ADD_TYPE] }, message),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signRemove(message) {
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(KEY_REGISTRY_EIP_712_DOMAIN, { Remove: [...KEY_REGISTRY_REMOVE_TYPE] }, message),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signKeyRequest(message) {
    const hexSignature = await ResultAsync7.fromPromise(
      this._ethersSigner.signTypedData(
        SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
        { SignedKeyRequest: [...SIGNED_KEY_REQUEST_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async getSignedKeyRequestMetadata(message) {
    const signatureBytes = await this.signKeyRequest(message);
    if (signatureBytes.isErr()) {
      return err6(signatureBytes.error);
    }
    const signature = bytesToHexString(signatureBytes.value);
    if (signature.isErr()) {
      return err6(signature.error);
    }
    const signerAddressBytes = await this.getSignerKey();
    if (signerAddressBytes.isErr()) {
      return err6(signerAddressBytes.error);
    }
    const signerAddress = bytesToHexString(signerAddressBytes.value);
    if (signerAddress.isErr()) {
      return err6(signerAddress.error);
    }
    const metadataStruct = {
      requestFid: message.requestFid,
      requestSigner: signerAddress.value,
      signature: signature.value,
      deadline: message.deadline
    };
    const encodedStruct = encodeAbiParameters(
      [
        {
          components: [
            {
              name: "requestFid",
              type: "uint256"
            },
            {
              name: "requestSigner",
              type: "address"
            },
            {
              name: "signature",
              type: "bytes"
            },
            {
              name: "deadline",
              type: "uint256"
            }
          ],
          name: "SignedKeyRequestMetadata",
          type: "tuple"
        }
      ],
      [metadataStruct]
    );
    return hexStringToBytes(encodedStruct);
  }
};

// src/signers/ethersV5Eip712Signer.ts
init_esm_shims();
import { ResultAsync as ResultAsync8, err as err7 } from "neverthrow";
import { encodeAbiParameters as encodeAbiParameters2 } from "viem";
var EthersV5Eip712Signer = class extends Eip712Signer {
  constructor(typedDataSigner) {
    super();
    __publicField(this, "_typedDataSigner");
    this._typedDataSigner = typedDataSigner;
  }
  async getSignerKey() {
    return ResultAsync8.fromPromise(
      this._typedDataSigner.getAddress(),
      (e) => new HubError("unknown", e)
    ).andThen(hexStringToBytes);
  }
  async signMessageHash(hash) {
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(
        eip712_exports.EIP_712_FARCASTER_DOMAIN,
        { MessageData: [...eip712_exports.EIP_712_FARCASTER_MESSAGE_DATA] },
        { hash }
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signVerificationEthAddressClaim(claim, chainId = 0) {
    const domain = chainId === 0 ? eip712_exports.EIP_712_FARCASTER_DOMAIN : { ...eip712_exports.EIP_712_FARCASTER_DOMAIN, chainId };
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(
        domain,
        { VerificationClaim: [...eip712_exports.EIP_712_FARCASTER_VERIFICATION_CLAIM] },
        claim
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signUserNameProofClaim(usernameProof) {
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(
        eip712_exports.EIP_712_USERNAME_DOMAIN,
        { UserNameProof: [...eip712_exports.EIP_712_USERNAME_PROOF] },
        usernameProof
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signRegister(message) {
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(
        ID_GATEWAY_EIP_712_DOMAIN,
        { Register: [...ID_GATEWAY_REGISTER_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signTransfer(message) {
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { Transfer: [...ID_REGISTRY_TRANSFER_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signTransferAndChangeRecovery(message) {
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { TransferAndChangeRecovery: [...ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signChangeRecoveryAddress(message) {
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { ChangeRecoveryAddress: [...ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signAdd(message) {
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(KEY_GATEWAY_EIP_712_DOMAIN, { Add: [...KEY_GATEWAY_ADD_TYPE] }, message),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signRemove(message) {
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(
        KEY_REGISTRY_EIP_712_DOMAIN,
        { Remove: [...KEY_REGISTRY_REMOVE_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signKeyRequest(message) {
    const hexSignature = await ResultAsync8.fromPromise(
      this._typedDataSigner._signTypedData(
        SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
        { SignedKeyRequest: [...SIGNED_KEY_REQUEST_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async getSignedKeyRequestMetadata(message) {
    const signatureBytes = await this.signKeyRequest(message);
    if (signatureBytes.isErr()) {
      return err7(signatureBytes.error);
    }
    const signature = bytesToHexString(signatureBytes.value);
    if (signature.isErr()) {
      return err7(signature.error);
    }
    const signerAddressBytes = await this.getSignerKey();
    if (signerAddressBytes.isErr()) {
      return err7(signerAddressBytes.error);
    }
    const signerAddress = bytesToHexString(signerAddressBytes.value);
    if (signerAddress.isErr()) {
      return err7(signerAddress.error);
    }
    const metadataStruct = {
      requestFid: message.requestFid,
      requestSigner: signerAddress.value,
      signature: signature.value,
      deadline: message.deadline
    };
    const encodedStruct = encodeAbiParameters2(
      [
        {
          components: [
            {
              name: "requestFid",
              type: "uint256"
            },
            {
              name: "requestSigner",
              type: "address"
            },
            {
              name: "signature",
              type: "bytes"
            },
            {
              name: "deadline",
              type: "uint256"
            }
          ],
          name: "SignedKeyRequestMetadata",
          type: "tuple"
        }
      ],
      [metadataStruct]
    );
    return hexStringToBytes(encodedStruct);
  }
};

// src/signers/nobleEd25519Signer.ts
init_esm_shims();
import { ok as ok6 } from "neverthrow";
import { ed25519 as ed255192 } from "@noble/curves/ed25519";
var NobleEd25519Signer = class extends Ed25519Signer {
  constructor(privateKey) {
    super();
    __publicField(this, "_privateKey");
    this._privateKey = privateKey;
  }
  async getSignerKey() {
    return ok6(ed255192.getPublicKey(this._privateKey));
  }
  async signMessageHash(hash) {
    return ok6(ed255192.sign(hash, this._privateKey));
  }
};

// src/signers/viemLocalEip712Signer.ts
init_esm_shims();
import { ResultAsync as ResultAsync9, err as err8 } from "neverthrow";
import { bytesToHex as bytesToHex8, encodeAbiParameters as encodeAbiParameters3 } from "viem/utils";
var ViemLocalEip712Signer = class extends Eip712Signer {
  constructor(viemLocalAccount) {
    super();
    __publicField(this, "_viemLocalAccount");
    this._viemLocalAccount = viemLocalAccount;
  }
  async getSignerKey() {
    return ResultAsync9.fromPromise(
      Promise.resolve(this._viemLocalAccount.address),
      (e) => new HubError("unknown", e)
    ).andThen(hexStringToBytes);
  }
  async signMessageHash(hash) {
    return this._signTypedData({
      ...MESSAGE_DATA_EIP_712_TYPES,
      primaryType: "MessageData",
      message: {
        hash: bytesToHex8(hash)
      }
    });
  }
  async signVerificationEthAddressClaim(claim, chainId = 0) {
    const domain = chainId === 0 ? EIP_712_FARCASTER_DOMAIN : { ...EIP_712_FARCASTER_DOMAIN, chainId };
    return this._signTypedData({
      domain,
      types: { VerificationClaim: EIP_712_FARCASTER_VERIFICATION_CLAIM },
      primaryType: "VerificationClaim",
      message: claim
    });
  }
  async signUserNameProofClaim(userNameProof) {
    return this._signTypedData({
      ...USERNAME_PROOF_EIP_712_TYPES,
      primaryType: "UserNameProof",
      message: userNameProof
    });
  }
  async signRegister(message) {
    return this._signTypedData({
      ...ID_GATEWAY_EIP_712_TYPES,
      primaryType: "Register",
      message
    });
  }
  async signTransfer(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "Transfer",
      message
    });
  }
  async signTransferAndChangeRecovery(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "TransferAndChangeRecovery",
      message
    });
  }
  async signChangeRecoveryAddress(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "ChangeRecoveryAddress",
      message
    });
  }
  async signAdd(message) {
    return this._signTypedData({
      ...KEY_GATEWAY_EIP_712_TYPES,
      primaryType: "Add",
      message: { ...message, key: bytesToHex8(message.key) }
    });
  }
  async signRemove(message) {
    return this._signTypedData({
      ...KEY_REGISTRY_EIP_712_TYPES,
      primaryType: "Remove",
      message: { ...message, key: bytesToHex8(message.key) }
    });
  }
  async signKeyRequest(message) {
    return this._signTypedData({
      ...SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES,
      primaryType: "SignedKeyRequest",
      message: { ...message, key: bytesToHex8(message.key) }
    });
  }
  async getSignedKeyRequestMetadata(message) {
    const signatureBytes = await this.signKeyRequest(message);
    if (signatureBytes.isErr()) {
      return err8(signatureBytes.error);
    }
    const signature = bytesToHexString(signatureBytes.value);
    if (signature.isErr()) {
      return err8(signature.error);
    }
    const signerAddressBytes = await this.getSignerKey();
    if (signerAddressBytes.isErr()) {
      return err8(signerAddressBytes.error);
    }
    const signerAddress = bytesToHexString(signerAddressBytes.value);
    if (signerAddress.isErr()) {
      return err8(signerAddress.error);
    }
    const metadataStruct = {
      requestFid: message.requestFid,
      requestSigner: signerAddress.value,
      signature: signature.value,
      deadline: message.deadline
    };
    const encodedStruct = encodeAbiParameters3(
      [
        {
          components: [
            {
              name: "requestFid",
              type: "uint256"
            },
            {
              name: "requestSigner",
              type: "address"
            },
            {
              name: "signature",
              type: "bytes"
            },
            {
              name: "deadline",
              type: "uint256"
            }
          ],
          name: "SignedKeyRequestMetadata",
          type: "tuple"
        }
      ],
      [metadataStruct]
    );
    return hexStringToBytes(encodedStruct);
  }
  async _signTypedData(params) {
    const hexSignature = await ResultAsync9.fromPromise(
      this._viemLocalAccount.signTypedData(params),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
};

// src/signers/viemWalletEip712Signer.ts
init_esm_shims();
import { ResultAsync as ResultAsync10, err as err9 } from "neverthrow";
import { bytesToHex as bytesToHex9, encodeAbiParameters as encodeAbiParameters4 } from "viem/utils";
import { signTypedData } from "viem/actions";
var ViemWalletEip712Signer = class extends Eip712Signer {
  constructor(viemWalletClient) {
    super();
    __publicField(this, "_viemWalletClient");
    this._viemWalletClient = viemWalletClient;
  }
  async getSignerKey() {
    var _a;
    const address = (_a = this._viemWalletClient.account) == null ? void 0 : _a.address;
    if (!address) {
      return err9(new HubError("unavailable", "wallet not connected"));
    }
    return ResultAsync10.fromPromise(Promise.resolve(address), (e) => new HubError("unknown", e)).andThen(
      hexStringToBytes
    );
  }
  async signMessageHash(hash) {
    return this._signTypedData({
      ...MESSAGE_DATA_EIP_712_TYPES,
      primaryType: "MessageData",
      message: {
        hash: bytesToHex9(hash)
      }
    });
  }
  async signVerificationEthAddressClaim(claim, chainId = 0) {
    const domain = chainId === 0 ? EIP_712_FARCASTER_DOMAIN : { ...EIP_712_FARCASTER_DOMAIN, chainId };
    return this._signTypedData({
      domain,
      types: { VerificationClaim: EIP_712_FARCASTER_VERIFICATION_CLAIM },
      primaryType: "VerificationClaim",
      message: claim
    });
  }
  async signUserNameProofClaim(userNameProof) {
    return this._signTypedData({
      ...USERNAME_PROOF_EIP_712_TYPES,
      primaryType: "UserNameProof",
      message: userNameProof
    });
  }
  async signRegister(message) {
    return this._signTypedData({
      ...ID_GATEWAY_EIP_712_TYPES,
      primaryType: "Register",
      message
    });
  }
  async signTransfer(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "Transfer",
      message
    });
  }
  async signTransferAndChangeRecovery(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "TransferAndChangeRecovery",
      message
    });
  }
  async signChangeRecoveryAddress(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "ChangeRecoveryAddress",
      message
    });
  }
  async signAdd(message) {
    return this._signTypedData({
      ...KEY_GATEWAY_EIP_712_TYPES,
      primaryType: "Add",
      message: { ...message, key: bytesToHex9(message.key) }
    });
  }
  async signRemove(message) {
    return this._signTypedData({
      ...KEY_REGISTRY_EIP_712_TYPES,
      primaryType: "Remove",
      message: { ...message, key: bytesToHex9(message.key) }
    });
  }
  async signKeyRequest(message) {
    return this._signTypedData({
      ...SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES,
      primaryType: "SignedKeyRequest",
      message: { ...message, key: bytesToHex9(message.key) }
    });
  }
  async getSignedKeyRequestMetadata(message) {
    const signatureBytes = await this.signKeyRequest(message);
    if (signatureBytes.isErr()) {
      return err9(signatureBytes.error);
    }
    const signature = bytesToHexString(signatureBytes.value);
    if (signature.isErr()) {
      return err9(signature.error);
    }
    const signerAddressBytes = await this.getSignerKey();
    if (signerAddressBytes.isErr()) {
      return err9(signerAddressBytes.error);
    }
    const signerAddress = bytesToHexString(signerAddressBytes.value);
    if (signerAddress.isErr()) {
      return err9(signerAddress.error);
    }
    const metadataStruct = {
      requestFid: message.requestFid,
      requestSigner: signerAddress.value,
      signature: signature.value,
      deadline: message.deadline
    };
    const encodedStruct = encodeAbiParameters4(
      [
        {
          components: [
            {
              name: "requestFid",
              type: "uint256"
            },
            {
              name: "requestSigner",
              type: "address"
            },
            {
              name: "signature",
              type: "bytes"
            },
            {
              name: "deadline",
              type: "uint256"
            }
          ],
          name: "SignedKeyRequestMetadata",
          type: "tuple"
        }
      ],
      [metadataStruct]
    );
    return hexStringToBytes(encodedStruct);
  }
  async _signTypedData(params) {
    const account = this._viemWalletClient.account;
    if (!account) {
      return err9(new HubError("unavailable", "wallet not connected"));
    }
    const hexSignature = await ResultAsync10.fromPromise(
      signTypedData(this._viemWalletClient, { ...params, account }),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
};

// src/signers/signer.ts
init_esm_shims();

// src/factories.ts
import { bytesToHex as bytesToHex10, hexToBytes as hexToBytes2 } from "viem";

// ../../node_modules/ethers/lib.esm/ethers.js
init_esm_shims();

// ../../node_modules/ethers/lib.esm/_version.js
init_esm_shims();
var version = "6.6.1";

// ../../node_modules/ethers/lib.esm/utils/index.js
init_esm_shims();

// ../../node_modules/ethers/lib.esm/utils/errors.js
init_esm_shims();

// ../../node_modules/ethers/lib.esm/utils/properties.js
init_esm_shims();
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// ../../node_modules/ethers/lib.esm/utils/errors.js
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function makeError(message, code, info) {
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);

// ../../node_modules/ethers/lib.esm/utils/maths.js
init_esm_shims();
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var maxValue = 9007199254740991;
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
var Nibbles = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles[v >> 4];
      result += Nibbles[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}

// src/factories.ts
var FidFactory = Factory.define(() => {
  return faker.datatype.number({ min: 1 });
});
var BytesFactory = Factory.define(({ transientParams }) => {
  var _a;
  const length = (_a = transientParams.length) != null ? _a : faker.datatype.number({ max: 64, min: 1 });
  return randomBytes(length);
});
var MessageHashFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 20 } });
});
var FnameFactory = Factory.define(() => {
  const length = faker.datatype.number({ min: 1, max: 16 });
  const bytes = new Uint8Array(length);
  bytes.set(
    [
      faker.helpers.arrayElement([
        faker.datatype.number({ min: 48, max: 57 }),
        faker.datatype.number({ min: 97, max: 122 })
      ])
    ],
    0
  );
  for (let i = 1; i < length; i++) {
    bytes.set(
      [
        faker.helpers.arrayElement([
          45,
          faker.datatype.number({ min: 48, max: 57 }),
          faker.datatype.number({ min: 97, max: 122 })
        ])
      ],
      i
    );
  }
  return bytes;
});
var EnsNameFactory = Factory.define(() => {
  const ensName = faker.random.alphaNumeric(faker.datatype.number({ min: 3, max: 16 }));
  return utf8StringToBytes(ensName.concat(".eth"))._unsafeUnwrap();
});
var BlockHashFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 32 } });
});
var EthAddressFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 20 } });
});
var SolAddressFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 32 } });
});
var TransactionHashFactory = Factory.define(() => {
  return BytesFactory.build(void 0, { transient: { length: 32 } });
});
var Ed25519PrivateKeyFactory = Factory.define(() => {
  return ed255193.utils.randomPrivateKey();
});
var Ed25519PublicKeyFactory = Factory.define(() => {
  const privateKey = Ed25519PrivateKeyFactory.build();
  return ed255193.getPublicKey(privateKey);
});
var Ed25519SignerFactory = Factory.define(() => {
  return new NobleEd25519Signer(Ed25519PrivateKeyFactory.build());
});
var Ed25519SignatureFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 64 } });
});
var Eip712SignerFactory = Factory.define(({ transientParams }) => {
  var _a;
  const account = (_a = transientParams.account) != null ? _a : privateKeyToAccount(generatePrivateKey());
  return new ViemLocalEip712Signer(account);
});
var Eip712SignatureFactory = Factory.define(() => {
  return BytesFactory.build(void 0, { transient: { length: 65 } });
});
var CastIdFactory = Factory.define(() => {
  return CastId.create({
    fid: FidFactory.build(),
    hash: MessageHashFactory.build()
  });
});
var FarcasterNetworkFactory = Factory.define(() => {
  return faker.helpers.arrayElement([
    3 /* DEVNET */,
    1 /* MAINNET */,
    2 /* TESTNET */
  ]);
});
var ReactionTypeFactory = Factory.define(() => {
  return faker.helpers.arrayElement([1 /* LIKE */, 2 /* RECAST */]);
});
var UserDataTypeFactory = Factory.define(() => {
  return faker.helpers.arrayElement([
    3 /* BIO */,
    2 /* DISPLAY */,
    6 /* USERNAME */,
    1 /* PFP */,
    5 /* URL */
  ]);
});
var MessageTypeFactory = Factory.define(() => {
  return faker.helpers.arrayElement([
    1 /* CAST_ADD */,
    2 /* CAST_REMOVE */,
    3 /* REACTION_ADD */,
    4 /* REACTION_REMOVE */,
    11 /* USER_DATA_ADD */,
    7 /* VERIFICATION_ADD_ETH_ADDRESS */,
    8 /* VERIFICATION_REMOVE */
  ]);
});
var MessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate(async (message) => {
      var _a;
      if (!message.data) {
        return message;
      }
      const dataBytes = MessageData.encode(message.data).finish();
      if (message.hash.length === 0) {
        message.hash = blake33(dataBytes, { dkLen: 20 });
      }
      const signer = (_a = transientParams.signer) != null ? _a : Ed25519SignerFactory.build();
      if (message.signature.length === 0) {
        message.signature = (await signer.signMessageHash(message.hash))._unsafeUnwrap();
      }
      if (!message.signatureScheme) {
        message.signatureScheme = signer.scheme;
      }
      if (message.signer.length === 0) {
        message.signer = (await signer.getSignerKey())._unsafeUnwrap();
      }
      return message;
    });
    return Message.create({
      data: CastAddDataFactory.build(),
      hashScheme: 1 /* BLAKE3 */
    });
  }
);
var MessageDataFactory = Factory.define(() => {
  return MessageData.create({
    fid: FidFactory.build(),
    timestamp: getFarcasterTime()._unsafeUnwrap(),
    network: 2 /* TESTNET */
  });
});
var CastIdEmbedFactory = Factory.define(() => {
  return Embed.create({ castId: CastIdFactory.build() });
});
var UrlEmbedFactory = Factory.define(() => {
  return Embed.create({ url: faker.internet.url() });
});
var EmbedFactory = Factory.define(() => {
  return faker.helpers.arrayElement([CastIdEmbedFactory.build(), UrlEmbedFactory.build()]);
});
var CastAddBodyFactory = Factory.define(() => {
  const text = faker.lorem.sentence(12);
  return CastAddBody.create({
    embeds: [EmbedFactory.build(), EmbedFactory.build()],
    mentions: [FidFactory.build(), FidFactory.build(), FidFactory.build()],
    mentionsPositions: [0, Math.floor(text.length / 2), text.length],
    // Hack to avoid duplicates
    parentCastId: CastIdFactory.build(),
    text
  });
});
var CastAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    castAddBody: CastAddBodyFactory.build(),
    type: 1 /* CAST_ADD */
  });
});
var CastAddMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: CastAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var CastRemoveBodyFactory = Factory.define(() => {
  return CastRemoveBody.create({
    targetHash: MessageHashFactory.build()
  });
});
var CastRemoveDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    castRemoveBody: CastRemoveBodyFactory.build(),
    type: 2 /* CAST_REMOVE */
  });
});
var CastRemoveMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: CastRemoveDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var LinkCompactStateBodyFactory = Factory.define(() => {
  return LinkCompactStateBody.create({
    targetFids: [FidFactory.build()],
    type: "follow"
  });
});
var LinkBodyFactory = Factory.define(() => {
  return LinkBody.create({
    targetFid: FidFactory.build(),
    type: "follow"
  });
});
var LinkCompactStateAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    linkCompactStateBody: LinkCompactStateBodyFactory.build(),
    type: 14 /* LINK_COMPACT_STATE */
  });
});
var LinkAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    linkBody: LinkBodyFactory.build(),
    type: 5 /* LINK_ADD */
  });
});
var LinkCompactStateMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, {
        transient: transientParams
      });
    });
    return MessageFactory.build(
      { data: LinkCompactStateAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var LinkAddMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: LinkAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var LinkRemoveDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    linkBody: LinkBodyFactory.build(),
    type: 6 /* LINK_REMOVE */
  });
});
var LinkRemoveMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: LinkRemoveDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var ReactionBodyFactory = Factory.define(() => {
  return ReactionBody.create({
    targetCastId: CastIdFactory.build(),
    type: ReactionTypeFactory.build()
  });
});
var ReactionAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    reactionBody: ReactionBodyFactory.build(),
    type: 3 /* REACTION_ADD */
  });
});
var ReactionAddMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: ReactionAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var ReactionRemoveDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    reactionBody: ReactionBodyFactory.build(),
    type: 4 /* REACTION_REMOVE */
  });
});
var ReactionRemoveMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: ReactionRemoveDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var VerificationSolAddressClaimFactory = Factory.define(() => {
  const address = bytesToBase58(SolAddressFactory.build())._unsafeUnwrap();
  const blockHash = bytesToBase58(BlockHashFactory.build())._unsafeUnwrap();
  if (base58ToBytes(address)._unsafeUnwrap().length !== 32) {
    throw new Error(`Bad address: ${address}`);
  }
  return {
    fid: BigInt(FidFactory.build()),
    address,
    network: FarcasterNetworkFactory.build(),
    blockHash,
    protocol: 1 /* SOLANA */
  };
});
var VerificationEthAddressClaimFactory = Factory.define(() => {
  const address = bytesToHexString(EthAddressFactory.build())._unsafeUnwrap();
  const blockHash = bytesToHexString(BlockHashFactory.build())._unsafeUnwrap();
  return {
    fid: BigInt(FidFactory.build()),
    address,
    network: FarcasterNetworkFactory.build(),
    blockHash,
    protocol: 0 /* ETHEREUM */
  };
});
var VerificationAddAddressBodyFactory = Factory.define(({ onCreate, transientParams }) => {
  onCreate(async (body) => {
    var _a, _b, _c, _d, _e, _f;
    switch (transientParams.protocol) {
      case 0 /* ETHEREUM */: {
        const ethSigner = (_a = transientParams.signer) != null ? _a : Eip712SignerFactory.build();
        if (!transientParams.contractSignature) {
          body.address = (await ethSigner.getSignerKey())._unsafeUnwrap();
        }
        if (body.claimSignature.length === 0) {
          const fid = (_b = transientParams.fid) != null ? _b : FidFactory.build();
          const network = (_c = transientParams.network) != null ? _c : FarcasterNetworkFactory.build();
          const blockHash = bytesToHexString(body.blockHash);
          const claim = VerificationEthAddressClaimFactory.build({
            fid: BigInt(fid),
            network,
            blockHash: blockHash.isOk() ? blockHash.value : "0x",
            address: bytesToHexString(body.address)._unsafeUnwrap(),
            protocol: 0 /* ETHEREUM */
          });
          body.claimSignature = (await ethSigner.signVerificationEthAddressClaim(claim, body.chainId))._unsafeUnwrap();
        }
        body.protocol = 0 /* ETHEREUM */;
        return body;
      }
      case 1 /* SOLANA */: {
        const solSigner = (_d = transientParams.signer) != null ? _d : Ed25519SignerFactory.build();
        body.address = (await solSigner.getSignerKey())._unsafeUnwrap();
        if (body.claimSignature.length === 0) {
          const fid = (_e = transientParams.fid) != null ? _e : FidFactory.build();
          const network = (_f = transientParams.network) != null ? _f : FarcasterNetworkFactory.build();
          const blockHash = body.blockHash;
          const claim = VerificationSolAddressClaimFactory.build({
            fid: toBigInt(fid),
            network,
            blockHash: bytesToBase58(blockHash)._unsafeUnwrap(),
            address: bytesToBase58(body.address)._unsafeUnwrap(),
            protocol: 1 /* SOLANA */
          });
          const fullMessage = recreateSolanaClaimMessage(claim, body.address);
          body.claimSignature = hexToBytes2(bytesToHex10((await solSigner.signMessageHash(fullMessage))._unsafeUnwrap()));
        }
        body.protocol = 1 /* SOLANA */;
        return body;
      }
      default:
        throw new Error(`Unsupported protocol [found: ${transientParams.protocol}]`);
    }
  });
  return VerificationAddAddressBody.create({
    address: EthAddressFactory.build(),
    blockHash: BlockHashFactory.build()
  });
});
var VerificationAddSolAddressDataFactory = Factory.define(({ onCreate, transientParams }) => {
  onCreate(async (data) => {
    const body = data.verificationAddAddressBody;
    if (body.claimSignature.length === 0) {
      data.verificationAddAddressBody = await VerificationAddAddressBodyFactory.create(body, {
        transient: {
          fid: data.fid,
          network: data.network,
          signer: transientParams.signer,
          protocol: 1 /* SOLANA */
        }
      });
    }
    return data;
  });
  return MessageDataFactory.build({
    // verificationAddEthAddressBody will not be valid until onCreate
    verificationAddAddressBody: VerificationAddAddressBodyFactory.build(
      { protocol: 1 /* SOLANA */ },
      { transient: { protocol: 1 /* SOLANA */ } }
    ),
    type: 7 /* VERIFICATION_ADD_ETH_ADDRESS */
  });
});
var VerificationAddSolAddressMessageFactory = Factory.define(({ onCreate, transientParams, params }) => {
  var _a;
  const signer = (_a = transientParams.signer) != null ? _a : Ed25519SignerFactory.build();
  onCreate(async (message) => {
    message.data = await VerificationAddSolAddressDataFactory.create(message.data, {
      transient: { signer: transientParams.signer }
    });
    return MessageFactory.create(message, {
      transient: { signer }
    });
  });
  return MessageFactory.build(
    {
      data: VerificationAddSolAddressDataFactory.build(params.data, {
        transient: { signer: transientParams.signer }
      })
    },
    { transient: { signer } }
  );
});
var VerificationAddEthAddressDataFactory = Factory.define(({ onCreate, transientParams }) => {
  onCreate(async (data) => {
    const body = data.verificationAddAddressBody;
    if (body.claimSignature.length === 0) {
      data.verificationAddAddressBody = await VerificationAddAddressBodyFactory.create(body, {
        transient: {
          fid: data.fid,
          network: data.network,
          signer: transientParams.signer,
          protocol: 0 /* ETHEREUM */
        }
      });
    }
    return data;
  });
  return MessageDataFactory.build({
    // verificationAddEthAddressBody will not be valid until onCreate
    verificationAddAddressBody: VerificationAddAddressBodyFactory.build({ protocol: 0 /* ETHEREUM */ }),
    type: 7 /* VERIFICATION_ADD_ETH_ADDRESS */
  });
});
var VerificationAddEthAddressMessageFactory = Factory.define(({ onCreate, transientParams, params }) => {
  var _a;
  const signer = (_a = transientParams.signer) != null ? _a : Ed25519SignerFactory.build();
  onCreate(async (message) => {
    message.data = await VerificationAddEthAddressDataFactory.create(message.data, {
      transient: { signer: transientParams.ethSigner }
    });
    return MessageFactory.create(message, {
      transient: { signer }
    });
  });
  return MessageFactory.build(
    {
      data: VerificationAddEthAddressDataFactory.build(params.data, {
        transient: { signer: transientParams.ethSigner }
      })
    },
    { transient: { signer } }
  );
});
var VerificationRemoveBodyFactory = Factory.define(({ params }) => {
  switch (params.protocol) {
    case 0 /* ETHEREUM */:
      return VerificationRemoveBody.create({
        address: EthAddressFactory.build(),
        protocol: 0 /* ETHEREUM */
      });
    case 1 /* SOLANA */:
      return VerificationRemoveBody.create({
        address: SolAddressFactory.build(),
        protocol: 1 /* SOLANA */
      });
    default:
      throw new Error(`Unsupported protocol [found: ${params.protocol}]`);
  }
});
var VerificationRemoveDataFactory = MessageDataFactory.params({
  verificationRemoveBody: VerificationRemoveBodyFactory.build({ protocol: 0 /* ETHEREUM */ }),
  type: 8 /* VERIFICATION_REMOVE */
});
var VerificationRemoveMessageFactory = MessageFactory.params({
  data: VerificationRemoveDataFactory.build(),
  signatureScheme: 1 /* ED25519 */
});
var UserDataBodyFactory = Factory.define(() => {
  return UserDataBody.create({
    type: UserDataTypeFactory.build(),
    value: faker.random.alphaNumeric(16)
    // 16 chars to stay within range for all UserDataAdd types
  });
});
var UserDataAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    userDataBody: UserDataBodyFactory.build(),
    type: 11 /* USER_DATA_ADD */
  });
});
var UserDataAddMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: UserDataAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var UsernameProofDataFactory = Factory.define(() => {
  const proofBody = UserNameProofFactory.build({
    type: 2 /* USERNAME_TYPE_ENS_L1 */,
    name: EnsNameFactory.build()
  });
  return MessageDataFactory.build({
    usernameProofBody: proofBody,
    type: 12 /* USERNAME_PROOF */,
    // Proof timestamp is in Unix seconds
    timestamp: toFarcasterTime(proofBody.timestamp * 1e3)._unsafeUnwrap(),
    fid: proofBody.fid
  });
});
var UsernameProofMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: UsernameProofDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var FrameActionBodyFactory = Factory.define(() => {
  return FrameActionBody.create({
    url: Buffer.from(faker.internet.url()),
    buttonIndex: faker.datatype.number({ min: 1, max: 4 }),
    castId: CastIdFactory.build()
  });
});
var FrameActionDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    frameActionBody: FrameActionBodyFactory.build(),
    type: 13 /* FRAME_ACTION */
  });
});
var FrameActionMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: FrameActionDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var OnChainEventFactory = Factory.define(() => {
  return OnChainEvent.create({
    type: 1 /* EVENT_TYPE_SIGNER */,
    chainId: 1,
    fid: FidFactory.build(),
    blockNumber: faker.datatype.number({ min: 1, max: 1e5 }),
    blockHash: BlockHashFactory.build(),
    blockTimestamp: Math.floor(faker.datatype.datetime({ min: FARCASTER_EPOCH, max: Date.now() }).getTime() / 1e3),
    transactionHash: TransactionHashFactory.build(),
    logIndex: faker.datatype.number({ min: 0, max: 1e3 })
  });
});
var UserNameProofFactory = Factory.define(() => {
  return UserNameProof.create({
    timestamp: Math.floor(Date.now() / 1e3),
    signature: Eip712SignatureFactory.build(),
    owner: EthAddressFactory.build(),
    name: FnameFactory.build(),
    fid: FidFactory.build(),
    type: 1 /* USERNAME_TYPE_FNAME */
  });
});
var SignerEventBodyFactory = Factory.define(() => {
  return SignerEventBody.create({
    key: Ed25519PublicKeyFactory.build(),
    eventType: 1 /* ADD */,
    keyType: 1,
    metadataType: 1
  });
});
var SignerOnChainEventFactory = Factory.define(({ transientParams }) => {
  return OnChainEventFactory.build({
    type: 1 /* EVENT_TYPE_SIGNER */,
    signerEventBody: transientParams.signer ? SignerEventBodyFactory.build({ key: transientParams.signer }) : SignerEventBodyFactory.build()
  });
});
var IdRegisterEventBodyFactory = Factory.define(() => {
  return IdRegisterEventBody.create({
    eventType: 1 /* REGISTER */,
    from: EthAddressFactory.build()
  });
});
var IdRegisterOnChainEventFactory = Factory.define(
  ({ transientParams }) => {
    return OnChainEventFactory.build({
      type: 3 /* EVENT_TYPE_ID_REGISTER */,
      idRegisterEventBody: transientParams.to ? IdRegisterEventBodyFactory.build({ to: transientParams.to }) : IdRegisterEventBodyFactory.build()
    });
  }
);
var SignerMigratedOnChainEventFactory = Factory.define(() => {
  return OnChainEventFactory.build({
    type: 2 /* EVENT_TYPE_SIGNER_MIGRATED */,
    fid: 0,
    signerMigratedEventBody: SignerMigratedEventBody.create({
      migratedAt: Math.floor(Date.now() / 1e3) + 48 * 60 * 60
      // Default to 48 hours in the future so pruning is not enabled
    })
  });
});
var StorageRentEventBodyFactory = Factory.define(() => {
  return StorageRentEventBody.create({
    payer: EthAddressFactory.build(),
    units: faker.datatype.number({ min: 1, max: 10 }),
    expiry: getFarcasterTime()._unsafeUnwrap() + 60 * 60 * 24 * 365
    // a year
  });
});
var StorageRentOnChainEventFactory = Factory.define(
  ({ transientParams }) => {
    const oneYearAgo = /* @__PURE__ */ new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
    const yesterday = /* @__PURE__ */ new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const randomDate = faker.date.between(oneYearAgo, yesterday);
    const randomDateInSeconds = Math.floor(randomDate.getTime() / 1e3);
    return OnChainEventFactory.build({
      type: 4 /* EVENT_TYPE_STORAGE_RENT */,
      blockTimestamp: randomDateInSeconds,
      storageRentEventBody: transientParams.units ? StorageRentEventBodyFactory.build({ units: transientParams.units }) : StorageRentEventBodyFactory.build()
    });
  }
);
var Factories = {
  Fid: FidFactory,
  Fname: FnameFactory,
  Bytes: BytesFactory,
  MessageHash: MessageHashFactory,
  BlockHash: BlockHashFactory,
  EthAddress: EthAddressFactory,
  SolAddress: SolAddressFactory,
  EnsName: EnsNameFactory,
  TransactionHash: TransactionHashFactory,
  Ed25519PrivateKey: Ed25519PrivateKeyFactory,
  Ed25519PublicKey: Ed25519PublicKeyFactory,
  Ed25519Signer: Ed25519SignerFactory,
  Ed25519Signature: Ed25519SignatureFactory,
  Eip712Signer: Eip712SignerFactory,
  Eip712Signature: Eip712SignatureFactory,
  CastId: CastIdFactory,
  FarcasterNetwork: FarcasterNetworkFactory,
  ReactionType: ReactionTypeFactory,
  MessageType: MessageTypeFactory,
  MessageData: MessageDataFactory,
  Message: MessageFactory,
  CastIdEmbed: CastIdEmbedFactory,
  UrlEmbed: UrlEmbedFactory,
  Embed: EmbedFactory,
  CastAddBody: CastAddBodyFactory,
  CastAddData: CastAddDataFactory,
  CastAddMessage: CastAddMessageFactory,
  CastRemoveBody: CastRemoveBodyFactory,
  CastRemoveData: CastRemoveDataFactory,
  CastRemoveMessage: CastRemoveMessageFactory,
  FrameActionBody: FrameActionBodyFactory,
  FrameActionData: FrameActionDataFactory,
  FrameActionMessage: FrameActionMessageFactory,
  LinkBody: LinkBodyFactory,
  LinkAddData: LinkAddDataFactory,
  LinkAddMessage: LinkAddMessageFactory,
  LinkRemoveData: LinkRemoveDataFactory,
  LinkRemoveMessage: LinkRemoveMessageFactory,
  LinkCompactStateMessage: LinkCompactStateMessageFactory,
  ReactionBody: ReactionBodyFactory,
  ReactionAddData: ReactionAddDataFactory,
  ReactionAddMessage: ReactionAddMessageFactory,
  ReactionRemoveData: ReactionRemoveDataFactory,
  ReactionRemoveMessage: ReactionRemoveMessageFactory,
  VerificationEthAddressClaim: VerificationEthAddressClaimFactory,
  VerificationAddAddressBody: VerificationAddAddressBodyFactory,
  VerificationAddEthAddressData: VerificationAddEthAddressDataFactory,
  VerificationAddEthAddressMessage: VerificationAddEthAddressMessageFactory,
  VerificationSolAddressClaim: VerificationSolAddressClaimFactory,
  VerificationAddSolAddressData: VerificationAddSolAddressDataFactory,
  VerificationAddSolAddressMessage: VerificationAddSolAddressMessageFactory,
  VerificationRemoveBody: VerificationRemoveBodyFactory,
  VerificationRemoveData: VerificationRemoveDataFactory,
  VerificationRemoveMessage: VerificationRemoveMessageFactory,
  UserDataBody: UserDataBodyFactory,
  UserDataAddData: UserDataAddDataFactory,
  UserDataAddMessage: UserDataAddMessageFactory,
  UserNameProof: UserNameProofFactory,
  UsernameProofData: UsernameProofDataFactory,
  UsernameProofMessage: UsernameProofMessageFactory,
  OnChainEvent: OnChainEventFactory,
  SignerEventBody: SignerEventBodyFactory,
  SignerOnChainEvent: SignerOnChainEventFactory,
  IdRegistryOnChainEvent: IdRegisterOnChainEventFactory,
  IdRegistryEventBody: IdRegisterEventBodyFactory,
  SignerMigratedOnChainEvent: SignerMigratedOnChainEventFactory,
  StorageRentEventBody: StorageRentEventBodyFactory,
  StorageRentOnChainEvent: StorageRentOnChainEventFactory
};

// src/userNameProof.ts
init_esm_shims();
var makeUserNameProofClaim = ({
  name,
  owner,
  timestamp
}) => {
  return {
    name,
    owner,
    timestamp: BigInt(timestamp)
  };
};

// src/limits.ts
init_esm_shims();
var LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP = 1724889600;
var ONE_YEAR_IN_SECONDS = 365 * 24 * 60 * 60;
var STORAGE_UNIT_DEFAULTS = {
  [1 /* CASTS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 5e3,
    [1 /* UNIT_TYPE_2024 */]: 2e3
  },
  [2 /* LINKS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 2500,
    [1 /* UNIT_TYPE_2024 */]: 1e3
  },
  [3 /* REACTIONS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 2500,
    [1 /* UNIT_TYPE_2024 */]: 1e3
  },
  [4 /* USER_DATA */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 50,
    [1 /* UNIT_TYPE_2024 */]: 50
  },
  [6 /* USERNAME_PROOFS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 5,
    [1 /* UNIT_TYPE_2024 */]: 5
  },
  [5 /* VERIFICATIONS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 25,
    [1 /* UNIT_TYPE_2024 */]: 25
  },
  [0 /* NONE */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 0,
    [1 /* UNIT_TYPE_2024 */]: 0
  }
};
var getStoreLimits = (unit_details) => [
  {
    storeType: 1 /* CASTS */,
    limit: getStoreLimit(1 /* CASTS */, unit_details)
  },
  {
    storeType: 2 /* LINKS */,
    limit: getStoreLimit(2 /* LINKS */, unit_details)
  },
  {
    storeType: 3 /* REACTIONS */,
    limit: getStoreLimit(3 /* REACTIONS */, unit_details)
  },
  {
    storeType: 4 /* USER_DATA */,
    limit: getStoreLimit(4 /* USER_DATA */, unit_details)
  },
  {
    storeType: 6 /* USERNAME_PROOFS */,
    limit: getStoreLimit(6 /* USERNAME_PROOFS */, unit_details)
  },
  {
    storeType: 5 /* VERIFICATIONS */,
    limit: getStoreLimit(5 /* VERIFICATIONS */, unit_details)
  }
];
var getStoreLimit = (storeType, unit_details) => {
  let limit = 0;
  for (const unit of unit_details) {
    limit += getDefaultStoreLimit(storeType, unit.unitType) * unit.unitSize;
  }
  return limit;
};
var getDefaultStoreLimit = (storeType, unit_type) => {
  return STORAGE_UNIT_DEFAULTS[storeType][unit_type];
};
var getStorageUnitType = (event) => {
  if (event.blockTimestamp < LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP) {
    return 0 /* UNIT_TYPE_LEGACY */;
  } else {
    return 1 /* UNIT_TYPE_2024 */;
  }
};
var getStorageUnitExpiry = (event) => {
  if (event.blockTimestamp < LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP) {
    return event.blockTimestamp + ONE_YEAR_IN_SECONDS * 2;
  } else {
    return event.blockTimestamp + ONE_YEAR_IN_SECONDS;
  }
};
export {
  AckMessageBody,
  BUNDLER_ADDRESS,
  BulkMessageResponse,
  CastAddBody,
  CastId,
  CastRemoveBody,
  CastType,
  CastsByParentRequest,
  ContactInfoContent,
  ContactInfoContentBody,
  ContactInfoResponse,
  DbStats,
  DbTrieNode,
  Ed25519Signer,
  Eip712Signer,
  Embed,
  Empty,
  EthersEip712Signer,
  EthersV5Eip712Signer,
  EventRequest,
  FARCASTER_EPOCH,
  Factories,
  FarcasterNetwork,
  FidRequest,
  FidTimestampRequest,
  FidsRequest,
  FidsResponse,
  FrameActionBody,
  GossipAddressInfo,
  GossipMessage,
  GossipVersion,
  HashScheme,
  HubError,
  HubEvent,
  HubEventType,
  HubInfoRequest,
  HubInfoResponse,
  HubState,
  ID_GATEWAY_ADDRESS,
  ID_GATEWAY_EIP_712_DOMAIN,
  ID_GATEWAY_EIP_712_TYPES,
  ID_GATEWAY_REGISTER_TYPE,
  ID_REGISTRY_ADDRESS,
  ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE,
  ID_REGISTRY_EIP_712_DOMAIN,
  ID_REGISTRY_EIP_712_TYPES,
  ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE,
  ID_REGISTRY_TRANSFER_TYPE,
  IdRegisterEventBody,
  IdRegisterEventType,
  IdRegistryEventByAddressRequest,
  KEY_GATEWAY_ADDRESS,
  KEY_GATEWAY_ADD_TYPE,
  KEY_GATEWAY_EIP_712_DOMAIN,
  KEY_GATEWAY_EIP_712_TYPES,
  KEY_REGISTRY_ADDRESS,
  KEY_REGISTRY_EIP_712_DOMAIN,
  KEY_REGISTRY_EIP_712_TYPES,
  KEY_REGISTRY_REMOVE_TYPE,
  LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP,
  LinkBody,
  LinkCompactStateBody,
  LinkRequest,
  LinksByFidRequest,
  LinksByTargetRequest,
  MergeMessageBody,
  MergeOnChainEventBody,
  MergeUserNameProofBody,
  Message,
  MessageBundle,
  MessageData,
  MessageError,
  MessageType,
  MessagesResponse,
  NameRegistryEventRequest,
  NetworkLatencyMessage,
  NobleEd25519Signer,
  OnChainEvent,
  OnChainEventRequest,
  OnChainEventResponse,
  OnChainEventType,
  PingMessageBody,
  Protocol,
  PruneMessageBody,
  ReactionBody,
  ReactionRequest,
  ReactionType,
  ReactionsByFidRequest,
  ReactionsByTargetRequest,
  RentRegistryEventsRequest,
  RevokeMessageBody,
  RevokeMessagesBySignerJobPayload,
  SIGNED_KEY_REQUEST_TYPE,
  SIGNED_KEY_REQUEST_VALIDATOR_ADDRESS,
  SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
  SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES,
  STORAGE_REGISTRY_ADDRESS,
  SignatureScheme,
  SignerEventBody,
  SignerEventType,
  SignerMigratedEventBody,
  SignerRequest,
  StorageLimit,
  StorageLimitsResponse,
  StorageRentEventBody,
  StorageUnitDetails,
  StorageUnitType,
  StoreType,
  StreamError,
  StreamFetchRequest,
  StreamFetchResponse,
  StreamSyncRequest,
  StreamSyncResponse,
  SubmitBulkMessagesRequest,
  SubmitBulkMessagesResponse,
  SubscribeRequest,
  SyncIds,
  SyncStatus,
  SyncStatusRequest,
  SyncStatusResponse,
  TrieNodeMetadataResponse,
  TrieNodePrefix,
  TrieNodeSnapshotResponse,
  UpdateNameRegistryEventExpiryJobPayload,
  UserDataBody,
  UserDataRequest,
  UserDataType,
  UserNameProof,
  UserNameType,
  UsernameProofRequest,
  UsernameProofsResponse,
  ValidateOrRevokeJobState,
  ValidationResponse,
  VerificationAddAddressBody,
  VerificationRemoveBody,
  VerificationRequest,
  ViemLocalEip712Signer,
  ViemWalletEip712Signer,
  base58ToBytes,
  bigIntToBytes,
  bundlerABI,
  bytesCompare,
  bytesDecrement,
  bytesIncrement,
  bytesStartsWith,
  bytesToBase58,
  bytesToBigInt,
  bytesToHexString,
  bytesToUtf8String,
  castTypeFromJSON,
  castTypeToJSON,
  chains_exports as chains,
  clients_exports as clients,
  ed25519_exports as ed25519,
  eip712_exports as eip712,
  extractEventTimestamp,
  farcasterNetworkFromJSON,
  farcasterNetworkToJSON,
  fromFarcasterTime,
  getDefaultStoreLimit,
  getFarcasterTime,
  getStorageUnitExpiry,
  getStorageUnitType,
  getStoreLimit,
  getStoreLimits,
  gossipVersionFromJSON,
  gossipVersionToJSON,
  hashSchemeFromJSON,
  hashSchemeToJSON,
  hexStringToBytes,
  hubEventTypeFromJSON,
  hubEventTypeToJSON,
  idGatewayABI,
  idRegisterEventTypeFromJSON,
  idRegisterEventTypeToJSON,
  idRegistryABI,
  isCastAddData,
  isCastAddMessage,
  isCastRemoveData,
  isCastRemoveMessage,
  isFrameActionData,
  isFrameActionMessage,
  isHubError,
  isIdRegisterOnChainEvent,
  isLinkAddData,
  isLinkAddMessage,
  isLinkCompactStateMessage,
  isLinkRemoveData,
  isLinkRemoveMessage,
  isMergeMessageHubEvent,
  isMergeOnChainHubEvent,
  isMergeUsernameProofHubEvent,
  isPruneMessageHubEvent,
  isReactionAddData,
  isReactionAddMessage,
  isReactionRemoveData,
  isReactionRemoveMessage,
  isRevokeMessageHubEvent,
  isSignerMigratedOnChainEvent,
  isSignerOnChainEvent,
  isStorageRentOnChainEvent,
  isUserDataAddData,
  isUserDataAddMessage,
  isUsernameProofData,
  isUsernameProofMessage,
  isVerificationAddAddressData,
  isVerificationAddAddressMessage,
  isVerificationRemoveData,
  isVerificationRemoveMessage,
  keyGatewayABI,
  keyRegistryABI,
  makeCastAdd,
  makeCastAddData,
  makeCastRemove,
  makeCastRemoveData,
  makeEventId,
  makeFrameAction,
  makeFrameActionData,
  makeLinkAdd,
  makeLinkAddData,
  makeLinkCompactState,
  makeLinkCompactStateData,
  makeLinkRemove,
  makeLinkRemoveData,
  makeMessage,
  makeMessageHash,
  makeMessageWithSignature,
  makeReactionAdd,
  makeReactionAddData,
  makeReactionRemove,
  makeReactionRemoveData,
  makeUserDataAdd,
  makeUserDataAddData,
  makeUserNameProofClaim,
  makeUsernameProof,
  makeUsernameProofData,
  makeVerificationAddEthAddress,
  makeVerificationAddEthAddressData,
  makeVerificationAddressClaim,
  makeVerificationRemove,
  makeVerificationRemoveData,
  messageTypeFromJSON,
  messageTypeToJSON,
  onChainEventTypeFromJSON,
  onChainEventTypeToJSON,
  protocolFromJSON,
  protocolToJSON,
  reactionTypeFromJSON,
  reactionTypeToJSON,
  recreateSolanaClaimMessage,
  signatureSchemeFromJSON,
  signatureSchemeToJSON,
  signedKeyRequestValidatorABI,
  signerEventTypeFromJSON,
  signerEventTypeToJSON,
  storageRegistryABI,
  storageUnitTypeFromJSON,
  storageUnitTypeToJSON,
  storeTypeFromJSON,
  storeTypeToJSON,
  toFarcasterTime,
  userDataTypeFromJSON,
  userDataTypeToJSON,
  userNameTypeFromJSON,
  userNameTypeToJSON,
  utf8StringToBytes,
  validations_exports as validations,
  verifyAdd,
  verifyChangeRecoveryAddress,
  verifyKeyRequest,
  verifyRegister,
  verifyRemove,
  verifyTransfer,
  verifyTransferAndChangeRecovery
};
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)

@farcaster/fishery/dist/fishery.mjs:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
